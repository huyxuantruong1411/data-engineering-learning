Directory structure:
└── jikan-me-jikan-rest/
    ├── README.MD
    ├── artisan
    ├── COMMANDS.MD
    ├── composer.json
    ├── container-setup.sh
    ├── container_usage.md
    ├── docker-compose.yml
    ├── docker-entrypoint.php
    ├── docker-entrypoint.sh
    ├── Dockerfile
    ├── LICENSE
    ├── phpunit.xml
    ├── TROUBLESHOOTING.md
    ├── .codecov.yml
    ├── .dockerignore
    ├── .editorconfig
    ├── .env.dist
    ├── .rr.local.unix.yaml
    ├── .rr.local.yaml
    ├── .rr.yaml
    ├── app/
    │   ├── Anime.php
    │   ├── CarbonDateRange.php
    │   ├── Character.php
    │   ├── Club.php
    │   ├── Episode.php
    │   ├── GenreAnime.php
    │   ├── GenreManga.php
    │   ├── IsoDateFormatter.php
    │   ├── JikanApiModel.php
    │   ├── JikanApiSearchableModel.php
    │   ├── JikanSearchable.php
    │   ├── Magazine.php
    │   ├── Manga.php
    │   ├── Person.php
    │   ├── Producers.php
    │   ├── Profile.php
    │   ├── SearchMetric.php
    │   ├── User.php
    │   ├── Casts/
    │   │   ├── ContextualBooleanCast.php
    │   │   └── EnumCast.php
    │   ├── Concerns/
    │   │   ├── FilteredByLetter.php
    │   │   ├── HasRequestFingerprint.php
    │   │   ├── MediaFilters.php
    │   │   ├── ResolvesPaginatorParams.php
    │   │   └── ScraperCacheTtl.php
    │   ├── Console/
    │   │   ├── Kernel.php
    │   │   └── Commands/
    │   │       ├── CacheRemove.php
    │   │       ├── .gitkeep
    │   │       └── Indexer/
    │   │           ├── AnimeIndexer.php
    │   │           ├── AnimeScheduleIndexer.php
    │   │           ├── AnimeSweepIndexer.php
    │   │           ├── CommonIndexer.php
    │   │           ├── CurrentSeasonIndexer.php
    │   │           ├── GenreIndexer.php
    │   │           ├── IncrementalIndexer.php
    │   │           ├── MangaIndexer.php
    │   │           ├── MangaSweepIndexer.php
    │   │           └── ProducersIndexer.php
    │   ├── Contracts/
    │   │   ├── AnimeRepository.php
    │   │   ├── CachedScraperService.php
    │   │   ├── CharacterRepository.php
    │   │   ├── ClubRepository.php
    │   │   ├── DataRequest.php
    │   │   ├── GenreRepository.php
    │   │   ├── MagazineRepository.php
    │   │   ├── MangaRepository.php
    │   │   ├── Mediator.php
    │   │   ├── PeopleRepository.php
    │   │   ├── ProducerRepository.php
    │   │   ├── Repository.php
    │   │   ├── RepositoryQuery.php
    │   │   ├── RequestHandler.php
    │   │   ├── SearchAnalyticsService.php
    │   │   ├── UnitOfWork.php
    │   │   └── UserRepository.php
    │   ├── DataPipes/
    │   │   └── MapRouteParametersDataPipe.php
    │   ├── Dto/
    │   │   ├── AnimeCharactersLookupCommand.php
    │   │   ├── AnimeEpisodeLookupCommand.php
    │   │   ├── AnimeEpisodesLookupCommand.php
    │   │   ├── AnimeExternalLookupCommand.php
    │   │   ├── AnimeForumLookupCommand.php
    │   │   ├── AnimeFullLookupCommand.php
    │   │   ├── AnimeGenreListCommand.php
    │   │   ├── AnimeLookupCommand.php
    │   │   ├── AnimeMoreInfoLookupCommand.php
    │   │   ├── AnimeNewsLookupCommand.php
    │   │   ├── AnimePicturesLookupCommand.php
    │   │   ├── AnimeRecommendationsLookupCommand.php
    │   │   ├── AnimeRelationsLookupCommand.php
    │   │   ├── AnimeReviewsLookupCommand.php
    │   │   ├── AnimeSearchCommand.php
    │   │   ├── AnimeStaffLookupCommand.php
    │   │   ├── AnimeStatsLookupCommand.php
    │   │   ├── AnimeStreamingLookupCommand.php
    │   │   ├── AnimeThemesLookupCommand.php
    │   │   ├── AnimeUserUpdatesLookupCommand.php
    │   │   ├── AnimeVideosEpisodesLookupCommand.php
    │   │   ├── AnimeVideosLookupCommand.php
    │   │   ├── CharacterAnimeLookupCommand.php
    │   │   ├── CharacterFullLookupCommand.php
    │   │   ├── CharacterLookupCommand.php
    │   │   ├── CharacterMangaLookupCommand.php
    │   │   ├── CharacterPicturesLookupCommand.php
    │   │   ├── CharactersSearchCommand.php
    │   │   ├── CharacterVoicesLookupCommand.php
    │   │   ├── ClubLookupCommand.php
    │   │   ├── ClubMembersLookupCommand.php
    │   │   ├── ClubRelationLookupCommand.php
    │   │   ├── ClubSearchCommand.php
    │   │   ├── ClubStaffLookupCommand.php
    │   │   ├── GenreListCommand.php
    │   │   ├── LookupByUsernameCommand.php
    │   │   ├── LookupDataCommand.php
    │   │   ├── MagazineSearchCommand.php
    │   │   ├── MangaCharactersLookupCommand.php
    │   │   ├── MangaExternalLookupCommand.php
    │   │   ├── MangaForumLookupCommand.php
    │   │   ├── MangaFullLookupCommand.php
    │   │   ├── MangaGenreListCommand.php
    │   │   ├── MangaLookupCommand.php
    │   │   ├── MangaMoreInfoLookupCommand.php
    │   │   ├── MangaNewsLookupCommand.php
    │   │   ├── MangaPicturesLookupCommand.php
    │   │   ├── MangaRecommendationsLookupCommand.php
    │   │   ├── MangaRelationsLookupCommand.php
    │   │   ├── MangaReviewsLookupCommand.php
    │   │   ├── MangaSearchCommand.php
    │   │   ├── MangaStatsLookupCommand.php
    │   │   ├── MangaUserUpdatesLookupCommand.php
    │   │   ├── MediaSearchCommand.php
    │   │   ├── PeopleSearchCommand.php
    │   │   ├── PersonAnimeLookupCommand.php
    │   │   ├── PersonFullLookupCommand.php
    │   │   ├── PersonLookupCommand.php
    │   │   ├── PersonMangaLookupCommand.php
    │   │   ├── PersonPicturesLookupCommand.php
    │   │   ├── PersonVoicesLookupCommand.php
    │   │   ├── ProducerExternalLookupCommand.php
    │   │   ├── ProducerFullLookupCommand.php
    │   │   ├── ProducerLookupCommand.php
    │   │   ├── ProducersSearchCommand.php
    │   │   ├── QueryAnimeListOfUserCommand.php
    │   │   ├── QueryAnimeRecommendationsCommand.php
    │   │   ├── QueryAnimeReviewsCommand.php
    │   │   ├── QueryAnimeSchedulesCommand.php
    │   │   ├── QueryAnimeSeasonCommand.php
    │   │   ├── QueryAnimeSeasonListCommand.php
    │   │   ├── QueryCurrentAnimeSeasonCommand.php
    │   │   ├── QueryListOfUserCommand.php
    │   │   ├── QueryMangaListOfUserCommand.php
    │   │   ├── QueryMangaRecommendationsCommand.php
    │   │   ├── QueryMangaReviewsCommand.php
    │   │   ├── QueryPopularEpisodesCommand.php
    │   │   ├── QueryPopularPromoVideosCommand.php
    │   │   ├── QueryRandomAnimeCommand.php
    │   │   ├── QueryRandomCharacterCommand.php
    │   │   ├── QueryRandomMangaCommand.php
    │   │   ├── QueryRandomPersonCommand.php
    │   │   ├── QueryRandomUserCommand.php
    │   │   ├── QueryRecentlyAddedEpisodesCommand.php
    │   │   ├── QueryRecentlyAddedPromoVideosCommand.php
    │   │   ├── QueryRecentlyOnlineUsersCommand.php
    │   │   ├── QueryReviewsCommand.php
    │   │   ├── QuerySpecificAnimeSeasonCommand.php
    │   │   ├── QueryTopAnimeItemsCommand.php
    │   │   ├── QueryTopCharactersCommand.php
    │   │   ├── QueryTopItemsCommand.php
    │   │   ├── QueryTopMangaItemsCommand.php
    │   │   ├── QueryTopPeopleCommand.php
    │   │   ├── QueryTopReviewsCommand.php
    │   │   ├── QueryUpcomingAnimeSeasonCommand.php
    │   │   ├── SearchCommand.php
    │   │   ├── UserAboutLookupCommand.php
    │   │   ├── UserByIdLookupCommand.php
    │   │   ├── UserClubsLookupCommand.php
    │   │   ├── UserExternalLookupCommand.php
    │   │   ├── UserFavoritesLookupCommand.php
    │   │   ├── UserFriendsLookupCommand.php
    │   │   ├── UserFullLookupCommand.php
    │   │   ├── UserHistoryLookupCommand.php
    │   │   ├── UserProfileLookupCommand.php
    │   │   ├── UserRecommendationsLookupCommand.php
    │   │   ├── UserReviewsLookupCommand.php
    │   │   ├── UsersSearchCommand.php
    │   │   ├── UserStatisticsLookupCommand.php
    │   │   ├── UserUpdatesLookupCommand.php
    │   │   └── Concerns/
    │   │       ├── HasContinuingParameter.php
    │   │       ├── HasKidsParameter.php
    │   │       ├── HasLimitParameter.php
    │   │       ├── HasPageParameter.php
    │   │       ├── HasPreliminaryParameter.php
    │   │       ├── HasSfwParameter.php
    │   │       ├── HasSpoilersParameter.php
    │   │       ├── HasUnapprovedParameter.php
    │   │       ├── MapsRouteParameters.php
    │   │       └── PreparesData.php
    │   ├── Enums/
    │   │   ├── AnimeForumFilterEnum.php
    │   │   ├── AnimeListAiringStatusFilterEnum.php
    │   │   ├── AnimeListStatusEnum.php
    │   │   ├── AnimeOrderByEnum.php
    │   │   ├── AnimeRatingEnum.php
    │   │   ├── AnimeScheduleFilterEnum.php
    │   │   ├── AnimeSeasonEnum.php
    │   │   ├── AnimeStatusEnum.php
    │   │   ├── AnimeTypeEnum.php
    │   │   ├── CharacterOrderByEnum.php
    │   │   ├── ClubCategoryEnum.php
    │   │   ├── ClubOrderByEnum.php
    │   │   ├── ClubTypeEnum.php
    │   │   ├── GenderEnum.php
    │   │   ├── GenreFilterEnum.php
    │   │   ├── MagazineOrderByEnum.php
    │   │   ├── MangaForumFilterEnum.php
    │   │   ├── MangaListStatusEnum.php
    │   │   ├── MangaOrderByEnum.php
    │   │   ├── MangaStatusEnum.php
    │   │   ├── MangaTypeEnum.php
    │   │   ├── MediaReviewsSortEnum.php
    │   │   ├── PeopleOrderByEnum.php
    │   │   ├── ProducerOrderByEnum.php
    │   │   ├── ReviewTypeEnum.php
    │   │   ├── SortDirection.php
    │   │   ├── TopAnimeFilterEnum.php
    │   │   ├── TopMangaFilterEnum.php
    │   │   ├── TopReviewsTypeEnum.php
    │   │   ├── UserAnimeListOrderByEnum.php
    │   │   ├── UserHistoryTypeEnum.php
    │   │   ├── UserListTypeEnum.php
    │   │   ├── UserMangaListOrderByEnum.php
    │   │   └── UserMangaListStatusFilterEnum.php
    │   ├── Events/
    │   │   ├── Event.php
    │   │   ├── ExampleEvent.php
    │   │   └── SourceHeartbeatEvent.php
    │   ├── Exceptions/
    │   │   ├── CustomTestException.php
    │   │   ├── GithubReport.php
    │   │   ├── Handler.php
    │   │   └── Console/
    │   │       ├── CommandAlreadyRunningException.php
    │   │       └── FileNotFoundException.php
    │   ├── Features/
    │   │   ├── AnimeCharactersLookupHandler.php
    │   │   ├── AnimeEpisodeLookupHandler.php
    │   │   ├── AnimeEpisodesLookupHandler.php
    │   │   ├── AnimeExternalLookupHandler.php
    │   │   ├── AnimeForumLookupHandler.php
    │   │   ├── AnimeFullLookupHandler.php
    │   │   ├── AnimeGenreListHandler.php
    │   │   ├── AnimeLookupHandler.php
    │   │   ├── AnimeMoreInfoLookupHandler.php
    │   │   ├── AnimeNewsLookupHandler.php
    │   │   ├── AnimePicturesLookupHandler.php
    │   │   ├── AnimeRecommendationsLookupHandler.php
    │   │   ├── AnimeRelationsLookupHandler.php
    │   │   ├── AnimeReviewsLookupHandler.php
    │   │   ├── AnimeSearchHandler.php
    │   │   ├── AnimeStaffLookupHandler.php
    │   │   ├── AnimeStatsLookupHandler.php
    │   │   ├── AnimeStreamingLookupHandler.php
    │   │   ├── AnimeThemesLookupHandler.php
    │   │   ├── AnimeUserUpdatesLookupHandler.php
    │   │   ├── AnimeVideosEpisodesLookupHandler.php
    │   │   ├── AnimeVideosLookupHandler.php
    │   │   ├── CharacterAnimeLookupHandler.php
    │   │   ├── CharacterFullLookupHandler.php
    │   │   ├── CharacterLookupHandler.php
    │   │   ├── CharacterMangaLookupHandler.php
    │   │   ├── CharacterPicturesLookupHandler.php
    │   │   ├── CharacterSearchHandler.php
    │   │   ├── CharacterVoicesLookupHandler.php
    │   │   ├── ClubLookupHandler.php
    │   │   ├── ClubMembersLookupHandler.php
    │   │   ├── ClubRelationsLookupHandler.php
    │   │   ├── ClubSearchHandler.php
    │   │   ├── ClubStaffLookupHandler.php
    │   │   ├── GenreListHandler.php
    │   │   ├── ItemLookupHandler.php
    │   │   ├── MagazineSearchHandler.php
    │   │   ├── MangaCharactersLookupHandler.php
    │   │   ├── MangaExternalLookupHandler.php
    │   │   ├── MangaForumLookupHandler.php
    │   │   ├── MangaFullLookupHandler.php
    │   │   ├── MangaGenreListHandler.php
    │   │   ├── MangaLookupHandler.php
    │   │   ├── MangaMoreInfoLookupHandler.php
    │   │   ├── MangaNewsLookupHandler.php
    │   │   ├── MangaPicturesLookupHandler.php
    │   │   ├── MangaRecommendationsLookupHandler.php
    │   │   ├── MangaRelationsLookupHandler.php
    │   │   ├── MangaReviewsLookupHandler.php
    │   │   ├── MangaSearchHandler.php
    │   │   ├── MangaStatsLookupHandler.php
    │   │   ├── MangaUserUpdatesLookupHandler.php
    │   │   ├── PeopleSearchHandler.php
    │   │   ├── PersonAnimeLookupHandler.php
    │   │   ├── PersonFullLookupHandler.php
    │   │   ├── PersonLookupHandler.php
    │   │   ├── PersonMangaLookupHandler.php
    │   │   ├── PersonPicturesLookupHandler.php
    │   │   ├── PersonVoicesLookupHandler.php
    │   │   ├── ProducerExternalLookupHandler.php
    │   │   ├── ProducerFullLookupHandler.php
    │   │   ├── ProducerLookupHandler.php
    │   │   ├── ProducerSearchHandler.php
    │   │   ├── QueryAnimeListOfUserHandler.php
    │   │   ├── QueryAnimeRecommendationsHandler.php
    │   │   ├── QueryAnimeReviewsHandler.php
    │   │   ├── QueryAnimeSchedulesHandler.php
    │   │   ├── QueryAnimeSeasonHandlerBase.php
    │   │   ├── QueryAnimeSeasonListHandler.php
    │   │   ├── QueryCurrentAnimeSeasonHandler.php
    │   │   ├── QueryMangaListOfUserHandler.php
    │   │   ├── QueryMangaRecommendationsHandler.php
    │   │   ├── QueryMangaReviewsHandler.php
    │   │   ├── QueryPopularEpisodesHandler.php
    │   │   ├── QueryPopularPromoVideosHandler.php
    │   │   ├── QueryRandomAnimeHandler.php
    │   │   ├── QueryRandomCharacterHandler.php
    │   │   ├── QueryRandomItemHandler.php
    │   │   ├── QueryRandomMangaHandler.php
    │   │   ├── QueryRandomPersonHandler.php
    │   │   ├── QueryRandomUserHandler.php
    │   │   ├── QueryRecentlyAddedEpisodesHandler.php
    │   │   ├── QueryRecentlyAddedPromoVideosHandler.php
    │   │   ├── QueryRecentlyOnlineUsersHandler.php
    │   │   ├── QueryRecommendationsHandler.php
    │   │   ├── QueryReviewsHandler.php
    │   │   ├── QuerySpecificAnimeSeasonHandler.php
    │   │   ├── QueryTopAnimeItemsHandler.php
    │   │   ├── QueryTopCharactersHandler.php
    │   │   ├── QueryTopMangaItemsHandler.php
    │   │   ├── QueryTopPeopleHandler.php
    │   │   ├── QueryTopReviewsHandler.php
    │   │   ├── QueryUpcomingAnimeSeasonHandler.php
    │   │   ├── RequestHandlerWithScraperCache.php
    │   │   ├── SearchRequestHandler.php
    │   │   ├── UserAboutLookupHandler.php
    │   │   ├── UserByIdLookupHandler.php
    │   │   ├── UserClubsLookupHandler.php
    │   │   ├── UserExternalLookupHandler.php
    │   │   ├── UserFavoritesLookupHandler.php
    │   │   ├── UserFriendsLookupHandler.php
    │   │   ├── UserFullLookupHandler.php
    │   │   ├── UserHistoryLookupHandler.php
    │   │   ├── UserLookupHandler.php
    │   │   ├── UserProfileLookupHandler.php
    │   │   ├── UserRecommendationsLookupHandler.php
    │   │   ├── UserReviewsLookupHandler.php
    │   │   ├── UserSearchHandler.php
    │   │   ├── UserStatisticsLookupHandler.php
    │   │   ├── UserUpdatesLookupHandler.php
    │   │   └── Concerns/
    │   │       └── ResolvesMediaReviewParams.php
    │   ├── Filters/
    │   │   ├── BaseClause.php
    │   │   ├── FilterQueryString.php
    │   │   ├── FilterResolver.php
    │   │   ├── OrderbyClause.php
    │   │   └── WhereClause.php
    │   ├── Helpers/
    │   │   ├── Guards.php
    │   │   └── ScraperHelper.php
    │   ├── Http/
    │   │   ├── HttpHelper.php
    │   │   ├── HttpResponse.php
    │   │   ├── Controllers/
    │   │   │   └── V4DB/
    │   │   │       ├── AnimeController.php
    │   │   │       ├── CharacterController.php
    │   │   │       ├── ClubController.php
    │   │   │       ├── Controller.php
    │   │   │       ├── GenreController.php
    │   │   │       ├── InsightsController.php
    │   │   │       ├── MagazineController.php
    │   │   │       ├── MangaController.php
    │   │   │       ├── PersonController.php
    │   │   │       ├── ProducerController.php
    │   │   │       ├── RandomController.php
    │   │   │       ├── RecommendationsController.php
    │   │   │       ├── ReviewsController.php
    │   │   │       ├── ScheduleController.php
    │   │   │       ├── SearchController.php
    │   │   │       ├── SeasonController.php
    │   │   │       ├── TopController.php
    │   │   │       ├── UserController.php
    │   │   │       └── WatchController.php
    │   │   ├── Middleware/
    │   │   │   ├── CorsMiddleware.php
    │   │   │   ├── EndpointCacheTtlMiddleware.php
    │   │   │   ├── Insights.php
    │   │   │   ├── MicroCaching.php
    │   │   │   └── SourceHeartbeatMonitor.php
    │   │   └── Resources/
    │   │       └── V4/
    │   │           ├── AnimeCharactersResource.php
    │   │           ├── AnimeCollection.php
    │   │           ├── AnimeEpisodeResource.php
    │   │           ├── AnimeEpisodesResource.php
    │   │           ├── AnimeFullResource.php
    │   │           ├── AnimeRelationsResource.php
    │   │           ├── AnimeResource.php
    │   │           ├── AnimeStaffResource.php
    │   │           ├── AnimeStatisticsResource.php
    │   │           ├── AnimeThemesResource.php
    │   │           ├── AnimeVideosResource.php
    │   │           ├── CharacterAnimeCollection.php
    │   │           ├── CharacterAnimeResource.php
    │   │           ├── CharacterCollection.php
    │   │           ├── CharacterFullResource.php
    │   │           ├── CharacterMangaCollection.php
    │   │           ├── CharacterMangaResource.php
    │   │           ├── CharacterResource.php
    │   │           ├── CharacterSeiyuuCollection.php
    │   │           ├── CharacterSeiyuuResource.php
    │   │           ├── ClubCollection.php
    │   │           ├── ClubRelationsResource.php
    │   │           ├── ClubResource.php
    │   │           ├── ClubStaffResource.php
    │   │           ├── CommonResource.php
    │   │           ├── ExternalLinksResource.php
    │   │           ├── ForumResource.php
    │   │           ├── GenreCollection.php
    │   │           ├── GenreResource.php
    │   │           ├── InsightsCollection.php
    │   │           ├── InsightsResource.php
    │   │           ├── MagazineCollection.php
    │   │           ├── MagazineResource.php
    │   │           ├── MangaCharactersResource.php
    │   │           ├── MangaCollection.php
    │   │           ├── MangaFullResource.php
    │   │           ├── MangaRelationsResource.php
    │   │           ├── MangaResource.php
    │   │           ├── MangaStatisticsResource.php
    │   │           ├── MoreInfoResource.php
    │   │           ├── NewsResource.php
    │   │           ├── PersonAnimeCollection.php
    │   │           ├── PersonAnimeResource.php
    │   │           ├── PersonCollection.php
    │   │           ├── PersonFullResource.php
    │   │           ├── PersonMangaCollection.php
    │   │           ├── PersonMangaResource.php
    │   │           ├── PersonResource.php
    │   │           ├── PersonVoiceResource.php
    │   │           ├── PersonVoicesCollection.php
    │   │           ├── PicturesResource.php
    │   │           ├── ProducerCollection.php
    │   │           ├── ProducerFullResource.php
    │   │           ├── ProducerResource.php
    │   │           ├── ProfileAboutResource.php
    │   │           ├── ProfileFavoritesResource.php
    │   │           ├── ProfileFullResource.php
    │   │           ├── ProfileHistoryResource.php
    │   │           ├── ProfileLastUpdatesResource.php
    │   │           ├── ProfileResource.php
    │   │           ├── ProfileStatisticsResource.php
    │   │           ├── RecommendationsResource.php
    │   │           ├── ResultsResource.php
    │   │           ├── ReviewsResource.php
    │   │           ├── StreamingLinksResource.php
    │   │           ├── TrendsCollection.php
    │   │           ├── TrendsResource.php
    │   │           ├── UserCollection.php
    │   │           ├── UserProfileAnimeListCollection.php
    │   │           ├── UserProfileAnimeListResource.php
    │   │           ├── UserProfileMangaListCollection.php
    │   │           ├── UserProfileMangaListResource.php
    │   │           └── UserUpdatesResource.php
    │   ├── Jobs/
    │   │   ├── ExampleJob.php
    │   │   ├── Job.php
    │   │   ├── UpdateCacheJob.php
    │   │   └── UpdateDatabaseJob.php
    │   ├── Listeners/
    │   │   ├── ExampleListener.php
    │   │   ├── PsrWorkerErrorListener.php
    │   │   └── SourceHeartbeatListener.php
    │   ├── Macros/
    │   │   ├── CollectionOffsetGetFirst.php
    │   │   ├── ResponseJikanCacheFlags.php
    │   │   └── To2dArrayWithDottedKeys.php
    │   ├── Mixins/
    │   │   └── ScoutBuilderMixin.php
    │   ├── Providers/
    │   │   ├── AppServiceProvider.php
    │   │   ├── AuthServiceProvider.php
    │   │   ├── EventServiceProvider.php
    │   │   ├── JikanEnumServiceProvider.php
    │   │   ├── SearchQueryBuilderProvider.php
    │   │   ├── SerializationContextFactory.php
    │   │   ├── SerializerFactory.php
    │   │   └── SourceHeartbeatProvider.php
    │   ├── Repositories/
    │   │   ├── AnimeGenresRepository.php
    │   │   ├── DatabaseRepository.php
    │   │   ├── DefaultAnimeRepository.php
    │   │   ├── DefaultCharacterRepository.php
    │   │   ├── DefaultClubRepository.php
    │   │   ├── DefaultMagazineRepository.php
    │   │   ├── DefaultMangaRepository.php
    │   │   ├── DefaultPeopleRepository.php
    │   │   ├── DefaultProducerRepository.php
    │   │   ├── DefaultUserRepository.php
    │   │   ├── DocumentRepository.php
    │   │   └── MangaGenresRepository.php
    │   ├── Rules/
    │   │   ├── MaxResultsPerPageRule.php
    │   │   └── Attributes/
    │   │       ├── EnumValidation.php
    │   │       └── MaxLimitWithFallback.php
    │   ├── Services/
    │   │   ├── DefaultBuilderPaginatorService.php
    │   │   ├── DefaultCachedScraperService.php
    │   │   ├── DefaultPrivateFieldMapperService.php
    │   │   ├── DefaultQueryBuilderService.php
    │   │   ├── DefaultScoutSearchService.php
    │   │   ├── DefaultSearchAnalyticsService.php
    │   │   ├── DummySearchAnalyticsService.php
    │   │   ├── ElasticScoutSearchService.php
    │   │   ├── EloquentBuilderPaginatorService.php
    │   │   ├── EndpointType.php
    │   │   ├── JikanUserListRequestMapperService.php
    │   │   ├── MongoSearchService.php
    │   │   ├── PrivateFieldMapperService.php
    │   │   ├── QueryBuilderPaginatorService.php
    │   │   ├── QueryBuilderService.php
    │   │   ├── ScoutBuilderPaginatorService.php
    │   │   ├── ScoutSearchService.php
    │   │   ├── SearchEngineSearchService.php
    │   │   ├── SearchQueryBuilderProvider.php
    │   │   ├── SearchService.php
    │   │   ├── SearchServiceBase.php
    │   │   ├── TypesenseCollectionDescriptor.php
    │   │   └── TypeSenseScoutSearchService.php
    │   ├── Support/
    │   │   ├── CachedData.php
    │   │   ├── CacheOptions.php
    │   │   ├── DefaultMediator.php
    │   │   ├── helpers.php
    │   │   ├── JikanConfig.php
    │   │   ├── JikanUnitOfWork.php
    │   │   ├── RepositoryQuery.php
    │   │   └── RepositoryQueryBase.php
    │   └── Testing/
    │       ├── JikanDataGenerator.php
    │       ├── ScoutFlush.php
    │       ├── SyntheticMongoDbTransaction.php
    │       ├── TestExceptionsHandler.php
    │       └── Concerns/
    │           └── MakesHttpRequestsEx.php
    ├── bootstrap/
    │   ├── app.php
    │   └── tests.php
    ├── config/
    │   ├── cache.php
    │   ├── cors.php
    │   ├── data.php
    │   ├── database.php
    │   ├── elasticsearch.php
    │   ├── jikan.php
    │   ├── logging.php
    │   ├── queue.php
    │   ├── roadrunner.php
    │   ├── scout.php
    │   ├── sentry.php
    │   └── swagger-lume.php
    ├── database/
    │   ├── factories/
    │   │   ├── AnimeFactory.php
    │   │   ├── AnimeModelFactoryDescriptor.php
    │   │   ├── CharacterFactory.php
    │   │   ├── ClubFactory.php
    │   │   ├── EpisodeFactory.php
    │   │   ├── GenreAnimeFactory.php
    │   │   ├── GenreFactory.php
    │   │   ├── GenreMangaFactory.php
    │   │   ├── JikanMediaModelFactory.php
    │   │   ├── JikanModelFactory.php
    │   │   ├── MagazineFactory.php
    │   │   ├── MangaFactory.php
    │   │   ├── MangaModelFactoryDescriptor.php
    │   │   ├── MediaModelFactory.php
    │   │   ├── MediaModelFactoryDescriptor.php
    │   │   ├── ModelFactory.php
    │   │   ├── PersonFactory.php
    │   │   ├── ProducersFactory.php
    │   │   └── ProfileFactory.php
    │   ├── migrations/
    │   │   ├── 2022_12_04_210448_squash.php
    │   │   └── .gitkeep
    │   └── seeds/
    │       └── DatabaseSeeder.php
    ├── docker/
    │   ├── mongo-init.js
    │   └── config/
    │       └── .env.compose
    ├── public/
    │   ├── index.php
    │   └── .htaccess
    ├── resources/
    │   └── views/
    │       └── .gitkeep
    ├── routes/
    │   └── web.v4.php
    ├── storage/
    │   └── app/
    │       └── metadata.v4/
    │           ├── Jikan.Model.Anime.Anime.yml
    │           ├── Jikan.Model.Anime.AnimeCharactersAndStaff.yml
    │           ├── Jikan.Model.Anime.EpisodeListItem.yml
    │           ├── Jikan.Model.Anime.Episodes.yml
    │           ├── Jikan.Model.Anime.PromoListItem.yml
    │           ├── Jikan.Model.Anime.StaffListItem.yml
    │           ├── Jikan.Model.Anime.StreamEpisodeListItem.yml
    │           ├── Jikan.Model.Character.Animeography.yml
    │           ├── Jikan.Model.Character.Character.yml
    │           ├── Jikan.Model.Character.CharacterListItem.yml
    │           ├── Jikan.Model.Character.Mangaography.yml
    │           ├── Jikan.Model.Character.VoiceActor.yml
    │           ├── Jikan.Model.Common.AnimeCard.yml
    │           ├── Jikan.Model.Common.MangaCard.yml
    │           ├── Jikan.Model.Common.Picture.yml
    │           ├── Jikan.Model.Forum.ForumTopic.yml
    │           ├── Jikan.Model.Genre.AnimeGenre.yml
    │           ├── Jikan.Model.Genre.MangaGenre.yml
    │           ├── Jikan.Model.Magazine.Magazine.yml
    │           ├── Jikan.Model.Manga.CharacterListItem.yml
    │           ├── Jikan.Model.Manga.Manga.yml
    │           ├── Jikan.Model.News.NewsListItem.yml
    │           ├── Jikan.Model.Person.AnimeStaffPosition.yml
    │           ├── Jikan.Model.Person.Person.yml
    │           ├── Jikan.Model.Person.PublishedManga.yml
    │           ├── Jikan.Model.Person.VoiceActingRole.yml
    │           ├── Jikan.Model.Producer.Producer.yml
    │           ├── Jikan.Model.Schedule.Schedule.yml
    │           ├── Jikan.Model.Search.AnimeSearchListItem.yml
    │           ├── Jikan.Model.Search.CharacterSearchListItem.yml
    │           ├── Jikan.Model.Search.MangaSearchListItem.yml
    │           ├── Jikan.Model.Search.PersonSearchListItem.yml
    │           ├── Jikan.Model.Top.TopAnime.yml
    │           ├── Jikan.Model.Top.TopCharacter.yml
    │           ├── Jikan.Model.Top.TopManga.yml
    │           ├── Jikan.Model.Top.TopPerson.yml
    │           └── Jikan.Model.User.History.yml
    ├── tests/
    │   ├── readme.md
    │   ├── IntegrationTestListener.php
    │   ├── TestCase.php
    │   ├── TestServiceProvider.php
    │   ├── Integration/
    │   │   ├── AnimeControllerTest.php
    │   │   ├── AnimeSearchEndpointTest.php
    │   │   ├── CharacterControllerTest.php
    │   │   ├── ClubControllerTest.php
    │   │   ├── GenreControllerTest.php
    │   │   ├── MagazineControllerTest.php
    │   │   ├── MangaControllerTest.php
    │   │   ├── MangaSearchEndpointTest.php
    │   │   ├── PersonControllerTest.php
    │   │   ├── ProducerControllerTest.php
    │   │   ├── RecommendationsControllerTest.php
    │   │   ├── ReviewsControllerTest.php
    │   │   ├── ScheduleControllerTest.php
    │   │   ├── SearchControllerTest.php
    │   │   ├── SeasonControllerTest.php
    │   │   ├── TopAnimeEndpointTest.php
    │   │   ├── TopControllerTest.php
    │   │   ├── UserControllerTest.php
    │   │   └── WatchControllerTest.php
    │   └── Unit/
    │       ├── CachedDataTest.php
    │       ├── DefaultCachedScraperServiceTest.php
    │       ├── DefaultMediatorTest.php
    │       ├── JikanApiSearchableModelTest.php
    │       └── PreparesDataTraitTest.php
    └── .github/
        ├── CODEOWNERS
        ├── dependabot.yml
        ├── FUNDING.yml
        ├── ISSUE_TEMPLATE/
        │   ├── bug.yml
        │   ├── feature.yml
        │   └── support_question.md
        └── workflows/
            ├── container-image-release.yml
            └── tests.yml


Files Content:

(Files content cropped to 300k characters, download full ingest to see more)
================================================
FILE: README.MD
================================================
[![Jikan](https://i.imgur.com/ccx3pxo.png)](#jikan-rest-api-v4---unofficial-myanimelistnet-rest-api)

# Jikan REST API v4 - Unofficial MyAnimeList.net REST API
[![Average time to resolve an issue](http://isitmaintained.com/badge/resolution/jikan-me/jikan-rest.svg)](http://isitmaintained.com/project/jikan-me/jikan-rest "Average time to resolve an issue") [![Percentage of issues still open](http://isitmaintained.com/badge/open/jikan-me/jikan-rest.svg)](http://isitmaintained.com/project/jikan-me/jikan-rest "Percentage of issues still open") [![stable](https://img.shields.io/badge/PHP-^8.1-blue.svg?style=flat)]() [![Discord Server](https://img.shields.io/discord/460491088004907029.svg?style=flat&logo=discord)](http://discord.jikan.moe)

Jikan is a REST API for [MyAnimeList.net](https://myanimelist.net). It scrapes the website to satisfy the need for API functionality that MyAnimeList.net lacks.

The raison d'être of Jikan is to assist developers easily get the data they need for their apps and projects without having to depend on unstable APIs, or sidetracking their projects to develop parsers.

The word _Jikan_ literally translates to _Time_ in Japanese (**時間**). And that's what this API saves you of. ;)

**Notice**: Jikan REST API does not support authenticated requests. You can not update your lists. Use the official MyAnimeList API for this!


## Installation

### NOTICE: v3
This is Jikan REST API **v4** - which has been merged into master branch. If you're looking for deploying a v3 build, view the v3 branch for installation instructions:
https://github.com/jikan-me/jikan-rest/tree/v3

⚠ v3 is discontinued and will no longer receive any updates.

### Manual installation
Please read the [manual installation guide](https://github.com/jikan-me/jikan-rest/wiki).
For any additional help, join our [Discord server](http://discord.jikan.moe/).

### 🐳 Docker Installation
We distribute the app as a container image, so you can just run it:
```bash
docker run -d --name=jikan-rest -p 8080:8080 -v ./.env:/app/.env jikanme/jikan-rest:latest
```

For more information please refer to our [container usage guide](container_usage.md).

## Public REST API
If you don't want to host your instance, there's a public API available.

- *[Apps/Projects using the REST API](https://jikan.moe/showcase)*

### Documentation
Please view the [documentation](https://docs.api.jikan.moe/).
For any additional help, join our [Discord server](http://discord.jikan.moe/).

## Wrappers

| Language   | Wrappers |
|------------|----------|
| JavaScript | [JikanJS](https://github.com/zuritor/jikanjs) by Zuritor<br>🆕 **(v4)** [JikanJS](https://github.com/mateoaranda/jikanjs) by Mateo Aranda |
| Java       | [Jikan4java](https://github.com/Doomsdayrs/Jikan4java) by Doomsdayrs<br>🆕 **(v4)** [reactive-jikan](https://github.com/SandroHc/reactive-jikan) by Sandro Marques<br>🆕 **(v4)** [Jaikan](https://github.com/ShindouMihou/Jaikan) by ShindouMihou |
| Python     | **(v4)** [JikanPy](https://github.com/abhinavk99/jikanpy) by Abhinav Kasamsetty<br>🆕 **(v4)** [jikan4snek](https://github.com/ScathachGrip/jikan4snek) by Indrawan I. |
| Node.js    | [jikan-node](https://github.com/xy137/jikan-node) by xy137<br>[jikan-nodejs](https://github.com/ribeirogab/jikan-nodejs) by ribeirogab<br>🆕 **(v4)** [Jikan4JS](https://github.com/rizzzigit/jikan4.js) by RizzziGit<br>🆕 **(v4)** [jikan-api.js](https://github.com/OpenianDevelopment/jikan-api.js) by OpenianDev |
| TypeScript | [jikants](https://github.com/Julien-Broyard/jikants) by Julien Broyard<br>[jikan-client](https://github.com/javi11/jikan-client) by Javier Blanco<br>🆕 **(v4)** [jikan-ts](https://github.com/tutkli/jikan-ts) by Clara Castillo<br>🆕 **(v4)** [jikan-api-lightweight-client](https://github.com/HRAshton/jikan-api-lightweight-client) by HRAshton |
| PHP        | [jikan-php](https://github.com/janvernieuwe/jikan-jikanPHP) by Jan Vernieuwe |
| .NET       | 🆕 **(v4)** [Jikan.net](https://github.com/Ervie/jikan.net) by Ervie |
| Go         | 🆕 **(v4)** [jikan-go](https://github.com/darenliang/jikan-go) by Daren Liang<br>[jikan2go](https://github.com/nokusukun/jikan2go) by nokusukun |
| Ruby       | [Jikan.rb](https://github.com/Zerocchi/jikan.rb) by Zerocchi |
| Dart       | [jikan-dart](https://github.com/charafau/jikan-dart) by Rafal Wachol |
| Kotlin     | [JikanKt](https://github.com/GSculerlor/JikanKt) by Ganedra Afrasya |

[Add your wrapper here](https://github.com/jikan-me/jikan-rest/edit/master/README.MD)

## Running Tests

`php vendor/bin/phpunit tests`

Note: Tests may fail due to rate limit from MyAnimeList (HTTP 429)

---
## Backers

A huge thank you to all our Patrons! 🙏 This project wouldn't be running without your support.

We have a free [REST API service](https://jikan.moe), if you wish to support us you can [become a Patron!](https://patreon.com/jikan)

### Sugoi (すごい) Patrons

- [Jared Allard (jaredallard)](https://github.com/jaredallard)
- [hugonun (hug_onun)](https://twitter.com/hug_onun)

### Patrons

- Aaron Treinish
- Abdelhafid Achtaou
- Aika Fujiwara
- Bobby Williams
- Cesar Irad Mendoza
- CrafterSama
- Fro116
- Jason Weatherly
- Jesse
- Kundan Chintamaneni
- Kururin
- Purplepinapples
- Ryo Ando
- Sakamotodesu
- TeraNovaLP

## Development

|||
|------------|----------|
| ![JetBrain](https://user-images.githubusercontent.com/9166451/126047249-9e5bdc63-ae91-4082-bca5-ffe271b421da.png) | Jikan's development is powered by [JetBrain's Open Source License](https://jb.gg/OpenSource) |

A shoutout to their amazing products and for supporting Jikan since early versions!

---

# DISCLAIMER

- Jikan is not affiliated with MyAnimeList.net
- You are responsible for the usage of this API. Please be respectful towards MyAnimeList's [Terms Of Service](https://myanimelist.net/about/terms_of_use)



================================================
FILE: artisan
================================================
#!/usr/bin/env php
<?php

use Symfony\Component\Console\Input\ArgvInput;
use Symfony\Component\Console\Output\ConsoleOutput;

/*
|--------------------------------------------------------------------------
| Create The Application
|--------------------------------------------------------------------------
|
| First we need to get an application instance. This creates an instance
| of the application / container and bootstraps the application so it
| is ready to receive HTTP / Console requests from the environment.
|
*/

$app = require __DIR__.'/bootstrap/app.php';

/*
|--------------------------------------------------------------------------
| Run The Artisan Application
|--------------------------------------------------------------------------
|
| When we run the console application, the current CLI command will be
| executed in this console and the response sent back to a terminal
| or another output device for the developers. Here goes nothing!
|
*/

$kernel = $app->make(
    'Illuminate\Contracts\Console\Kernel'
);

exit($kernel->handle(new ArgvInput, new ConsoleOutput));



================================================
FILE: COMMANDS.MD
================================================
# Artisan Commands

Artisan commands are run in the root of the project directory where the `artisan` file is present.
For an entire list of commands, you can run `php artisan list`

## Index
- [Serve](#serve)
- [Queue](#queue)
    - [Clear](#queue-clear)
- [Cache](#cache)
    - [Remove](#cache-remove)
    - [Change Cache Driver](#cache-change-cache-driver)
    - [Change Cache Method](#cache-change-cache-method)
- [Indexer](#indexer)
    - [Anime](#indexer-anime)
    - [Manga](#indexer-manga)
    - [Incremental](#indexer-incremental)

## Commands

### Serve
Command: `serve`
Example: `php artisan serve`

Serve the application on the PHP development server

### Queue

#### Queue: Clear
Command: `queue:clear`

Example: `php artisan queue:clear`

This will empty any cache updater jobs that are currently in queue if you're using the [Queue Cache Method](https://github.com/jikan-me/jikan-rest/blob/master/README.md#06-configuring-how-jikan-handles-expired-cache-optional)

### Cache

#### Cache: Remove
Command: `cache:remove {key}`

Example: `php artisan cache:remove request:anime:d6092f2422f084452c84555f17c7ba047e6998d3`

This will remove the cache of a specific request. You can retrieve any request's hash key by visiting the request.

In v2-v3, the request hash key is defined in the JSON response body as `request_hash`.

In v3.4+, the request is defined in the response headers as `X-Request-Hash` as well.

In v4+, the request is defined only in the response header.

#### Cache: Change Cache Driver
Command: `cache:driver {driver}`

Example: `cache:driver redis`

[Read more on how it works](https://github.com/jikan-me/jikan-rest/blob/master/README.md#05-configuring-how-jikan-caches-optional)

#### Cache: Change Cache Method
Command: `cache:method {method}`

Example: `cache:method queue`

[Read more on how it works](https://github.com/jikan-me/jikan-rest/blob/master/README.md#06-configuring-how-jikan-handles-expired-cache-optional)

### Indexer
#### Indexer: Anime
Since v4 uses MongoDB as a means to index cache on some endpoints, having a built cache is important since it
works best for endpoints like search or top.

`Indexer:Anime` uses [https://github.com/purarue/mal-id-cache](https://github.com/purarue/mal-id-cache) to fetch available MAL IDs and indexes them.

This function only needs to be run once. Any entry's cache updating will automatically be taken care of if it's expired, and a client makes a request for that entry.

⚠ This is strictly for performance and experience and providing better search functionality. Don't build your own anime database as that's against MyAnimeList's Terms of Service.

Command:
```
indexer:anime
    {--failed : Run only entries that failed to index last time}
    {--resume : Resume from the last position}
    {--reverse : Start from the end of the array}
    {--index=0 : Start from a specific index}
    {--delay=3 : Set a delay between requests}
```

Example: `indexer:anime --reverse --delay=5 --failed`

This translates to running entries that previously failed to index or update, in reverse, with a delay of 5 seconds between each request.

#### Indexer: Manga
Since v4 uses MongoDB as a means to index cache on some endpoints, having a built cache is important since it
works best for endpoints like search or top.

`Indexer:Manga` uses [https://github.com/purarue/mal-id-cache](https://github.com/purarue/mal-id-cache) to fetch available MAL IDs and indexes them.

This function only needs to be run once. Any entry's cache updating will automatically be taken care of if it's expired, and a client makes a request for that entry.

⚠ This is strictly for performance and experience and providing better search functionality. Don't build your own anime database as that's against MyAnimeList's Terms of Service.

Command:
```
indexer:manga
    {--failed : Run only entries that failed to index last time}
    {--resume : Resume from the last position}
    {--reverse : Start from the end of the array}
    {--index=0 : Start from a specific index}
    {--delay=3 : Set a delay between requests}
```

Example: `indexer:manga`

This simply translates to running the indexer without any additional configuration.

#### Indexer: Incremental
Incrementally indexes media entries from MAL.
This command will compare the latest version of MAL ids from the [mal_id_cache](https://github.com/purarue/mal-id-cache)
github repository and compares them with the downloaded ids from the previous run. If no ids found from the previous run, a full indexing session is started.

Command:
```
indexer:incremental {mediaType*}
    {--failed : Run only entries that failed to index last time}
    {--resume : Resume from the last position}
    {--delay=3 : Set a delay between requests}
```



================================================
FILE: composer.json
================================================
{
    "name": "laravel/lumen",
    "description": "The Laravel Lumen Framework.",
    "keywords": ["framework", "laravel", "lumen"],
    "license": "MIT",
    "type": "project",
    "repositories": [
      {
        "type": "vcs",
        "url": "https://github.com/pushrbx/lumen-roadrunner"
      }
    ],
    "require": {
        "php": "^8.1",
        "ext-json": "*",
        "ext-mongodb": "*",
        "ext-pcntl": "*",
        "amphp/http-client": "^4.6",
        "danielmewes/php-rql": "dev-master",
        "darkaonline/swagger-lume": "^9.0",
        "doctrine/annotations": "1.14.2",
        "fabpot/goutte": "^4.0",
        "flipbox/lumen-generator": "^9.0",
        "illuminate/redis": "^9.0",
        "jenssegers/mongodb": "^3.9",
        "jikan-me/jikan": "^4",
        "jms/serializer": "^3.0",
        "laravel/legacy-factories": "^1.1",
        "laravel/lumen-framework": "^9.0",
        "laravel/scout": "^9.4",
        "league/flysystem": "^3.0",
        "matchish/laravel-scout-elasticsearch": "^6.0",
        "mirazmac/dotenvwriter": "^0.1.0",
        "ocramius/package-versions": "^2.5",
        "predis/predis": "^1.1",
        "pushrbx/lumen-roadrunner": "5.9.1",
        "sentry/sentry-laravel": "^2.8",
        "spatie/laravel-data": "^3.11",
        "spatie/laravel-enum": "^3.0",
        "symfony/yaml": "^4.1",
        "typesense/laravel-scout-typesense-driver": "^5.2",
        "vlucas/phpdotenv": "^5",
        "zircote/swagger-php": "3.*"
    },
    "require-dev": {
        "fakerphp/faker": "^1.21",
        "haydenpierce/class-finder": "^0.4.4",
        "mockery/mockery": "^1.5.1",
        "phpunit/phpunit": "^9.5.28"
    },
    "autoload": {
        "psr-4": {
            "App\\": "app/",
            "Database\\Factories\\": "database/factories/"
        },
        "files": [
          "app/Support/helpers.php"
        ]
    },
    "autoload-dev": {
        "psr-4": {
          "Tests\\": ["tests/"]
        }
    },
    "scripts": {
        "post-root-package-install": [
            "php -r \"copy('.env.dist', '.env');\""
        ],
        "phpunit": "@php ./vendor/bin/phpunit --no-coverage",
        "phpunit-cover": "@php ./vendor/bin/phpunit",
        "test": [
          "@phpunit --testsuite unit"
        ],
        "integration-test": [
          "@phpunit --testsuite integration"
        ],
        "test-cover": [
          "@phpunit-cover"
        ]
    },
    "minimum-stability": "dev",
    "prefer-stable": true,
    "config": {
        "preferred-install": "dist",
        "sort-packages": true,
        "optimize-autoloader": true,
        "allow-plugins": {
            "php-http/discovery": true
        }
    }
}



================================================
FILE: container-setup.sh
================================================
#!/bin/bash

_JIKAN_API_VERSION=v4.0.0
SUBSTITUTE_VERSION=$_JIKAN_API_VERSION
if [ -x "$(command -v git)" ]; then
  # check if we have checked out a tag or not
  git symbolic-ref HEAD &> /dev/null
  if [ $? -ne 0 ]; then
    # if a tag is checked out then use the tag name as the version
    SUBSTITUTE_VERSION=$(git describe --tags)
  else
    # this is used when building locally
    SUBSTITUTE_VERSION=$(git describe --tags | sed -e "s/-[a-z0-9]\{8\}/-$(git rev-parse --short HEAD)/g")
  fi
fi
# set JIKAN_API_VERSION env var to "latest" or a tag which exists in the container registry to use the remote image
# otherwise docker-compose will look for a locally builded image
export _JIKAN_API_VERSION=${JIKAN_API_VERSION:-$SUBSTITUTE_VERSION}

DOCKER_COMPOSE_PROJECT_NAME=jikan-api
DOCKER_CMD="docker"
DOCKER_COMPOSE_CMD="docker-compose"

display_help() {
  echo "============================================================"
  echo "Jikan API Container Setup CLI"
  echo "============================================================"
  echo "Syntax: ./container-setup.sh [command]"
  echo "Jikan API Version: $_JIKAN_API_VERSION"
  echo "---commands---"
  echo "help                   Print CLI help"
  echo "build-image            Build Image Locally"
  echo "start                  Start Jikan API (mongodb, typesense, redis, jikan-api workers)"
  echo "stop                   Stop Jikan API"
  echo "validate-prereqs       Validate pre-reqs installed (docker, docker-compose)"
  echo "execute-indexers       Execute the indexers, which will scrape and index data from MAL. (Notice: This can take days)"
  echo "index-incrementally    Executes the incremental indexers for each media type. (anime, manga)"
  echo ""
}

validate_prereqs() {
  docker_exists=$(command -v docker)
  docker_compose_exists=$(command -v docker-compose)
  podman_exists=$(command -v podman)
  podman_compose_exists=$(command -v podman-compose)

   if [ ! -x "$docker_exists" ] && [ ! -x "$podman_exists" ]; then
      echo -e "'docker' is not installed. \xE2\x9D\x8C"
      exit 1
   else
      echo -e "Docker is Installed. \xE2\x9C\x94"
   fi

   if [ -x "$docker_exists" ]; then
      DOCKER_CMD="docker"
      docker -v >/dev/null 2>&1
      if [ $? -ne 0 ]; then
         echo -e "'docker' is not executable without sudo. \xE2\x9D\x8C"
         exit 1
      fi
   elif [ -n "$podman_exists" ]; then
      DOCKER_CMD="podman"
   fi

   if [ ! -x "$docker_compose_exists" ] && [ ! -x "$podman_compose_exists" ]; then
       echo -e "'docker-compose' is not installed. \xE2\x9D\x8C"
       exit 1
    else
       echo -e "Docker compose is Installed. \xE2\x9C\x94"
    fi

    if [ -x "$docker_compose_exists" ]; then
       DOCKER_COMPOSE_CMD="docker-compose"
    elif [ -x "$podman_compose_exists" ]; then
       DOCKER_COMPOSE_CMD="podman-compose"
    else
      echo "Error"
      exit 1
    fi
}

build_image() {
  validate_prereqs
  $DOCKER_CMD inspect jikanme/jikan-rest:"$_JIKAN_API_VERSION" &> /dev/null && $DOCKER_CMD rmi jikanme/jikan-rest:"$_JIKAN_API_VERSION"
  $DOCKER_CMD build --rm --compress -t jikanme/jikan-rest:"$_JIKAN_API_VERSION" .
  $DOCKER_CMD tag jikanme/jikan-rest:"$_JIKAN_API_VERSION" jikanme/jikan-rest:latest
}

ensure_secrets() {
  declare -a secrets=("db_password" "db_admin_password" "redis_password" "typesense_api_key")

  if [ ! -f "db_username.txt" ]; then
    echo "db_username.txt not found, please provide a db_username [default is jikan]:"
    read -r db_username
    if [ -z "$db_username" ]; then
      db_username="jikan"
    fi
    echo -n "$db_username" > "db_username.txt"
  else
    echo -e "db_username.txt found, using it's value. \xE2\x9C\x94"
  fi

  if [ ! -f "db_admin_username.txt" ]; then
    echo "db_admin_username.txt not found, please provide a db_admin_username [default is jikan_admin]:"
    read -r db_admin_username
    if [ -z "$db_admin_username" ]; then
      db_admin_username="jikan_admin"
    fi
    echo -n "$db_admin_username" > "db_admin_username.txt"
  else
    echo -e "db_admin_username.txt found, using it's value. \xE2\x9C\x94"
  fi

  for secret_name in "${secrets[@]}"
  do
    if [ ! -f "$secret_name.txt" ]; then
      if [ "$secret_name" == "db_username" ]; then
        generated_secret="jikan"
      else
        generated_secret=$(LC_ALL=c tr -dc 'A-Za-z0-9!'\''()*+,-;<=>_' </dev/urandom | head -c 16  ; echo)
      fi
      echo "$secret_name.txt not found, please provide a $secret_name [default is $generated_secret]:"
      # prompt for secret and save it in file
      read -r secret_value
      if [ -z "$secret_value" ]; then
        secret_value=$generated_secret
      fi
      echo -n "$secret_value" > "$secret_name.txt"
    else
      echo -e "$secret_name.txt found, using it's value. \xE2\x9C\x94"
    fi
  done
}

start() {
   # todo: create a marker file for initial startup, and on initial startup ask the user whether they want a local image or the remote one
  validate_prereqs
  ensure_secrets
  exec $DOCKER_COMPOSE_CMD -p "$DOCKER_COMPOSE_PROJECT_NAME" up -d
}

case "$1" in
   "help")
      display_help
      ;;
   "validate-prereqs")
      validate_prereqs
      ;;
   "build-image")
      build_image
      ;;
   "start")
      start
      ;;
   "stop")
      validate_prereqs
      $DOCKER_COMPOSE_CMD -p "$DOCKER_COMPOSE_PROJECT_NAME" down
      ;;
   "execute-indexers")
      echo "Indexing anime..."
      $DOCKER_COMPOSE_CMD -p "$DOCKER_COMPOSE_PROJECT_NAME" exec jikan_rest php /app/artisan indexer:anime
      echo "Indexing manga..."
      $DOCKER_COMPOSE_CMD -p "$DOCKER_COMPOSE_PROJECT_NAME" exec jikan_rest php /app/artisan indexer:manga
      echo "Indexing characters and people..."
      $DOCKER_COMPOSE_CMD -p "$DOCKER_COMPOSE_PROJECT_NAME" exec jikan_rest php /app/artisan indexer:common
      echo "Indexing genres..."
      $DOCKER_COMPOSE_CMD -p "$DOCKER_COMPOSE_PROJECT_NAME" exec jikan_rest php /app/artisan indexer:genres
      echo "Indexing producers..."
      $DOCKER_COMPOSE_CMD -p "$DOCKER_COMPOSE_PROJECT_NAME" exec jikan_rest php /app/artisan indexer:producers
      echo "Indexing done!"
      ;;
   "index-incrementally")
      echo "Indexing..."
      $DOCKER_COMPOSE_CMD -p "$DOCKER_COMPOSE_PROJECT_NAME" exec jikan_rest php /app/artisan indexer:incremental anime manga
      echo "Indexing done!"
      ;;
   *)
      echo "No command specified, displaying help"
      display_help
      ;;
esac



================================================
FILE: container_usage.md
================================================
# 🐳 Running Jikan API in a container

The most easiest way to get started is to use our container setup cli script after checking out the repo with git (linux only):

```bash
./container-setup.sh start
```

This will:

- Prompt you for the required passwords and usernames
- Sets up a production ready setup with `redis`, `typesense` and `mongodb` (almost same as the public api at `api.jikan.moe`)
- Sets mongodb to use max 1gb of memory
- Configures jikan-api to add CORS headers to responses.

> **Note**: The script supports both `docker` and `podman`. In case of `podman` please bare in mind that sometimes the container name resolution doesn't work on the container network. 
> In those cases you might have to install `aardvark-dns` package. On `Arch Linux` podman uses `netavark` network by default (in 2023) so you will need to install the before mentioned package.

> **Note 2**: The script will start the jikan API, but if you start it for the first  time, it won't have any data in it!
> You will have to run the indexers through artisan to have data. See ["Running the indexer with the script"](#running-the-indexer-with-the-script) section.

The script has the following prerequisites and will notify you if these are not present:

- git
- `docker` or `podman`
- `docker-compose` or `podman-compose`

### Available commands in the cli script

```
============================================================
Jikan API Container Setup CLI
============================================================
Syntax: ./container-setup.sh [command]
---commands---
help                   Print CLI help
build-image            Build Image Locally
start                  Start Jikan API (mongodb, typesense, redis, jikan-api workers)
stop                   Stop Jikan API
validate-prereqs       Validate pre-reqs installed (docker, docker-compose)
execute-indexers       Execute the indexers, which will scrape and index data from MAL. (Notice: This can take days)
index-incrementally    Executes the incremental indexers for each media type. (anime, manga)
```

### Running the indexer with the script

When you first startup the app you will have an empty database. To fill it up you can execute the following command:

```bash
./container-setup.sh execute-indexers
```

Please note that this command can take 4-5 days to run. You can run it in the background with the `&` marker:

```bash
./container-setup.sh execute-indexers &
```

If interrupted then you will have to manually resume the indexing, otherwise the above command will just start again from the beginning.

### Updating to a newer version

You need to stop the app first:

```bash
./container-setup.sh stop
```

Then remove the jikan-api image from your local storage and pull the new one. Set the `JIKAN_API_VERSION` environment variable to the latest image tag. This can be either `latest` or the version `v4.0.0-11`.

```bash
JIKAN_API_VERSION=latest ./container-setup.sh start
```

## More customised setups

Some of you might only want to run the `jikan-rest` app with only mongodb, without the more sophisticated search functionality. In those cases we don't have a `docker-compose` config for you. You need to start the `jikan-rest` container with atleast a `mongodb` instance.
The `jikan-rest` container will require a `.env` file mounted where you configure the credentials for `mongodb`.


```bash
docker run -d --name=jikan-rest -p 8080:8080 -v ./.env:/app/.env jikanme/jikan-rest:latest
```

- Container listens on port `8080` for http requests
- By mounting your .env file on the container via `-v ./.env:/app/.env` command line option for `docker run` you can
  configure Jikan API.

> **Important**: You need to either mount a `.env` file on the container or specify the configuration through
> environment variables to make Jikan API work in the container. Jikan API needs a MongoDB and optionally a search engine.
> In high load environments additionally a `redis` server is required too. The configuration should point to the correct
> address of these services.

> **Tip**: If you run the container on a non-default network, you can use the container names in the configuration to
> specify the address of services like MongoDB and TypeSense.

There is also a `Dockerfile` in the repo which you can use to build the container image and startup the app in a
container:

```bash
docker build -t jikan-rest:nightly .
docker run -d --name=jikan-rest -p 8080:8080 -v ./.env:/app/.env jikan-rest:nightly
```

> Most of the time it's enough to just use the image from [Docker Hub](https://hub.docker.com/r/jikanme/jikan-rest).

### Docker compose usage

```
docker-compose up
```

This does the same thing as the `container-setup.sh` script mostly, but you will have to create the secret files yourself. The following secret files are required for credentials (put them next to the `docker-compose.yml` file):

- db_admin_password.txt
- db_admin_username.txt
- db_password.txt
- db_username.txt
- redis_password.txt
- typesense_api_key.txt

You can customise the Jikan API config through `./docker/config/.env.compose` file. (E.g. you don't want CORS headers)

> **Please note**: The syntax rules of docker compose for `.env` applies
> here: https://docs.docker.com/compose/env-file/#syntax-rules

> **Additional configuration**: You can change the mongodb memory usage via `MONGO_CACHE_SIZE_GB` environment variable. 
> It sets how many gigabytes of memory is available for wired tiger. Default is `1`. This is useful for systems with low memory capacity.

### Note for Podman

If you build the container image yourself with podman, the resulting image format will be OCI by default.
To make the health checks work in that situation you need to run the container the following way:

```bash
podman run -d --name=jikan-rest -p 8080:8080 -v ./.env:/app/.env --health-start-period=5s --health-cmd="curl --fail http://localhost:2114/health?plugin=http || exit 1" jikan-rest:nightly
```

### Configuration of the container

You can also change the settings of Jikan through setting environment variables via the `-e` command line argument option for
the `docker run` command.
These environment variables are the same as the options found in the `.env` file. We also provide a sample file
called `.env.dist`.      
Additionally, you can use the `--env-file` option of `docker run` to specify configuration for Jikan, in which case you
put all the configuration in the env file.

```bash
docker run -d --name=jikan-rest -p 8080:8080 --env-file ./env.list jikanme/jikan-rest:latest
```

The env-file should contain env var value pairs line by line.

```
VAR1=value1
VAR2=value2
```

There are additional configuration options:

| Name                                 | Description                                                                                                                                                                                         |
|--------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| RR_MAX_WORKER_MEMORY                 | (Number) Configures the available memory in megabytes for the php scripts                                                                                                                           |
| RR_MAX_REQUEST_SIZE_MB               | (Number) Configures the max allowed request body size in megabytes                                                                                                                                  |
| JIKAN_QUEUE_WORKER_PROCESS_NUM       | (Number) Configures the number of running queue worker processes. (You want to increase this if you experience huge load)                                                                           |
| JIKAN_ENABLE_PERIODICAL_FULL_INDEXER | (Bool) Configures whether to run the anime/manga indexer every week, which would crawl all anime/manga at first then it would just grab the latest anime/manga entries from MAL. Defaults to false. |

You can read more about additional configuration options on
the [Configuration Wiki page](https://github.com/jikan-me/jikan-rest/wiki/Configuration).

## Some facts about the container image

- Jikan uses RoadRunner as an application server within the container.
- Both `wget` and `curl` exists in the container image.
- The script in `docker-entrypoint.php` sets safe defaults. Because of this by default the app won't behave the same way
  as the publicly available version of the app at [https://api.jikan.moe/v4](https://api.jikan.moe/v4). The default
  settings:
  - No redis caching
  - No search index usage (inaccurate search results)
- Via Roadrunner multiple processes are running in the container, and their logs are aggregated and forwarded
  to `stdout`.
  - These processes are:
    - the php processes ingesting the http requests
    - [Supercronic](https://github.com/aptible/supercronic), which runs cron jobs.
    - Queue workers for populating the search index and other background jobs.



================================================
FILE: docker-compose.yml
================================================
version: '3.8'
volumes:
  mongo-data: { }
  redis-data: { }
  typesense-data: { }

networks:
  jikan_network: { }

secrets:
  db_username:
    file: db_username.txt
  db_password:
    file: db_password.txt
  db_admin_username:
    file: db_admin_username.txt
  db_admin_password:
    file: db_admin_password.txt
  redis_password:
    file: redis_password.txt
  typesense_api_key:
    file: typesense_api_key.txt

services:
  jikan_rest:
    image: "docker.io/jikanme/jikan-rest:${_JIKAN_API_VERSION:-latest}"
    user: "${APP_UID:-10001}:${APP_GID:-10001}"
    networks:
      - jikan_network
    secrets:
      - db_username
      - db_password
      - typesense_api_key
      - redis_password
    environment:
      PS1: '\[\033[1;32m\]\[\033[1;36m\][\u@\h] \[\033[1;34m\]\w\[\033[0;35m\] \[\033[1;36m\]# \[\033[0m\]'
    env_file:
      - ./docker/config/.env.compose
    ports:
      - '8080:8080/tcp'
    hostname: jikan-rest-api
    healthcheck:
      test: [ 'CMD-SHELL', 'wget --spider -q "http://127.0.0.1:2114/health?plugin=http"' ]
      interval: 2s
      timeout: 2s
    links:
      - mongodb:mongodb
      - redis:redis
      - typesense:typesense
    depends_on:
      mongodb: { condition: service_healthy }
      redis: { condition: service_healthy }
      typesense: { condition: service_healthy }

  mongodb:
    image: docker.io/mongo:focal
    hostname: mongodb
    volumes:
      - mongo-data:/data/db
      - ./docker/mongo-init.js:/docker-entrypoint-initdb.d/mongo-init.js:ro
    ports:
      - 27017/tcp
    command: "--wiredTigerCacheSizeGB ${MONGO_CACHE_SIZE_GB:-1.0}"
    networks:
      - jikan_network
    secrets:
      - db_username
      - db_password
      - db_admin_username
      - db_admin_password
    environment:
      MONGO_INITDB_ROOT_USERNAME_FILE: /run/secrets/db_admin_username
      MONGO_INITDB_ROOT_PASSWORD_FILE: /run/secrets/db_admin_password
      MONGO_INITDB_DATABASE: jikan_admin
    healthcheck:
      test: echo 'db.runCommand("ping").ok' | mongosh mongodb://localhost:27017 --quiet
      interval: 30s
      timeout: 10s
      retries: 5

  redis:
    image: docker.io/redis:6-alpine
    hostname: redis
    secrets:
      - redis_password
    networks:
      - jikan_network
    command:
      - /bin/sh
      - -c
      - redis-server --requirepass "$$(cat /run/secrets/redis_password)"
    volumes:
      - redis-data:/data:rw
    ports:
      - '6379/tcp'
    healthcheck:
      test: [ 'CMD', 'redis-cli', 'ping' ]
      interval: 500ms
      timeout: 1s

  typesense:
    image: docker.io/typesense/typesense:0.24.1
    hostname: typesense
    entrypoint: /bin/sh
    secrets:
      - typesense_api_key
    networks:
      - jikan_network
    command:
      - -c
      - TYPESENSE_API_KEY="$$(cat /run/secrets/typesense_api_key)" /opt/typesense-server --data-dir /data
    deploy:
      restart_policy:
        condition: none
    volumes:
      - typesense-data:/data
    ports:
      - "8108/tcp"



================================================
FILE: docker-entrypoint.php
================================================
#!/usr/bin/env php
<?php

use Dotenv\Dotenv;

require_once __DIR__.'/vendor/autoload.php';

$safe_defaults = [
    // mongodb regex search by default
    "SCOUT_DRIVER" => "none",
    "SCOUT_QUEUE" => false,
    "THROTTLE" => false,
    "QUEUE_CONNECTION" => "database",
    "DB_CACHING" => true,
    "DB_HOST" => "localhost",
    "DB_PORT" => 27017,
    "DB_DATABASE" => "jikan",
    "DB_USERNAME" => "",
    "DB_PASSWORD" => ""
];

// get a copy of the current env vars.
// these are the ones that are set during the container creation
$current_env = $_ENV;

if (!file_exists(".env")) {
    copy(".env.dist", ".env");
    $writer = new \MirazMac\DotEnv\Writer(__DIR__ . '/' . '.env');

    foreach ($safe_defaults as $env_var_name => $env_var_default) {
        $writer->set("SCOUT_DRIVER", env($env_var_name, $env_var_default));
    }
    $writer->write();
}

// We'd like to support Container secrets. So we'll check if any of the env vars has a __FILE suffix
// then we'll try to load the file and set the env var to the contents of the file.
// https://docs.docker.com/engine/swarm/secrets/
// Additionally we need to write the secrets to the .env file so the workers in roadrunner can access them.
// (it might just pass down the global env vars, but haven't tested that yet)
$envWriter = new \MirazMac\DotEnv\Writer(__DIR__ . '/' . '.env');
$itemsWritten = 0;
foreach (array_keys($current_env) as $env_key) {
    if (!str_contains($env_key, "__FILE")) {
        continue;
    }
    if (!file_exists($current_env[$env_key])) {
        echo "Couldn't load secret: " . $_ENV[$env_key] . PHP_EOL;
        continue;
    }
    $originalKey = str_replace("__FILE", "", $env_key);
    $secretsFileContents = file_get_contents($current_env[$env_key]);
    $envWriter->set($originalKey, str_replace(["\n", "\r"], "", $secretsFileContents));
    $itemsWritten++;
}

if ($itemsWritten > 0) {
    $envWriter->write();
    echo "Secrets loaded successfully.\n";
}

$dotenv = Dotenv::createImmutable(__DIR__);
$dotenv->load();

$current_env = $_ENV;

if ($current_env["SCOUT_DRIVER"] === "typesense" && empty($current_env["TYPESENSE_API_KEY"])) {
    echo "Please set the TYPESENSE_API_KEY environment variable when setting SCOUT_DRIVER to typesense.";
    exit(1);
}

$rrConfig = \Symfony\Component\Yaml\Yaml::parse(file_get_contents(".rr.yaml"));
$rrConfig["http"]["pool"]["supervisor"]["max_worker_memory"] = (int) env("RR_MAX_WORKER_MEMORY", 128);
$rrConfig["http"]["max_request_size"] = (int) env("RR_MAX_REQUEST_SIZE_MB", 256);
$rrConfig["service"]["laravel_queue_worker_1"]["process_num"] = (int) env("JIKAN_QUEUE_WORKER_PROCESS_NUM", 1);
$periodical_full_indexer_key = "JIKAN_ENABLE_PERIODICAL_FULL_INDEXER";
if (array_key_exists($periodical_full_indexer_key, $current_env) && in_array($current_env[$periodical_full_indexer_key], [1, '1', 'true', 'True', 'TRUE'])) {
    $supercronic_schedule = file_get_contents("/etc/supercronic/laravel");
    $supercronic_schedule .= PHP_EOL;
    $supercronic_schedule .= "0 1 * * 1 php /app/artisan indexer:anime --fail && php /app/artisan indexer:anime --resume && php /app/artisan indexer:manga --fail && php /app/artisan indexer:manga --resume";
    $supercronic_schedule .= PHP_EOL;
    file_put_contents("/etc/supercronic/laravel", $supercronic_schedule);
    $current_time = time();
    echo json_encode(["level" => "info", "ts" => "$current_time.0", "logger" => "container_entrypoint", "msg" => "Full anime/manga indexer is enabled. They will run every Monday at 1am."]) . PHP_EOL;
}
file_put_contents(".rr.yaml", \Symfony\Component\Yaml\Yaml::dump($rrConfig, 8));



================================================
FILE: docker-entrypoint.sh
================================================
#!/bin/bash
set -eo pipefail

status=0
if [[ $# -eq 0 ]] ; then
  php /app/docker-entrypoint.php
  status=$?
else
  php /app/docker-entrypoint.php "$@"
  status=$?
fi

[[ $status -ne 0 ]] && exit $status

exec rr serve -c .rr.yaml



================================================
FILE: Dockerfile
================================================
FROM docker.io/spiralscout/roadrunner:2.12.3 as roadrunner
FROM docker.io/composer:2.6.6 as composer
FROM docker.io/mlocati/php-extension-installer:2.1.77 as php-ext-installer
FROM php:8.1.27-bullseye
COPY --from=composer /usr/bin/composer /usr/bin/composer
COPY --from=php-ext-installer /usr/bin/install-php-extensions /usr/local/bin/
ENV COMPOSER_HOME="/tmp/composer"
RUN set -x \
    && install-php-extensions intl mbstring mongodb-stable redis opcache sockets pcntl \
    # install xdebug (for testing with code coverage), but do not enable it
    && IPE_DONT_ENABLE=1 install-php-extensions xdebug-3.2.0

# install roadrunner
COPY --from=roadrunner /usr/bin/rr /usr/bin/rr
LABEL org.opencontainers.image.source=https://github.com/jikan-me/jikan-rest
RUN	set -ex \
    && apt-get update && apt-get install -y --no-install-recommends \
	openssl \
	git \
    wget \
	unzip \
  # install supercronic (for laravel task scheduling), project page: <https://github.com/aptible/supercronic>
	&& wget -q "https://github.com/aptible/supercronic/releases/download/v0.1.12/supercronic-linux-$(dpkg --print-architecture)" \
	   -O /usr/bin/supercronic \
	&& chmod +x /usr/bin/supercronic \
	&& mkdir /etc/supercronic \
	&& echo '*/1 * * * * php /app/artisan schedule:run' > /etc/supercronic/laravel \
	&& rm -rf /var/lib/apt/lists/* \
	# enable opcache for CLI and JIT, docs: <https://www.php.net/manual/en/opcache.configuration.php#ini.opcache.jit>
	&& echo -e "\nopcache.enable=1\nopcache.enable_cli=1\nopcache.jit_buffer_size=32M\nopcache.jit=1235\n" >> \
	    ${PHP_INI_DIR}/conf.d/docker-php-ext-opcache.ini \
  # show php version
  && php -v \
	# show installed modules
	&& php -m \
  && composer --version \
	# create unpriviliged user
	&& adduser --disabled-password --shell "/sbin/nologin" --home "/nonexistent" --no-create-home --uid "10001" --gecos "" "jikanapi" \
	&& mkdir /app /var/run/rr \
	&& chown -R jikanapi:jikanapi /app /var/run/rr /etc/supercronic/laravel \
	&& chmod -R 777 /var/run/rr

USER jikanapi:jikanapi

WORKDIR /app

# copy composer (json|lock) files for dependencies layer caching
COPY --chown=jikanapi:jikanapi ./composer.* /app/

# install composer dependencies (autoloader MUST be generated later!)
RUN composer install -n --no-dev --no-cache --no-ansi --no-autoloader --no-scripts --prefer-dist

# copy application sources into image (completely)
COPY --chown=jikanapi:jikanapi . /app/

RUN set -ex \
    && composer dump-autoload -n --optimize --no-ansi --no-dev  \
    && chmod -R 777 ${COMPOSER_HOME}/cache \
    && chmod -R a+w storage/ \
    && chown -R jikanapi:jikanapi /app \
    && chmod +x docker-entrypoint.php \
    && chmod +x docker-entrypoint.sh

EXPOSE 8080
EXPOSE 2114

HEALTHCHECK CMD curl --fail http://localhost:2114/health?plugin=http || exit 1

# unset default image entrypoint.
ENTRYPOINT ["/app/docker-entrypoint.sh"]



================================================
FILE: LICENSE
================================================
MIT License

Copyright (c) 2019 Jikan API

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
FILE: phpunit.xml
================================================
<?xml version="1.0" encoding="UTF-8"?>
<phpunit xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:noNamespaceSchemaLocation="./vendor/phpunit/phpunit/phpunit.xsd"
         bootstrap="bootstrap/tests.php"
         colors="true"
         verbose="true"
>
    <testsuites>
        <testsuite name="integration">
          <directory>./tests/Integration/</directory>
        </testsuite>
        <testsuite name="unit">
          <directory>./tests/Unit/</directory>
        </testsuite>
    </testsuites>
    <coverage includeUncoveredFiles="false" processUncoveredFiles="true">
      <include>
        <directory suffix=".php">./app</directory>
      </include>
      <exclude>
        <directory>./vendor</directory>
        <directory>./tests</directory>
        <directory>./storage</directory>
        <directory>./resources</directory>
        <directory>./docker</directory>
        <directory>./bootstrap</directory>
        <directory>./config</directory>
        <directory>./routes</directory>
        <directory>./.github</directory>
      </exclude>
      <report>
        <html outputDirectory="./coverage/html"/>
        <xml outputDirectory="./coverage/xml"/>
        <clover outputFile="./coverage/clover.xml"/>
        <text outputFile="php://stdout" showUncoveredFiles="false"/>
      </report>
    </coverage>
    <listeners>
      <listener class="Tests\IntegrationTestListener" />
    </listeners>
    <php>
        <env name="APP_ENV" value="testing"/>
        <env name="CACHE_DRIVER" value="array"/>
        <env name="QUEUE_CONNECTION" value="sync"/>
    </php>
</phpunit>



================================================
FILE: TROUBLESHOOTING.md
================================================
# Troubleshooting Guide

## My local instance keeps returning HTTP 500

First off, check `storage/logs/lumen.log`.

**1. If you're getting a lot of Redis errors along the lines of `BGSAVE` failing.**
You probably have a low RAM resource, switch over to file caching `CACHE_DRIVER=file`.

Redis throws this error even if you have about 1/4 of your RAM free. This is because it does a background save of your entire Redis cache - which is stored in-memory and which fails without the sufficient required memory.

You can stop Redis from haggling you and override that by running the following command: `redis-cli config set stop-writes-on-bgsave-error no`

**2. Jikan is failing to cache (when `CACHE_DRIVER=file`) because the "disk is out of space" - but you're sure you have enough space available.**

Sorry! This is due to a bug on a previous release ([Issue #59](https://github.com/jikan-me/jikan-rest/issues/59)), please make sure you're upto date.

**Recovery Procedure**
- `sudo service supervisor stop`
- Delete Lumen & worker logs: `rm storage/logs/lumen.log` + `rm storage/logs/worker.log`
- Run `lsof | grep deleted` to check for the "Lumen.log" process, you'll know when it has a bizzare amount of space allocated to the process to it. Copy the process ID and then kill it; `kill [process id]` e.g `kill 12345`
- Make sure your Jikan instance is on the latest release. Run a `git pull` and then `composer update`
- Reduce the number of supervisor processes in `/etc/supervisor/conf.d/jikan-worker.conf` e.g `numprocs=1`

And then reload the supervisor configuration:

`sudo service supervisor start`

`sudo supervisorctl reread`

`sudo supervisorctl reload`

`sudo supervisorctl update`

`sudo supervisorctl start jikan-worker:*`

- Restart everything:
`sudo service supervisor restart`

`sudo service apache2 restart`

`sudo service redis restart`

If Redis is taking too long to restart, follow this: https://stackoverflow.com/a/45069100/2326811 and then start it `sudo service redis start`

## My local instance is returning HTTP 503

 This is an error forwarded from MAL, it typically happens when MAL is down. The Jikan response body includes the HTTP status from MAL, like: `[HTTP code] on [request url]` 

## I want to clear the cache in Jikan
`php artisan cache:clear`

## I want to clear the Cache Updater Queue
1. `sudo service supervisor stop`

2. `redis-cli --scan --pattern queue_update:* | xargs redis-cli del` or alternatively replace `del` with `unlink` to have it done in the background ([Redis 4.0.0 required](https://redis.io/commands/unlink))

3. `redis-cli --scan --pattern queues:* | xargs redis-cli del` or alternatively replace `del` with `unlink` to have it done in the background ([Redis 4.0.0 required](https://redis.io/commands/unlink))

4. `php artisan queue:restart`

5. `sudo service supervisor start`


More troubleshooting Q/A on the way, please let me know if there's anything else I should add onto here.



================================================
FILE: .codecov.yml
================================================
# Docs: <https://docs.codecov.io/docs/commit-status>

coverage:
  # coverage lower than 50 is red, higher than 90 green
  range: 30..80

  status:
    project:
      default:
        # Choose a minimum coverage ratio that the commit must meet to be considered a success.
        #
        # `auto` will use the coverage from the base commit (pull request base or parent commit) coverage to compare
        # against.
        target: auto

        # Allow the coverage to drop by X%, and posting a success status.
        threshold: 5%

        # Resulting status will pass no matter what the coverage is or what other settings are specified.
        informational: true

    patch:
      default:
        target: auto
        threshold: 5%
        informational: true



================================================
FILE: .dockerignore
================================================
.dockerignore
docker/*
Makefile
docker*.yml
Dockerfile
bootstrap/cache/*
storage/logs/*
storage/framework/cache/data/*
storage/framework/sessions/*
storage/framework/testing/*
storage/framework/views/*
storage/*.cache
vendor
node_modules
*.log
.gitignore
.editorconfig
.idea
.vscode
.github
.git
db_username.txt
db_password.txt
redis_password.txt
typesense_api_key.txt
.phpunit.result.cache
.env
docker-compose.yml



================================================
FILE: .editorconfig
================================================
# Editor configuration, see http://editorconfig.org
root = true

[*]
charset = utf-8
indent_style = space
indent_size = 2
insert_final_newline = true
trim_trailing_whitespace = true

[*.md]
max_line_length = off
trim_trailing_whitespace = false

[*.php]
indent_size = 4



================================================
FILE: .env.dist
================================================
###
# App
###
APP_ENV=production
APP_DEBUG=false
APP_KEY=
APP_TIMEZONE=UTC
APP_URL=http://localhost
APP_VERSION="4.2.2"

###
# Logging
###
LOG_CHANNEL=stack
LOG_SLACK_WEBHOOK_URL=
LOG_LEVEL=debug

###
# Database Caching (MongoDB)
###
DB_CACHING=true
DB_CONNECTION=mongodb
DB_HOST=localhost
DB_PORT=27017
DB_DATABASE=jikan
DB_ADMIN=jikan
DB_USERNAME=
DB_PASSWORD=

###
# Database query default values
###
MAX_RESULTS_PER_PAGE=25

###
# Enable MyAnimeList Heartbeat
#
# Monitor bad requests to determine whether MyAnimeList is down
#
# Fallback once the following threshold is reached
###
SOURCE=local
SOURCE_BAD_HEALTH_THRESHOLD=10
# Recheck source availability (in seconds)
SOURCE_BAD_HEALTH_RECHECK=10
# Fail count only within specified time range (in seconds)
SOURCE_BAD_HEALTH_RANGE=30
# Max Fail stores
SOURCE_BAD_HEALTH_MAX_STORE=50
# Disable failover if the score reaches the following (0.0-1.0 values ONLY)
# e.g 0.9 means 90% successful requests to MyAnimeList
SOURCE_GOOD_HEALTH_SCORE=0.9
# Max time request is allowed to take
# https://curl.haxx.se/libcurl/c/CURLOPT_TIMEOUT.html
SOURCE_TIMEOUT=10

###
# Caching (File, Redis, etc)
# Can be added over DB Caching
###
CACHING=false
CACHE_DRIVER=array

# Caching TTL (in seconds) on specific endpoints
CACHE_DEFAULT_EXPIRE=86400 # 1 day
CACHE_META_EXPIRE=300 # 5 minutes
CACHE_USER_EXPIRE=300 # 5 minutes
CACHE_USERLIST_EXPIRE=3600 # 1 hour
CACHE_404_EXPIRE=604800 # 7 days
CACHE_SEARCH_EXPIRE=432000 # 5 days
CACHE_PRODUCERS_EXPIRE=432000 # 5 days
CACHE_MAGAZINES_EXPIRE=432000 # 5 days
CACHE_MICROCACHE_EXPIRE=60

###
# Redis Caching Configuration
###
REDIS_HOST=127.0.0.1
REDIS_PASSWORD=null
REDIS_PORT=6379

###
# Micro Caching
# Uses CACHE_DRIVER
###
MICROCACHING=false
MICROCACHING_EXPIRE=5

###
# Queue management
# Uses QUEUE_CONNECTION as queue storage (MongoDB, Redis, etc)
###
QUEUE_CONNECTION=database
QUEUE_TABLE=jobs
QUEUE_FAILED_TABLE=jobs_failed
QUEUE_DELAY_PER_JOB=5

###
# Scout config
###
# For TypeSense use: typesense
#SCOUT_DRIVER=typesense
#SCOUT_QUEUE=false

###
# TypeSense Config
###
#TYPESENSE_HOST=localhost
#TYPESENSE_PORT=8108
#TYPESENSE_API_KEY=
#TYPESENSE_SEARCH_EXHAUSTIVE=true
#TYPESENSE_SEARCH_CUTTOFF_MS=450

###
# GitHub generate report URL on fatal errors
###
GITHUB_REPORTING=true
GITHUB_REST="jikan-me/jikan-rest"
GITHUB_API="jikan-me/jikan"

###
# OpenAPI
###
SWAGGER_VERSION=3.0

###
# API call insights
###
# Enable/Disable insights API system
INSIGHTS=false #WIP
# Max requests store in seconds - default 2 days
INSIGHTS_MAX_STORE_TIME=172800

###
# Error reporting
###
REPORTING=false
REPORTING_DRIVER=sentry
SENTRY_LARAVEL_DSN="https://examplePublicKey@o0.ingest.sentry.io/0"
SENTRY_TRACES_SAMPLE_RATE=0.5

###
# Endpoints
###
DISABLE_USER_LISTS=false



================================================
FILE: .rr.local.unix.yaml
================================================
# ---------------------------------------------------------------------------------------------------
# WARNING! This file should be used ONLY for local application development. NOT for production usage!
# ---------------------------------------------------------------------------------------------------

# Hint: RR will replace any config options using reference to environment variables,
# eg.: `option_key: ${ENVIRONMENT_VARIABLE_NAME}`.

# RR configuration version
version: "2.7"

# Remote Procedures Calling (docs: https://roadrunner.dev/docs/beep-beep-rpc)
# Is used for connecting to RoadRunner server from your PHP workers.
rpc:
  # TCP address:port for listening.
  #
  # Default: "tcp://127.0.0.1:6001"
  listen: tcp://127.0.0.1:6001

# Application server settings (docs: https://roadrunner.dev/docs/php-worker)
server:
  # Worker starting command, with any required arguments.
  #
  # This option is required.
  command: "php -dxdebug.start_with_request=trigger -dxdebug.mode=debug -dxdebug.client_port=9000 -dxdebug.client_host=127.0.0.1 -didekey=PHPSTORM ./vendor/bin/rr-worker start --relay-dsn unix:///var/run/rr/rr-relay.sock"
  env:
    - XDEBUG_SESSION: "1"

  ## Environment variables for the worker processes.
  ##
  ## Default: <empty map>
  #env:
  #  - SOME_KEY: "SOME_VALUE"
  #  - SOME_KEY2: "SOME_VALUE2"

  # Worker relay can be: "pipes", TCP (eg.: tcp://127.0.0.1:6001), or socket (eg.: unix:///var/run/rr-relay.sock).
  #
  # Default: "pipes"
  relay: "unix:///var/run/rr/rr-relay.sock"

  # Timeout for relay connection establishing (only for socket and TCP port relay).
  #
  # Default: 60s
  relay_timeout: 60s

# HTTP plugin settings.
http:
  # Host and port to listen on (eg.: `127.0.0.1:8080`).
  #
  # This option is required.
  address: 0.0.0.0:8080

  # HTTP access logs
  #
  # Default: false
  access_logs: true

  # Maximal incoming request size in megabytes. Zero means no limit.
  #
  # Default: 0
  max_request_size: 256

  # Middlewares for the http plugin, order is important. Allowed values is: "headers", "gzip".
  #
  # Default value: []
  middleware: ["static", "headers", "gzip"]

  # File uploading settings.
  uploads:
    # Directory for file uploads. Empty value means to use $TEMP based on your OS.
    #
    # Default: ""
    dir: "/tmp"

    # Deny files with the following extensions to upload.
    #
    # Default: [".php", ".exe", ".bat"]
    forbid: [".php", ".exe", ".bat", ".sh"]

  # Settings for "headers" middleware (docs: https://roadrunner.dev/docs/http-headers).
  headers:
    # Automatically add headers to every response.
    #
    # Default: <empty map>
    response:
      X-Powered-By: "RoadRunner"

  # Settings for serving static content (docs: https://roadrunner.dev/docs/http-static).
  static:
    # Path to the directory with static assets.
    #
    # This option is required.
    dir: "./public"

    # File extensions to forbid.
    #
    # Default: []
    forbid: [".htaccess", ".php"]

    # Automatically add headers to every response.
    #
    # Default: <empty map>
    response:
      X-Powered-By: "RoadRunner"

  # Workers pool settings.
  pool:
    debug: true
    # How many worker processes will be started. Zero (or nothing) means the number of logical CPUs.
    #
    # Default: 0
    num_workers: 4

    # Maximal count of worker executions. Zero (or nothing) means no limit.
    #
    # Default: 0
    max_jobs: 1

    # Timeout for worker allocation. Zero means no limit.
    #
    # Default: 60s
    allocate_timeout: 10s

    # Timeout for worker destroying before process killing. Zero means no limit.
    #
    # Default: 60s
    destroy_timeout: 10s

    # Supervisor is used to control http workers (previous name was "limit", docs:
    # https://roadrunner.dev/docs/php-limit). "Soft" limits will not interrupt current request processing. "Hard"
    # limit on the contrary - interrupts the execution of the request.
    supervisor:
      # Maximal worker memory usage in megabytes (soft limit). Zero means no limit.
      #
      # Default: 0
      max_worker_memory: 128

      # Maximal job lifetime (hard limit). Zero means no limit.
      #
      # Default: 0s
      exec_ttl: 60s

  # HTTP/2 settings.
  http2:
    # HTTP/2 over non-encrypted TCP connection using H2C.
    #
    # Default: false
    h2c: false

    # Maximal concurrent streams count.
    #
    # Default: 128
    max_concurrent_streams: 128

## Application metrics in Prometheus format (docs: https://roadrunner.dev/docs/beep-beep-metrics). Drop this section
## for this feature disabling.
#metrics:
#  # Prometheus client address (path /metrics added automatically).
#  #
#  # Default: "127.0.0.1:2112"
#  address: 127.0.0.1:8081

# Health check endpoint (docs: https://roadrunner.dev/docs/beep-beep-health). If response code is 200 - it means at
# least one worker ready to serve requests. 500 - there are no workers ready to service requests.
# Drop this section for this feature disabling.
status:
  # Host and port to listen on (eg.: `127.0.0.1:2114`). Use the following URL: http://127.0.0.1:2114/health?plugin=http
  # Multiple plugins must be separated using "&" - http://127.0.0.1:2114/health?plugin=http&plugin=rpc where "http" and
  # "rpc" are active (connected) plugins.
  #
  # This option is required.
  address: 127.0.0.1:2114

  # Response status code if a requested plugin not ready to handle requests
  # Valid for both /health and /ready endpoints
  #
  # Default: 503
  unavailable_status_code: 503

# Automatically detect PHP file changes and reload connected services (docs:
# https://roadrunner.dev/docs/beep-beep-reload). Drop this section for this feature disabling.
reload:
  # Sync interval.
  #
  # Default: "1s"
  interval: 1s

  # Global patterns to sync.
  #
  # Default: [".php"]
  patterns: [".php"]

  # List of included for sync services (this is a map, where key name is a plugin name).
  #
  # Default: <empty map>
  services:
    http:
      # Directories to sync. If recursive is set to true, recursive sync will be applied only to the directories in
      # "dirs" section. Dot (.) means "current working directory".
      #
      # Default: []
      dirs: ["."]

      # Recursive search for file patterns to add.
      #
      # Default: false
      recursive: true

      patterns: [ ".php", ".go", ".md" ]

      # Ignored folders.
      #
      # Default: []
      ignore: ["vendor"]

# RoadRunner internal container configuration (docs: https://github.com/spiral/endure).
endure:
  # Logging level. Possible values: "debug", "info", "warning", "error", "panic", "fatal".
  #
  # Default: "error"
  log_level: error
app:
  debug: true



================================================
FILE: .rr.local.yaml
================================================
# ---------------------------------------------------------------------------------------------------
# WARNING! This file should be used ONLY for local application development. NOT for production usage!
# ---------------------------------------------------------------------------------------------------

# Hint: RR will replace any config options using reference to environment variables,
# eg.: `option_key: ${ENVIRONMENT_VARIABLE_NAME}`.

# RR configuration version
version: "2.7"

# Remote Procedures Calling (docs: https://roadrunner.dev/docs/beep-beep-rpc)
# Is used for connecting to RoadRunner server from your PHP workers.
rpc:
  # TCP address:port for listening.
  #
  # Default: "tcp://127.0.0.1:6001"
  listen: tcp://127.0.0.1:6001

# Application server settings (docs: https://roadrunner.dev/docs/php-worker)
server:
  # Worker starting command, with any required arguments.
  #
  # This option is required.
  command: "php -dxdebug.start_with_request=trigger -dxdebug.mode=debug -dxdebug.client_port=9000 -dxdebug.client_host=127.0.0.1 -didekey=PHPSTORM ./vendor/bin/rr-worker start"
  env:
    - XDEBUG_SESSION: "1"

  ## Environment variables for the worker processes.
  ##
  ## Default: <empty map>
  #env:
  #  - SOME_KEY: "SOME_VALUE"
  #  - SOME_KEY2: "SOME_VALUE2"

  # Worker relay can be: "pipes", TCP (eg.: tcp://127.0.0.1:6001), or socket (eg.: unix:///var/run/rr-relay.sock).
  #
  # Default: "pipes"
  relay: "pipes"

  # Timeout for relay connection establishing (only for socket and TCP port relay).
  #
  # Default: 60s
  relay_timeout: 60s

# HTTP plugin settings.
http:
  # Host and port to listen on (eg.: `127.0.0.1:8080`).
  #
  # This option is required.
  address: 0.0.0.0:8000

  # HTTP access logs
  #
  # Default: false
  access_logs: true

  # Maximal incoming request size in megabytes. Zero means no limit.
  #
  # Default: 0
  max_request_size: 256

  # Middlewares for the http plugin, order is important. Allowed values is: "headers", "gzip".
  #
  # Default value: []
  middleware: ["static", "headers", "gzip"]

  # File uploading settings.
  uploads:
    # Directory for file uploads. Empty value means to use $TEMP based on your OS.
    #
    # Default: ""
    dir: "/tmp"

    # Deny files with the following extensions to upload.
    #
    # Default: [".php", ".exe", ".bat"]
    forbid: [".php", ".exe", ".bat", ".sh"]

  # Settings for "headers" middleware (docs: https://roadrunner.dev/docs/http-headers).
  headers:
    # Automatically add headers to every response.
    #
    # Default: <empty map>
    response:
      X-Powered-By: "RoadRunner"

  # Settings for serving static content (docs: https://roadrunner.dev/docs/http-static).
  static:
    # Path to the directory with static assets.
    #
    # This option is required.
    dir: "./public"

    # File extensions to forbid.
    #
    # Default: []
    forbid: [".htaccess", ".php"]

    # Automatically add headers to every response.
    #
    # Default: <empty map>
    response:
      X-Powered-By: "RoadRunner"

  # Workers pool settings.
  pool:
    debug: true
    # How many worker processes will be started. Zero (or nothing) means the number of logical CPUs.
    #
    # Default: 0
    num_workers: 4

    # Maximal count of worker executions. Zero (or nothing) means no limit.
    #
    # Default: 0
    max_jobs: 1

    # Timeout for worker allocation. Zero means no limit.
    #
    # Default: 60s
    allocate_timeout: 10s

    # Timeout for worker destroying before process killing. Zero means no limit.
    #
    # Default: 60s
    destroy_timeout: 10s

    # Supervisor is used to control http workers (previous name was "limit", docs:
    # https://roadrunner.dev/docs/php-limit). "Soft" limits will not interrupt current request processing. "Hard"
    # limit on the contrary - interrupts the execution of the request.
    supervisor:
      # Maximal worker memory usage in megabytes (soft limit). Zero means no limit.
      #
      # Default: 0
      max_worker_memory: 128

      # Maximal job lifetime (hard limit). Zero means no limit.
      #
      # Default: 0s
      # we use 0s here to allow time for debugging
      exec_ttl: 0s

  # HTTP/2 settings.
  http2:
    # HTTP/2 over non-encrypted TCP connection using H2C.
    #
    # Default: false
    h2c: false

    # Maximal concurrent streams count.
    #
    # Default: 128
    max_concurrent_streams: 128

## Application metrics in Prometheus format (docs: https://roadrunner.dev/docs/beep-beep-metrics). Drop this section
## for this feature disabling.
#metrics:
#  # Prometheus client address (path /metrics added automatically).
#  #
#  # Default: "127.0.0.1:2112"
#  address: 127.0.0.1:8081

# Health check endpoint (docs: https://roadrunner.dev/docs/beep-beep-health). If response code is 200 - it means at
# least one worker ready to serve requests. 500 - there are no workers ready to service requests.
# Drop this section for this feature disabling.
status:
  # Host and port to listen on (eg.: `127.0.0.1:2114`). Use the following URL: http://127.0.0.1:2114/health?plugin=http
  # Multiple plugins must be separated using "&" - http://127.0.0.1:2114/health?plugin=http&plugin=rpc where "http" and
  # "rpc" are active (connected) plugins.
  #
  # This option is required.
  address: 127.0.0.1:2114

  # Response status code if a requested plugin not ready to handle requests
  # Valid for both /health and /ready endpoints
  #
  # Default: 503
  unavailable_status_code: 503

# Automatically detect PHP file changes and reload connected services (docs:
# https://roadrunner.dev/docs/beep-beep-reload). Drop this section for this feature disabling.
reload:
  # Sync interval.
  #
  # Default: "1s"
  interval: 1s

  # Global patterns to sync.
  #
  # Default: [".php"]
  patterns: [".php"]

  # List of included for sync services (this is a map, where key name is a plugin name).
  #
  # Default: <empty map>
  services:
    http:
      # Directories to sync. If recursive is set to true, recursive sync will be applied only to the directories in
      # "dirs" section. Dot (.) means "current working directory".
      #
      # Default: []
      dirs: ["."]

      # Recursive search for file patterns to add.
      #
      # Default: false
      recursive: true

      patterns: [ ".php", ".go", ".md" ]

      # Ignored folders.
      #
      # Default: []
      ignore: ["vendor"]

# RoadRunner internal container configuration (docs: https://github.com/spiral/endure).
endure:
  # Logging level. Possible values: "debug", "info", "warning", "error", "panic", "fatal".
  #
  # Default: "error"
  log_level: error
app:
  debug: true



================================================
FILE: .rr.yaml
================================================
# Production usage guide: https://roadrunner.dev/docs/beep-beep-production

# Hint: RR will replace any config options using reference to environment variables,
# eg.: `option_key: ${ENVIRONMENT_VARIABLE_NAME}`.
# Please note that this config is used within the docker container.

# RR configuration version
version: "2.7"

# Remote Procedures Calling (docs: https://roadrunner.dev/docs/beep-beep-rpc)
# Is used for connecting to RoadRunner server from your PHP workers.
rpc:
  # TCP address:port for listening.
  #
  # Default: "tcp://127.0.0.1:6001"
  listen: tcp://127.0.0.1:6001

# Application server settings (docs: https://roadrunner.dev/docs/php-worker)
server:
  # Worker starting command, with any required arguments.
  #
  # This option is required.
  command: "php ./vendor/bin/rr-worker start --relay-dsn unix:///var/run/rr/rr-relay.sock"

  ## Environment variables for the worker processes.
  ##
  ## Default: <empty map>
  #env:
  #  - SOME_KEY: "SOME_VALUE"
  #  - SOME_KEY2: "SOME_VALUE2"

  # Worker relay can be: "pipes", TCP (eg.: tcp://127.0.0.1:6001), or socket (eg.: unix:///var/run/rr-relay.sock).
  #
  # Default: "pipes"
  relay: "unix:///var/run/rr/rr-relay.sock"

  # Timeout for relay connection establishing (only for socket and TCP port relay).
  #
  # Default: 60s
  relay_timeout: 60s

# Logging settings (docs: https://roadrunner.dev/docs/beep-beep-logging)
logs:
  # Logging mode can be "development" or "production". Do not forget to change this value for production environment.
  #
  # Development mode (which makes DPanicLevel logs panic), uses a console encoder, writes to standard error, and
  # disables sampling. Stacktraces are automatically included on logs of WarnLevel and above.
  #
  # Default: "development"
  mode: production

  # Logging level can be "panic", "error", "warning", "info", "debug".
  #
  # Default: "debug"
  level: info

  # Encoding format can be "console" or "json" (last is preferred for production usage).
  #
  # Default: "console"
  encoding: json

  # we want to use docker's log drivers, so push logs to stdout
  output: stdout
  # we want to use docker's log drivers, so push error logs to stdout
  # this way it is possible for example to pipe logs to journald or to AWS Cloudwatch
  err_output: stdout

# HTTP plugin settings.
http:
  # Host and port to listen on (eg.: `127.0.0.1:8080`).
  #
  # This option is required.
  address: 0.0.0.0:8080

  # HTTP access logs
  #
  # Default: false
  access_logs: true

  # Maximal incoming request size in megabytes. Zero means no limit.
  #
  # Default: 0
  max_request_size: 256

  # Middlewares for the http plugin, order is important. Allowed values is: "headers", "gzip".
  #
  # Default value: []
  middleware: ["static", "headers", "gzip"]

  # File uploading settings.
  uploads:
    # Directory for file uploads. Empty value means to use $TEMP based on your OS.
    #
    # Default: ""
    dir: "/tmp"

    # Deny files with the following extensions to upload.
    #
    # Default: [".php", ".exe", ".bat"]
    forbid: [".php", ".exe", ".bat", ".sh"]

  # Settings for "headers" middleware (docs: https://roadrunner.dev/docs/http-headers).
  headers:
    # Automatically add headers to every response.
    #
    # Default: <empty map>
    response:
      X-Powered-By: "RoadRunner"

  # Settings for serving static content (docs: https://roadrunner.dev/docs/http-static).
  static:
    # Path to the directory with static assets.
    #
    # This option is required.
    dir: "./public"

    # File extensions to forbid.
    #
    # Default: []
    forbid: [".htaccess", ".php"]

    # Automatically add headers to every response.
    #
    # Default: <empty map>
    response:
      X-Powered-By: "RoadRunner"

  # Workers pool settings.
  pool:
    # How many worker processes will be started. Zero (or nothing) means the number of logical CPUs.
    #
    # Default: 0
    num_workers: 0

    # Maximal count of worker executions. Zero (or nothing) means no limit.
    #
    # Default: 0
    max_jobs: 64

    # Timeout for worker allocation. Zero means no limit.
    #
    # Default: 60s
    allocate_timeout: 10s

    # Timeout for worker destroying before process killing. Zero means no limit.
    #
    # Default: 60s
    destroy_timeout: 10s

    # Supervisor is used to control http workers (previous name was "limit", docs:
    # https://roadrunner.dev/docs/php-limit). "Soft" limits will not interrupt current request processing. "Hard"
    # limit on the contrary - interrupts the execution of the request.
    supervisor:
      # Maximal worker memory usage in megabytes (soft limit). Zero means no limit.
      #
      # Default: 0
      max_worker_memory: 128

      # Maximal job lifetime (hard limit). Zero means no limit.
      #
      # Default: 0s
      exec_ttl: 60s

  # HTTP/2 settings.
  http2:
    # HTTP/2 over non-encrypted TCP connection using H2C.
    #
    # Default: false
    h2c: false

    # Maximal concurrent streams count.
    #
    # Default: 128
    max_concurrent_streams: 128

## Application metrics in Prometheus format (docs: https://roadrunner.dev/docs/beep-beep-metrics). Drop this section
## for this feature disabling.
#metrics:
#  # Prometheus client address (path /metrics added automatically).
#  #
#  # Default: "127.0.0.1:2112"
#  address: 127.0.0.1:8081

# Health check endpoint (docs: https://roadrunner.dev/docs/beep-beep-health). If response code is 200 - it means at
# least one worker ready to serve requests. 500 - there are no workers ready to service requests.
# Drop this section for this feature disabling.
status:
  # Host and port to listen on (eg.: `127.0.0.1:2114`). Use the following URL: http://127.0.0.1:2114/health?plugin=http
  # Multiple plugins must be separated using "&" - http://127.0.0.1:2114/health?plugin=http&plugin=rpc where "http" and
  # "rpc" are active (connected) plugins.
  #
  # This option is required.
  address: 127.0.0.1:2114

  # Response status code if a requested plugin not ready to handle requests
  # Valid for both /health and /ready endpoints
  #
  # Default: 503
  unavailable_status_code: 503

service:
  laravel_queue_worker_1:
    command: "php /app/artisan queue:work --queue=high,default"
    process_num: 1
    restart_sec: 5
  supercronic:
    command: "supercronic /etc/supercronic/laravel"

# RoadRunner internal container configuration (docs: https://github.com/spiral/endure).
endure:
  # Logging level. Possible values: "debug", "info", "warning", "error", "panic", "fatal".
  #
  # Default: "error"
  log_level: error



================================================
FILE: app/Anime.php
================================================
<?php

namespace App;

use App\Concerns\FilteredByLetter;
use App\Concerns\MediaFilters;
use App\Enums\AnimeRatingEnum;
use App\Enums\AnimeTypeEnum;
use App\Http\HttpHelper;
use Carbon\CarbonImmutable;
use Database\Factories\AnimeFactory;
use Illuminate\Support\Facades\App;
use Illuminate\Support\Facades\Log;
use Jikan\Helper\Constants;
use Jikan\Jikan;
use Jikan\Request\Anime\AnimeRequest;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use MongoDB\Model\BSONDocument;

class Anime extends JikanApiSearchableModel
{
    use HasFactory, MediaFilters, FilteredByLetter;

    protected array $filters = [
        "order_by", "status", "type", "sort", "max_score", "min_score", "score", "rating", "start_date", "end_date",
        "producer", "producers", "letter", "genres", "genres_exclude", "sfw", "unapproved", "kids"
    ];
    /**
     * The attributes that are mass assignable.
     *
     * @var array
     */
    protected $fillable = [
        'mal_id', 'url', 'title', 'title_english', 'title_japanese', 'title_synonyms',
        'titles', 'images', 'type', 'source', 'episodes', 'status', 'airing', 'aired',
        'duration', 'rating', 'score', 'scored_by', 'rank', 'popularity', 'members',
        'favorites', 'synopsis', 'background', 'premiered', 'broadcast', 'related',
        'producers', 'licensors', 'studios', 'genres', 'explicit_genres', 'themes',
        'demographics', 'opening_themes', 'ending_themes', 'trailer', 'approved', 'createdAt', 'modifiedAt'
    ];

    /**
     * The accessors to append to the model's array form.
     *
     * @var array
     */
    protected $appends = ['season', 'year', 'themes'];

    /**
     * The table associated with the model.
     *
     * @var string
     */
    protected $table = 'anime';

    /**
     * The attributes excluded from the model's JSON form.
     *
     * @var array
     */
    protected $hidden = [
        '_id', 'premiered', 'request_hash', 'expiresAt'
    ];

    public function __construct(array $attributes = [])
    {
        parent::__construct($attributes);
        $this->displayNameFieldName = "title";
    }

    public function setSeasonAttribute($value)
    {
        // noop
        // this attribute is calculated
    }

    public function getSeasonAttribute()
    {
        $premiered = array_key_exists('premiered', $this->attributes) ? $this->attributes['premiered'] : null;

        if (empty($premiered)
            || is_null($premiered)
            || !preg_match('~(Winter|Spring|Summer|Fall|)\s([\d+]{4})~', $premiered)
        ) {
            return null;
        }

        $season = explode(' ', $premiered)[0];
        return strtolower($season);
    }

    public function setYearAttribute($value)
    {
        // noop
        // this attribute is calculated
    }

    public function getYearAttribute()
    {
        $premiered = array_key_exists('premiered', $this->attributes) ? $this->attributes['premiered'] : null;

        if (empty($premiered)
            || is_null($premiered)
            || !is_string($premiered)
            || !preg_match('~(Winter|Spring|Summer|Fall|)\s([\d+]{4})~', $premiered)
        ) {
            return null;
        }

        return (int)explode(' ', $premiered)[1];
    }

    public function setBroadcastAttribute($value)
    {
        $this->attributes['broadcast'] = $this->adaptBroadcastValue($value);
    }

    public function getBroadcastAttribute()
    {
        if (array_key_exists("broadcast", $this->attributes)) {
            return $this->adaptBroadcastValue($this->attributes['broadcast']);
        }

        return [
            'day' => null,
            'time' => null,
            'timezone' => null,
            'string' => null
        ];
    }

    public function getThemesAttribute()
    {
        $result = [];
        if (array_key_exists("themes", $this->attributes)) {
            $result = $this->attributes["themes"];
        }

        return $result;
    }

    /** @noinspection PhpUnused */
    public function filterByType(\Laravel\Scout\Builder|\Illuminate\Database\Eloquent\Builder $query, AnimeTypeEnum $value): \Laravel\Scout\Builder|\Illuminate\Database\Eloquent\Builder
    {
        return $query->where("type", $value->label);
    }

    /** @noinspection PhpUnused */
    public function filterByRating(\Laravel\Scout\Builder|\Illuminate\Database\Eloquent\Builder $query, AnimeRatingEnum $value): \Laravel\Scout\Builder|\Illuminate\Database\Eloquent\Builder
    {
        return $query->where("rating", $value->label);
    }

    /** @noinspection PhpUnused */
    public function filterByStartDate(\Laravel\Scout\Builder|\Illuminate\Database\Eloquent\Builder $query, CarbonImmutable $value): \Laravel\Scout\Builder|\Illuminate\Database\Eloquent\Builder
    {
        return $query
            ->where("aired.from", ">=",
                $value
                    ->setTime(0, 0)
                    ->setTimezone(new \DateTimeZone('UTC'))
                    ->toAtomString()
            );
    }

    /** @noinspection PhpUnused */
    public function filterByEndDate(\Laravel\Scout\Builder|\Illuminate\Database\Eloquent\Builder $query, CarbonImmutable $value): \Laravel\Scout\Builder|\Illuminate\Database\Eloquent\Builder
    {
        return $query
            ->where("aired.to", "<=",
                $value
                    ->setTime(0, 0)
                    ->setTimezone(new \DateTimeZone('UTC'))
                    ->toAtomString()
            );
    }

    public function filterByProducer(\Laravel\Scout\Builder|\Illuminate\Database\Eloquent\Builder $query, string $value): \Laravel\Scout\Builder|\Illuminate\Database\Eloquent\Builder
    {
        if (empty($value)) {
            return $query;
        }

        $producer = (int)$value;
        return $query->where(function (\Jenssegers\Mongodb\Eloquent\Builder $query) use ($producer) {
            return $query->where('producers.mal_id', $producer)
                ->orWhere('licensors.mal_id', $producer)
                ->orWhere('studios.mal_id', $producer);
        });
    }

    /** @noinspection PhpUnused */
    public function filterByProducers(\Laravel\Scout\Builder|\Illuminate\Database\Eloquent\Builder $query, string $value): \Laravel\Scout\Builder|\Illuminate\Database\Eloquent\Builder
    {
        if (empty($value)) {
            return $query;
        }

        /* @var \Illuminate\Support\Collection $producers */
        $producers = collect(explode(',', $value))->filter();

        return $query->where(function (\Jenssegers\Mongodb\Eloquent\Builder $query) use ($producers) {
            $firstProducer = (int)$producers->first();
            $query = $query->where('producers.mal_id', $firstProducer)
                ->orWhere('licensors.mal_id', $firstProducer)
                ->orWhere('studios.mal_id', $firstProducer);

            foreach ($producers->skip(1) as $producer) {
                $producer = (int)$producer;
                $query = $query->orWhere('producers.mal_id', $producer)
                    ->orWhere('licensors.mal_id', $producer)
                    ->orWhere('studios.mal_id', $producer);
            }

            return $query;
        });
    }

    /** @noinspection PhpUnused */
    public function scopeExceptItemsWithAdultRating(\Laravel\Scout\Builder|\Illuminate\Database\Eloquent\Builder $query): \Laravel\Scout\Builder|\Illuminate\Database\Eloquent\Builder
    {
        return $query
            ->where("demographics.mal_id", "!=", Constants::GENRE_ANIME_HENTAI)
            ->where("demographics.mal_id", "!=", Constants::GENRE_ANIME_EROTICA)
            ->where("rating", "!=", AnimeRatingEnum::rx()->label)
            ->where("genres.mal_id", "!=", Constants::GENRE_ANIME_HENTAI);
    }

    /** @noinspection PhpUnused */
    public function scopeExceptKidsItems(\Laravel\Scout\Builder|\Illuminate\Database\Eloquent\Builder $query): \Laravel\Scout\Builder|\Illuminate\Database\Eloquent\Builder
    {
        return $query
            ->where("demographics.mal_id", "!=", Constants::GENRE_ANIME_KIDS);
    }

    /** @noinspection PhpUnused */
    public function scopeOnlyKidsItems(\Laravel\Scout\Builder|\Illuminate\Database\Eloquent\Builder $query): \Laravel\Scout\Builder|\Illuminate\Database\Eloquent\Builder
    {
        return $query
            ->where("demographics.mal_id", Constants::GENRE_ANIME_KIDS);
    }

    public static function scrape(int $id)
    {
        $data = app('JikanParser')->getAnime(new AnimeRequest($id));

        return HttpHelper::serializeEmptyObjectsControllerLevel(
            json_decode(
                app('SerializerV4')
                    ->serialize($data, 'json'),
                true
            )
        );
    }

    /**
     * Converts the model to an index-able data array.
     *
     * @return array
     */
    public function toSearchableArray(): array
    {
        return [
            'id' => (string)$this->mal_id,
            'mal_id' => (int)$this->mal_id,
            'start_date' => $this->convertToTimestamp($this->aired['from']),
            'end_date' => $this->convertToTimestamp($this->aired['to']),
            'title' => $this->title,
            'title_transformed' => $this->simplifyStringForSearch($this->title),
            'title_english' => $this->title_english ?? "",
            'title_english_transformed' => $this->simplifyStringForSearch($this->title_english),
            'title_japanese' => $this->title_japanese,
            'title_japanese_transformed' => $this->simplifyStringForSearch($this->title_japanese),
            'title_synonyms' => collect($this->titles ?? [])
                                    ->filter(fn($v, $k) => !in_array($v["type"], ["Default", "English", "Japanese"]))
                                    ->pluck("title")
                                    ->values()
                                    ->all(),
            'type' => $this->type,
            'source' => $this->source,
            'episodes' => $this->episodes,
            'status' => $this->status,
            'airing' => $this->airing,
            'rating' => $this->rating,
            'score' => $this->score,
            'rank' => $this->rank,
            'popularity' => $this->popularity,
            'members' => $this->members,
            'favorites' => $this->favorites,
            'synopsis' => $this->synopsis,
            'season' => $this->season,
            'year' => $this->year,
            'approved' => $this->approved ?? false,
            'producers' => $this->getMalIdsOfField($this->producers),
            'studios' => $this->getMalIdsOfField($this->studios),
            'licensors' => $this->getMalIdsOfField($this->licensors),
            'genres' => $this->getMalIdsOfField($this->genres),
            'explicit_genres' => $this->getMalIdsOfField($this->explicit_genres)
        ];
    }

    public function getCollectionSchema(): array
    {
        return [
            'name' => $this->searchableAs(),
            'fields' => [
                [
                    'name' => '.*',
                    'type' => 'auto',
                ],
                [
                    'name' => 'title',
                    'type' => 'string',
                    'optional' => false,
                    'infix' => true,
                    'sort' => true
                ],
                [
                    'name' => 'title_transformed',
                    'type' => 'string',
                    'optional' => false,
                    'infix' => true,
                    'sort' => true
                ],
                [
                    'name' => 'title_japanese',
                    'type' => 'string',
                    'optional' => true,
                    'locale' => 'jp',
                    'infix' => true,
                    'sort' => false
                ],
                [
                    'name' => 'title_japanese_transformed',
                    'type' => 'string',
                    'optional' => true,
                    'locale' => 'jp',
                    'infix' => true,
                    'sort' => false
                ],
                [
                    'name' => 'title_english',
                    'type' => 'string',
                    'optional' => true,
                    'infix' => true,
                    'sort' => true
                ],
                [
                    'name' => 'title_english_transformed',
                    'type' => 'string',
                    'optional' => true,
                    'infix' => true,
                    'sort' => true
                ],
                [
                    'name' => 'title_synonyms',
                    'type' => 'string[]',
                    'optional' => true,
                    'infix' => true,
                    'sort' => false
                ]
            ]
        ];
    }

    /**
     * The fields to be queried against. See https://typesense.org/docs/0.21.0/api/documents.html#search.
     *
     * @return array
     */
    public function typesenseQueryBy(): array
    {
        return [
            'title',
            'title_transformed',
            'title_english',
            'title_english_transformed',
            'title_japanese',
            'title_japanese_transformed',
            'title_synonyms',
        ];
    }

    public function getTypeSenseQueryByWeights(): string|null
    {
        return "2,2,1,1,3,3,1";
    }

    /**
     * Returns which fields the search index should sort on when searching
     * @return array|null
     */
    public function getSearchIndexSortBy(): array|null
    {
        return [
            [
                "field" => "_text_match(buckets:".text_match_buckets().")",
                "direction" => "desc"
            ],
            [
                "field" => "popularity",
                "direction" => "asc"
            ],
            [
                "field" => "rank",
                "direction" => "asc"
            ]
        ];
    }

    private function adaptBroadcastValue(array|string|null|BSONDocument $broadcast): array
    {
        $null_value = [
            'day' => null,
            'time' => null,
            'timezone' => null,
            'string' => null
        ];
        if (is_null($broadcast)) {
            return $null_value;
        }

        if (is_array($broadcast)) {
            return $broadcast;
        }

        if ($broadcast instanceof BSONDocument) {
            return $broadcast->getArrayCopy();
        }

        if (!preg_match('~(.*) at (.*) \(~', $broadcast, $matches)) {
            return [
                'day' => null,
                'time' => null,
                'timezone' => null,
                'string' => $broadcast
            ];
        }

        if (preg_match('~(.*) at (.*) \(~', $broadcast, $matches)) {
            return [
                'day' => $matches[1],
                'time' => $matches[2],
                'timezone' => 'Asia/Tokyo',
                'string' => $broadcast
            ];
        }

        return $null_value;
    }

    protected static function newFactory()
    {
        return App::make(AnimeFactory::class);
    }
}



================================================
FILE: app/CarbonDateRange.php
================================================
<?php

namespace App;

use Illuminate\Support\Carbon;
use Jikan\Model\Common\DateProp;

/**
 * Class representing a date range via Carbon objects.
 *
 * Mainly used for testing.
 */
class CarbonDateRange
{
    private ?Carbon $fromObj = null;
    private ?Carbon $untilObj = null;

    public function __construct(?Carbon $from, ?Carbon $to)
    {
        $this->fromObj = $from;
        $this->untilObj = $to;
    }

    public function __toString()
    {
        $result = "";
        if ($this->untilObj === null && $this->fromObj !== null && $this->fromObj->day == 1 && $this->fromObj->month == 1) {
            $result = "{$this->fromObj->year}";
        }
        else if ($this->untilObj === null && $this->fromObj !== null && $this->fromObj->day == 1) {
            $result = $this->fromObj->format("M, Y");
        }
        else if ($this->untilObj === null && $this->fromObj !== null) {
            $result = $this->fromObj->format("M d, Y");
        }
        else if ($this->untilObj !== null && $this->fromObj !== null) {
            $result = "{$this->fromObj->format("M d, Y")} to {$this->untilObj->format("M d, Y")}";
        }
        return $result;
    }

    public function getFrom(): ?Carbon
    {
        return $this->fromObj;
    }

    public function getUntil(): ?Carbon
    {
        return $this->untilObj;
    }

    public function getFromProp(): ?DateProp
    {
        return DateProp::fromDateTime($this->fromObj?->toDateTimeImmutable());
    }

    public function getUntilProp(): ?DateProp
    {
        return DateProp::fromDateTime($this->untilObj?->toDateTimeImmutable());
    }
}



================================================
FILE: app/Character.php
================================================
<?php

namespace App;

use App\Concerns\FilteredByLetter;
use Jikan\Jikan;
use Jikan\Request\Character\CharacterRequest;
use Illuminate\Database\Eloquent\Factories\HasFactory;

class Character extends JikanApiSearchableModel
{
    use HasFactory, FilteredByLetter;

    protected array $filters = ["order_by", "sort", "letter"];

    /**
     * The attributes that are mass assignable.
     *
     * @var array
     */
    protected $fillable = [
        'mal_id', 'url', 'name', 'name_kanji', 'nicknames', 'about', 'member_favorites',
        'images', 'animeography', 'mangaography', 'voice_actors',
        'createdAt', 'modifiedAt'
    ];

    /**
     * The accessors to append to the model's array form.
     *
     * @var array
     */
    protected $appends = ['images', 'favorites'];

    /**
     * The table associated with the model.
     *
     * @var string
     */
    protected $table = 'characters';

    /**
     * The attributes excluded from the model's JSON form.
     *
     * @var array
     */
    protected $hidden = [
        '_id', 'trailer_url', 'premiered', 'opening_themes', 'ending_themes', 'member_favorites'
    ];

    public function __construct(array $attributes = [])
    {
        parent::__construct($attributes);
        $this->displayNameFieldName = "name";
    }

    /** @noinspection PhpUnused */
    public function getFavoritesAttribute()
    {
        return $this->attributes['member_favorites'];
    }

    /** @noinspection PhpUnused */
    public function getImagesAttribute()
    {
        return $this->attributes['images'];
    }

    public static function scrape(int $id)
    {
        $data = app('JikanParser')->getCharacter(new CharacterRequest($id));
        return json_decode(
            app('SerializerV4')
                ->serialize($data, 'json'),
            true
        );
    }

    public function toSearchableArray(): array
    {
        return [
            'id' => (string) $this->mal_id,
            'mal_id' => (int) $this->mal_id,
            'name' => $this->name,
            'name_kanji' => $this->name_kanji,
            'member_favorites' => $this->member_favorites
        ];
    }

    public function typesenseQueryBy(): array
    {
        return [
            'name',
            'name_kanji'
        ];
    }

    public function getTitleAttributeName(): string
    {
        return 'name';
    }
}



================================================
FILE: app/Club.php
================================================
<?php

namespace App;

use App\Concerns\FilteredByLetter;
use App\Enums\ClubCategoryEnum;
use App\Enums\ClubTypeEnum;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Jikan\Request\Club\ClubRequest;

class Club extends JikanApiSearchableModel
{
    use FilteredByLetter, HasFactory;

    protected array $filters = ["order_by", "sort", "letter", "category", "type"];

    /**
     * The attributes that are mass assignable.
     *
     * @var array
     */
    protected $fillable = [
        'mal_id', 'url', 'images', 'name', 'members', 'category', 'created', 'access', 'anime', 'manga', 'created_at', 'updated_at', 'characters', 'staff'
    ];

    /**
     * The accessors to append to the model's array form.
     *
     * @var array
     */
    protected $appends = ['images'];

    /**
     * The table associated with the model.
     *
     * @var string
     */
    protected $table = 'clubs';

    /**
     * The attributes excluded from the model's JSON form.
     *
     * @var array
     */
    protected $hidden = [
        '_id', 'request_hash', 'expiresAt'
    ];

    public function __construct(array $attributes = [])
    {
        parent::__construct($attributes);
        $this->displayNameFieldName = "name";
    }

    /** @noinspection PhpUnused */
    public function filterByCategory(\Laravel\Scout\Builder|\Illuminate\Database\Eloquent\Builder $query, ClubCategoryEnum $value): \Laravel\Scout\Builder|\Illuminate\Database\Eloquent\Builder
    {
        return $query->where("category", $value->label);
    }

    /** @noinspection PhpUnused */
    public function filterByType(\Laravel\Scout\Builder|\Illuminate\Database\Eloquent\Builder $query, ClubTypeEnum $value): \Laravel\Scout\Builder|\Illuminate\Database\Eloquent\Builder
    {
        return $query->where("access", $value->label);
    }

    /** @noinspection PhpUnused */
    public function getImagesAttribute()
    {
        return $this->attributes['images'];
    }

    public static function scrape(int $id)
    {
        $data = app('JikanParser')->getClub(new ClubRequest($id));

        return json_decode(
            app('SerializerV4')
                ->serialize($data, 'json'),
            true
        );
    }

    public function toSearchableArray(): array
    {
        return [
            'id' => (string) $this->mal_id,
            'mal_id' => (int) $this->mal_id,
            'name' => $this->name,
            'category' => $this->category,
            'created' => $this->convertToTimestamp($this->created),
            'access' => $this->type,
            'members' => $this->members
        ];
    }

    public function typesenseQueryBy(): array
    {
        return ['name'];
    }

    public function getTitleAttributeName(): string
    {
        return 'name';
    }
}



================================================
FILE: app/Episode.php
================================================
<?php

namespace App;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Jenssegers\Mongodb\Eloquent\Model;
use Jikan\Jikan;

class Episode extends Model
{
    use HasFactory;

    /**
     * The attributes that are mass assignable.
     *
     * @var array
     */
    protected $fillable = [
        'mal_id', 'title', 'title_japanese', 'title_romanji', 'aired', 'filler', 'recap', 'video_url', 'forum_url', 'synopsis',
        'createdAt', 'modifiedAt'
    ];

    /**
     * The accessors to append to the model's array form.
     *
     * @var array
     */
    protected $appends = [];

    /**
     * The table associated with the model.
     *
     * @var string
     */
    protected $table = 'anime_episode';

    /**
     * The attributes excluded from the model's JSON form.
     *
     * @var array
     */
    protected $hidden = [
        '_id', 'request_hash'
    ];

}



================================================
FILE: app/GenreAnime.php
================================================
<?php

namespace App;

use Jenssegers\Mongodb\Eloquent\Model;
use Jikan\Request\Genre\AnimeGenresRequest;
use Illuminate\Database\Eloquent\Factories\HasFactory;

/**
 * Class Magazine
 * @package App
 */
class GenreAnime extends JikanApiSearchableModel
{
    use HasFactory;

    protected array $filters = [];

    /**
     * The attributes that are mass assignable.
     *
     * @var array
     */
    protected $fillable = [
        'mal_id', 'name', 'url', 'count',
        'createdAt', 'modifiedAt'
    ];

    /**
     * The table associated with the model.
     *
     * @var string
     */
    protected $table = 'genres_anime';


    /**
     * The attributes excluded from the model's JSON form.
     *
     * @var array
     */
    protected $hidden = [
        '_id', 'expiresAt'
    ];

    /**
     * @return array
     */
    public static function scrape() : array
    {
        $data = app('JikanParser')->getAnimeGenres(new AnimeGenresRequest());

        return json_decode(
            app('SerializerV4')
                ->serialize($data, 'json'),
            true
        );
    }

    public function toSearchableArray(): array
    {
        return [
            'id' => (string) $this->mal_id,
            'mal_id' => (int) $this->mal_id,
            'name' => $this->name,
            'count' => $this->count
        ];
    }

    public function typesenseQueryBy(): array
    {
        return [
            'name'
        ];
    }

    public function getTitleAttributeName(): string
    {
        return 'name';
    }
}



================================================
FILE: app/GenreManga.php
================================================
<?php

namespace App;

use Jenssegers\Mongodb\Eloquent\Model;
use Jikan\Request\Genre\AnimeGenresRequest;
use Illuminate\Database\Eloquent\Factories\HasFactory;

/**
 * Class Magazine
 * @package App
 */
class GenreManga extends JikanApiSearchableModel
{
    use HasFactory;

    protected array $filters = [];

    /**
     * The attributes that are mass assignable.
     *
     * @var array
     */
    protected $fillable = [
        'mal_id', 'name', 'url', 'count',
        'createdAt', 'modifiedAt'
    ];

    /**
     * The table associated with the model.
     *
     * @var string
     */
    protected $table = 'genres_manga';

    /**
     * The attributes excluded from the model's JSON form.
     *
     * @var array
     */
    protected $hidden = [
        '_id', 'expiresAt'
    ];

    /**
     * @return array
     */
    public static function scrape() : array
    {
        $data = app('JikanParser')->getAnimeGenres(new AnimeGenresRequest());

        return json_decode(
            app('SerializerV4')
                ->serialize($data, 'json'),
            true
        );
    }

    public function toSearchableArray(): array
    {
        return [
            'id' => (string) $this->mal_id,
            'mal_id' => (int) $this->mal_id,
            'name' => $this->name,
            'count' => $this->count
        ];
    }

    public function typesenseQueryBy(): array
    {
        return [
            'name'
        ];
    }

    public function getTitleAttributeName(): string
    {
        return 'name';
    }
}



================================================
FILE: app/IsoDateFormatter.php
================================================
<?php

namespace App;

trait IsoDateFormatter
{
    protected function formatIsoDateTime(string $d): string
    {
        $dt = explode('-', $d);
        return (new \DateTime())
            ->setDate(
                $dt[0] ?? date('Y'),
                $dt[1] ?? 1,
                $dt[2] ?? 1
            )
            ->setTime(0, 0)
            ->setTimezone(new \DateTimeZone('UTC'))
            ->format(DATE_ATOM);
    }
}



================================================
FILE: app/JikanApiModel.php
================================================
<?php

namespace App;

use App\Enums\AnimeRatingEnum;
use App\Enums\MangaTypeEnum;
use App\Filters\FilterQueryString;
use Illuminate\Support\Collection;
use Jenssegers\Mongodb\Eloquent\Builder;
use Jikan\Helper\Constants;

class JikanApiModel extends \Jenssegers\Mongodb\Eloquent\Model
{
    use FilterQueryString;

    /**
     * The list of parameters which can be used to filter the result-set from the database.
     * The available field names and "order_by" is allowed as values. If "order_by" is specified then the field name
     * from the  "order_by" query string parameter will be used to sort the results.
     * @var string[]
     */
    protected array $filters = [];

    /** @noinspection PhpUnused */
    public function scopeRandom(Builder $query, int $numberOfRandomItems = 1, bool $sfw = false, bool $unapproved = false): Collection
    {
        return $query->raw(function(\Jenssegers\Mongodb\Collection $collection) use ($numberOfRandomItems, $sfw, $unapproved) {
            $sfwFilter = [
                'demographics.mal_id' => [
                    '$nin' => [
                        Constants::GENRE_ANIME_HENTAI,
                        Constants::GENRE_ANIME_EROTICA,
                        Constants::GENRE_MANGA_HENTAI,
                        Constants::GENRE_MANGA_EROTICA
                    ]
                ],
                'rating' => ['$ne' => AnimeRatingEnum::rx()->label],
                'type' => ['$ne' => MangaTypeEnum::doujin()->label],
                'genres.mal_id' => ['$nin' => [
                    Constants::GENRE_ANIME_HENTAI,
                    Constants::GENRE_MANGA_HENTAI
                ]]
            ];

            $pipelineParams = [
                ['$sample' => ['size' => $numberOfRandomItems]]
            ];

            if ($sfw && $unapproved) {
                array_unshift($pipelineParams, [
                    '$match' => [
                        ...$sfwFilter,
                        'approved' => false
                    ]
                ]);
            } else if ($sfw) {
                array_unshift($pipelineParams, ['$match' => $sfwFilter]);
            } else if ($unapproved) {
                array_unshift($pipelineParams, ['$match' => ['approved' => false]]);
            }

            return $collection->aggregate($pipelineParams);
        });
    }
}



================================================
FILE: app/JikanApiSearchableModel.php
================================================
<?php

namespace App;

use Jenssegers\Mongodb\Eloquent\Model;
use Typesense\LaravelTypesense\Interfaces\TypesenseDocument;

abstract class JikanApiSearchableModel extends JikanApiModel implements TypesenseDocument
{
    use JikanSearchable;

    /**
     * @return string[]
     */
    public abstract function typesenseQueryBy(): array;

    /**
     * The Typesense schema to be created.
     *
     * @return array
     */
    public function getCollectionSchema(): array
    {
        $titleAttributeName = $this->getTitleAttributeName();

        return [
            'name' => $this->searchableAs(),
            'fields' => [
                [
                    'name' => '.*',
                    'type' => 'auto',
                ],
                [
                    'name' => $titleAttributeName,
                    'type' => 'string',
                    'sort' => true,
                    'optional' => false
                ]
            ]
        ];
    }

    /**
     * Get the name of the index associated with the model.
     *
     * @return string
     */
    public function searchableAs(): string
    {
        return strtolower($this->table) . '_index' . (env("APP_ENV") === "testing" ? "_testing" : "");
    }

    /**
     * Get the value used to index the model.
     *
     * @return mixed
     */
    public function getScoutKey(): mixed
    {
        return $this->mal_id;
    }

    /**
     * Get the key name used to index the model.
     *
     * @return mixed
     */
    public function getScoutKeyName(): mixed
    {
        return 'mal_id';
    }

    /**
     * Returns what weights to use on query_by fields.
     * https://typesense.org/docs/0.23.0/api/documents.html#search-parameters
     * @return string|null
     */
    public function getTypeSenseQueryByWeights(): string|null
    {
        return null;
    }

    /**
     * Returns which fields the search index should sort on when searching
     * @return array|null
     */
    public function getSearchIndexSortBy(): array|null
    {
        return null;
    }

    protected function simplifyStringForSearch($val): string
    {
        if (!$val) {
            return "";
        }
        return preg_replace("/[^[:alnum:][:space:]]/u", ' ', $val) ?? "";
    }

    public function getTitleAttributeName(): string
    {
        return 'title';
    }
}



================================================
FILE: app/JikanSearchable.php
================================================
<?php
namespace App;

use Jikan\Helper\Parser;
use Laravel\Scout\Builder;
use Laravel\Scout\Searchable;
use MongoDB\BSON\UTCDateTime;

trait JikanSearchable
{
    use Searchable;

    protected function toTypeSenseCompatibleNestedField(string $fieldName): array
    {
        $field = $this->{$fieldName};

        if (!is_array($field) && !is_object($field)) {
            return $field;
        }

        return collect($field)->to2dArrayWithDottedKeys($field, $fieldName.'.');
    }

    protected function getMalIdsOfField(mixed $field): array
    {
        if (is_null($field)) {
            return [];
        }
        return array_map(function($elem) {
            return $elem["mal_id"];
        }, $field);
    }

    protected function convertToTimestamp(mixed $datetime): int
    {
        if ($datetime instanceof \DateTimeInterface) {
            return $datetime->getTimestamp();
        }
        if ($datetime instanceof UTCDateTime) {
            return $datetime->toDateTime()->getTimestamp();
        }
        return $datetime ? Parser::parseDate($datetime)->getTimestamp() : 0;
    }

    public function queryScoutModelsByIds(Builder $builder, array $ids): \Laravel\Scout\Builder|\Illuminate\Database\Eloquent\Builder
    {
        $query = static::usesSoftDelete()
            ? $this->withTrashed() : $this->newQuery();

        if ($builder->queryCallback) {
            call_user_func($builder->queryCallback, $query);
        }

        $whereIn = in_array($this->getKeyType(), ['int', 'integer']) ?
            'whereIntegerInRaw' :
            'whereIn';

        return $query->{$whereIn}(
            $this->getScoutKeyName(), array_map(fn ($v) => (int)$v, $ids)
        );
    }
}



================================================
FILE: app/Magazine.php
================================================
<?php

namespace App;

use App\Concerns\FilteredByLetter;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Jikan\Jikan;
use Jikan\Request\Magazine\MagazinesRequest;

/**
 * Class Magazine
 * @package App
 */
class Magazine extends JikanApiSearchableModel
{
    use FilteredByLetter, HasFactory;
    protected array $filters = ["order_by", "sort", "letter"];

    /**
     * The attributes that are mass assignable.
     *
     * @var array
     */
    protected $fillable = [
        'mal_id', 'name', 'url', 'count',
        'createdAt', 'modifiedAt'
    ];

    /**
     * The table associated with the model.
     *
     * @var string
     */
    protected $table = 'magazines';

    /**
     * The attributes excluded from the model's JSON form.
     *
     * @var array
     */
    protected $hidden = [
        '_id', 'expiresAt'
    ];

    public function __construct(array $attributes = [])
    {
        parent::__construct($attributes);
        $this->displayNameFieldName = "name";
    }

    /**
     * @return array
     */
    public static function scrape() : array
    {
        $data = app('JikanParser')->getMagazines(new MagazinesRequest());

        return json_decode(
            app('SerializerV4')
                ->serialize($data, 'json'),
            true
        );
    }

    public function toSearchableArray(): array
    {
        return [
            'id' => (string) $this->mal_id,
            'mal_id' => (int) $this->mal_id,
            'name' => $this->name,
            'count' => $this->count
        ];
    }

    public function typesenseQueryBy(): array
    {
        return [
            'name'
        ];
    }

    public function getTitleAttributeName(): string
    {
        return 'name';
    }
}



================================================
FILE: app/Manga.php
================================================
<?php

namespace App;

use App\Concerns\FilteredByLetter;
use App\Concerns\MediaFilters;
use App\Enums\MangaTypeEnum;
use App\Http\HttpHelper;
use Carbon\CarbonImmutable;
use Database\Factories\MangaFactory;
use Illuminate\Support\Facades\App;
use Jikan\Helper\Constants;
use Jikan\Jikan;
use Jikan\Request\Manga\MangaRequest;
use Illuminate\Database\Eloquent\Factories\HasFactory;

class Manga extends JikanApiSearchableModel
{
    use HasFactory, MediaFilters, FilteredByLetter;

    protected array $filters = [
        "order_by", "status", "type", "sort", "max_score", "min_score", "score", "start_date", "end_date", "magazine",
        "magazines", "letter", "genres", "genres_exclude", "sfw", "unapproved", "kids"
    ];

    /**
     * The attributes that are mass assignable.
     *
     * @var array
     */
    protected $fillable = [
        'mal_id', 'url', 'title', 'title_english', 'title_japanese', 'title_synonyms', 'titles',
        'images', 'status', 'type', 'volumes', 'chapters', 'publishing', 'published', 'rank', 'score',
        'scored_by', 'popularity', 'members', 'favorites', 'synopsis', 'background', 'related',
        'genres', 'explicit_genres', 'themes', 'demographics', 'authors', 'serializations',
        'createdAt', 'modifiedAt', 'approved'
    ];

    /**
     * The accessors to append to the model's array form.
     *
     * @var array
     */
    protected $appends = ['themes'];

    /**
     * The table associated with the model.
     *
     * @var string
     */
    protected $table = 'manga';

    /**
     * The attributes excluded from the model's JSON form.
     *
     * @var array
     */
    protected $hidden = [
        '_id', 'expiresAt', 'request_hash'
    ];

    public function __construct(array $attributes = [])
    {
        parent::__construct($attributes);
        $this->displayNameFieldName = "title";
    }

    /** @noinspection PhpUnused */
    public function filterByStartDate(\Laravel\Scout\Builder|\Illuminate\Database\Eloquent\Builder $query, CarbonImmutable $value): \Laravel\Scout\Builder|\Illuminate\Database\Eloquent\Builder
    {
        return $query
            ->where("published.from", ">=",
                $value->setTime(0, 0)
                    ->setTimezone(new \DateTimeZone('UTC'))
                    ->toAtomString()
            );
    }

    /** @noinspection PhpUnused */
    public function filterByType(\Laravel\Scout\Builder|\Illuminate\Database\Eloquent\Builder $query, MangaTypeEnum $value): \Laravel\Scout\Builder|\Illuminate\Database\Eloquent\Builder
    {
        return $query->where("type", $value->label);
    }

    /** @noinspection PhpUnused */
    public function filterByEndDate(\Laravel\Scout\Builder|\Illuminate\Database\Eloquent\Builder $query, CarbonImmutable $value): \Laravel\Scout\Builder|\Illuminate\Database\Eloquent\Builder
    {
        return $query
            ->where("published.to", "<=",
                $value->setTime(0, 0)
                    ->setTimezone(new \DateTimeZone('UTC'))
                    ->toAtomString()
            );
    }

    public function filterByMagazine(\Laravel\Scout\Builder|\Illuminate\Database\Eloquent\Builder $query, string $value): \Laravel\Scout\Builder|\Illuminate\Database\Eloquent\Builder
    {
        if (empty($value)) {
            return $query;
        }

        $magazine = (int)$value;
        return $query
            ->where('serializations.mal_id', $magazine);
    }

    /** @noinspection PhpUnused */
    public function filterByMagazines(\Laravel\Scout\Builder|\Illuminate\Database\Eloquent\Builder $query, string $value): \Laravel\Scout\Builder|\Illuminate\Database\Eloquent\Builder
    {
        if (empty($value)) {
            return $query;
        }

        /** @var \Illuminate\Support\Collection $magazines */
        $magazines = collect(explode(',', $value))->filter()->map(fn($x) => (int)$x)->toArray();

        return $query->whereIn("serializations.mal_id", $magazines);
    }

    /** @noinspection PhpUnused */
    public function scopeExceptItemsWithAdultRating(\Laravel\Scout\Builder|\Illuminate\Database\Eloquent\Builder $query): \Laravel\Scout\Builder|\Illuminate\Database\Eloquent\Builder
    {
        return $query
            ->where("type", "!=", MangaTypeEnum::doujin()->label)
            ->where("demographics.mal_id", "!=", Constants::GENRE_MANGA_HENTAI)
            ->where("demographics.mal_id", "!=", Constants::GENRE_MANGA_EROTICA)
            ->where("genres.mal_id", "!=", Constants::GENRE_MANGA_HENTAI);
    }

    /** @noinspection PhpUnused */
    public function scopeExceptKidsItems(\Laravel\Scout\Builder|\Illuminate\Database\Eloquent\Builder $query): \Laravel\Scout\Builder|\Illuminate\Database\Eloquent\Builder
    {
        return $query
            ->where("demographics.mal_id", "!=", Constants::GENRE_MANGA_KIDS);
    }

    /** @noinspection PhpUnused */
    public function scopeOnlyKidsItems(\Laravel\Scout\Builder|\Illuminate\Database\Eloquent\Builder $query): \Laravel\Scout\Builder|\Illuminate\Database\Eloquent\Builder
    {
        return $query
            ->where("demographics.mal_id", Constants::GENRE_MANGA_KIDS);
    }

    public static function scrape(int $id)
    {
        $data = app('JikanParser')->getManga(new MangaRequest($id));

        return HttpHelper::serializeEmptyObjectsControllerLevel(
            json_decode(
                app('SerializerV4')
                ->serialize($data, 'json'),
                true
            )
        );
    }

    /**
     * Converts the model to an index-able data array.
     *
     * @return array
     */
    public function toSearchableArray(): array
    {
        return [
            'id' => (string) $this->mal_id,
            'mal_id' => (int) $this->mal_id,
            'start_date' => $this->convertToTimestamp($this->published['from']),
            'end_date' => $this->convertToTimestamp($this->published['to']),
            'title' => $this->title,
            'title_transformed' => $this->simplifyStringForSearch($this->title),
            'title_english' => $this->title_english ?? "",
            'title_english_transformed' => $this->simplifyStringForSearch($this->title_english),
            'title_japanese' => $this->title_japanese,
            'title_japanese_transformed' => $this->simplifyStringForSearch($this->title_japanese),
            'title_synonyms' => collect($this->titles ?? [])
                                    ->filter(fn($v, $k) => !in_array($v["type"], ["Default", "English", "Japanese"]))
                                    ->pluck("title")
                                    ->values()
                                    ->all(),
            'type' => $this->type,
            'chapters' => $this->chapters,
            'volumes' => $this->volumes,
            'status' => $this->status,
            'publishing' => $this->publishing,
            'score' => $this->score,
            'rank' => $this->rank,
            'popularity' => $this->popularity,
            'members' => $this->members,
            'favorites' => $this->favorites,
            'synopsis' => $this->synopsis,
            'approved' => $this->approved ?? false,
            'magazines' => $this->getMalIdsOfField($this->magazines),
            'genres' => $this->getMalIdsOfField($this->genres),
            'explicit_genres' => $this->getMalIdsOfField($this->explicit_genres)
        ];
    }

    public function getCollectionSchema(): array
    {
        return [
            'name' => $this->searchableAs(),
            'fields' => [
                [
                    'name' => '.*',
                    'type' => 'auto',
                ],
                [
                    'name' => 'title',
                    'type' => 'string',
                    'optional' => false,
                    'infix' => true,
                    'sort' => true
                ],
                [
                    'name' => 'title_transformed',
                    'type' => 'string',
                    'optional' => false,
                    'infix' => true,
                    'sort' => true
                ],
                [
                    'name' => 'title_japanese',
                    'type' => 'string',
                    'optional' => true,
                    'locale' => 'jp',
                    'infix' => true,
                    'sort' => false
                ],
                [
                    'name' => 'title_japanese_transformed',
                    'type' => 'string',
                    'optional' => true,
                    'locale' => 'jp',
                    'infix' => true,
                    'sort' => false
                ],
                [
                    'name' => 'title_english',
                    'type' => 'string',
                    'optional' => true,
                    'infix' => true,
                    'sort' => true
                ],
                [
                    'name' => 'title_english_transformed',
                    'type' => 'string',
                    'optional' => true,
                    'infix' => true,
                    'sort' => true
                ],
                [
                    'name' => 'title_synonyms',
                    'type' => 'string[]',
                    'optional' => true,
                    'infix' => true,
                    'sort' => false
                ]
            ]
        ];
    }

    /** @noinspection PhpUnused */
    public function getThemesAttribute()
    {
        $result = [];
        if (array_key_exists("themes", $this->attributes)) {
            $result = $this->attributes["themes"];
        }

        return $result;
    }

    public function typesenseQueryBy(): array
    {
        return [
            'title',
            'title_transformed',
            'title_english',
            'title_english_transformed',
            'title_japanese',
            'title_japanese_transformed',
            'title_synonyms',
        ];
    }

    public function getTypeSenseQueryByWeights(): string|null
    {
        return "2,2,1,1,3,3,1";
    }

    /**
     * Returns which fields the search index should sort on when searching
     * @return array|null
     */
    public function getSearchIndexSortBy(): array|null
    {
        return [
            [
                "field" => "_text_match(buckets:".text_match_buckets().")",
                "direction" => "desc"
            ],
            [
                "field" => "popularity",
                "direction" => "asc"
            ],
            [
                "field" => "rank",
                "direction" => "asc"
            ]
        ];
    }

    protected static function newFactory()
    {
        return App::make(MangaFactory::class);
    }
}



================================================
FILE: app/Person.php
================================================
<?php

namespace App;

use App\Concerns\FilteredByLetter;
use Jikan\Jikan;
use Jikan\Request\Person\PersonRequest;
use function Symfony\Component\Translation\t;
use Illuminate\Database\Eloquent\Factories\HasFactory;

class Person extends JikanApiSearchableModel
{
    use HasFactory, FilteredByLetter;
    protected array $filters = ["order_by", "sort"];

    /**
     * The attributes that are mass assignable.
     *
     * @var array
     */
    protected $fillable = [
        'mal_id', 'url', 'images', 'website_url', 'name', 'given_name', 'family_name',
        'alternative_names', 'birthday', 'member_favorites', 'about', 'voice_acting_roles',
        'anime_staff_positions', 'published_manga',
        'createdAt', 'modifiedAt'
    ];

    /**
     * The accessors to append to the model's array form.
     *
     * @var array
     */
    protected $appends = ['images', 'favorites'];

    /**
     * The table associated with the model.
     *
     * @var string
     */
    protected $table = 'people';

    /**
     * The attributes excluded from the model's JSON form.
     *
     * @var array
     */
    protected $hidden = [
        '_id', 'member_favorites'
    ];

    public function __construct(array $attributes = [])
    {
        parent::__construct($attributes);
        $this->displayNameFieldName = "name";
    }

    /** @noinspection PhpUnused */
    public function getFavoritesAttribute()
    {
        return $this->attributes['member_favorites'];
    }

    /** @noinspection PhpUnused */
    public function getImagesAttribute()
    {
        return $this->attributes['images'];
    }

    public static function scrape(int $id)
    {
        $data = app('JikanParser')->getPerson(new PersonRequest($id));
        return json_decode(
            app('SerializerV4')
                ->serialize($data, 'json'),
            true
        );
    }

    /**
     * Converts the model to an index-able data array.
     *
     * @return array
     */
    public function toSearchableArray(): array
    {
        return [
            'id' => (string) $this->mal_id,
            'mal_id' => (int) $this->mal_id,
            'name' => $this->name,
            'given_name' => $this->given_name,
            'family_name' => $this->family_name,
            'alternate_names' => $this->alternate_names,
            'member_favorites' => $this->member_favorites,
            'birthday' => $this->convertToTimestamp($this->birthday)
        ];
    }

    public function typesenseQueryBy(): array
    {
        return [
            "name",
            "given_name",
            "family_name",
            "alternate_names"
        ];
    }

    public function getTitleAttributeName(): string
    {
        return 'name';
    }
}



================================================
FILE: app/Producers.php
================================================
<?php

namespace App;

use App\Concerns\FilteredByLetter;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Jikan\Request\Producer\ProducerRequest;

class Producers extends JikanApiSearchableModel
{
    use FilteredByLetter, HasFactory;
    protected array $filters = ["order_by", "sort", "letter"];

    /**
     * The attributes that are mass assignable.
     *
     * @var array
     */
    protected $fillable = [
        'mal_id', 'url', 'images', 'titles', 'established', 'favorites', 'about', 'external', 'count',
        'createdAt', 'modifiedAt'
    ];

    /**
     * The table associated with the model.
     *
     * @var string
     */
    protected $table = 'producers';

    /**
     * The attributes excluded from the model's JSON form.
     *
     * @var array
     */
    protected $hidden = [
        '_id', 'request_hash', 'expiresAt'
    ];

    public function __construct(array $attributes = [])
    {
        parent::__construct($attributes);
        $this->displayNameFieldName = "titles.0.title";
    }

    public static function scrape(int $id)
    {
        $data = app('JikanParser')->getProducer(new ProducerRequest($id));

        $data = json_decode(
            app('SerializerV4')
                ->serialize($data, 'json'),
            true
        );
        unset($data['results'], $data['has_next_page'], $data['last_visible_page']);

        return $data;
    }

    public function toSearchableArray(): array
    {
        $titles = !is_null($this->titles) ? collect($this->titles)->map(fn ($x) => $x["title"])->toArray() : [''];

        return [
            'id' => (string) $this->mal_id,
            'mal_id' => (int) $this->mal_id,
            'url' => !is_null($this->url) ? $this->url : '',
            'titles' => implode(', ', $titles),
            'established' => $this->convertToTimestamp($this->established),
            'favorites' => $this->favorites,
            'count' => $this->count
        ];
    }

    public function getCollectionSchema(): array
    {
        return [
            'name' => $this->searchableAs(),
            'fields' => [
                [
                    'name' => '.*',
                    'type' => 'auto',
                ],
                [
                    'name' => 'titles',
                    'type' => 'string',
                    'optional' => false,
                    'infix' => true,
                    'sort' => true
                ],
                [
                    'name' => 'url',
                    'type' => 'string',
                    'optional' => false,
                    'infix' => true,
                    'sort' => true
                ],
            ]
        ];
    }

    public function typesenseQueryBy(): array
    {
        return [
            'url',
            'titles'
        ];
    }

    public function getTitleAttributeName(): string
    {
        return 'titles';
    }
}



================================================
FILE: app/Profile.php
================================================
<?php

namespace App;

use App\Concerns\FilteredByLetter;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Jikan\Request\User\UserProfileRequest;

class Profile extends JikanApiSearchableModel
{
    use FilteredByLetter, HasFactory;
    protected array $filters = [];

    /**
     * The attributes that are mass assignable.
     *
     * @var array
     */
    protected $fillable = [
        'mal_id', 'username', 'url', 'images', 'last_online', 'gender', 'birthday', 'location',
        'joined', 'anime_stats', 'manga_stats', 'favorites', 'about',
        'createdAt', 'modifiedAt', 'internal_username'
    ];

    /**
     * The table associated with the model.
     *
     * @var string
     */
    protected $table = 'users';

    /**
     * The attributes excluded from the model's JSON form.
     *
     * @var array
     */
    protected $hidden = [
        '_id',
    ];

    public function __construct(array $attributes = [])
    {
        parent::__construct($attributes);
        $this->displayNameFieldName = "username";
    }

    public static function scrape(string $username)
    {
        $data = app('JikanParser')->getUserProfile(new UserProfileRequest($username));

        return json_decode(
            app('SerializerV4')
                ->serialize($data, 'json'),
            true
        );
    }

    /**
     * Converts the model to an index-able data array.
     *
     * @return array
     */
    public function toSearchableArray(): array
    {
        return [
            'id' => (string) $this->mal_id,
            'mal_id' => (int) $this->mal_id,
            'username' => $this->username
        ];
    }

    public function typesenseQueryBy(): array
    {
        return [
            "username"
        ];
    }

    public function getTitleAttributeName(): string
    {
        return "username";
    }
}



================================================
FILE: app/SearchMetric.php
================================================
<?php
namespace App;
use MongoDB\BSON\ObjectId;
use Laravel\Scout\Builder;

class SearchMetric extends JikanApiSearchableModel
{
    protected $table = 'search_metrics';

    protected $appends = ['hits'];

    protected $fillable = ["search_term", "request_count", "hits", "hits_count", "index_name"];

    protected $hidden = ["_id"];

    public function searchableAs(): string
    {
        return "jikan_search_metrics";
    }

    public function toSearchableArray()
    {
        return [
            "id" => $this->_id,
            "search_term" => $this->search_term,
            "request_count" => $this->request_count,
            "hits" => $this->hits,
            "hits_count" => $this->hits_count,
            "index_name" => $this->index_name
        ];
    }

    public function getCollectionSchema(): array
    {
        return [
            "name" => $this->searchableAs(),
            "fields" => [
                [
                    "name" => "id",
                    "type" => "string",
                    "optional" => false
                ],
                [
                    "name" => "search_term",
                    "type" => "string",
                    "optional" => false,
                    "sort" => false,
                    "infix" => true
                ],
                [
                    "name" => "request_count",
                    "type" => "int64",
                    "sort" => true,
                    "optional" => false,
                ],
                [
                    "name" => "hits",
                    "type" => "int64[]",
                    "sort" => false,
                    "optional" => false,
                ],
                [
                    "name" => "hits_count",
                    "type" => "int64",
                    "sort" => true,
                    "optional" => false,
                ],
                [
                    "name" => "index_name",
                    "type" => "string",
                    "sort" => false,
                    "optional" => false,
                    "facet" => true
                ]
            ]
        ];
    }

    public function getTypeSenseQueryByWeights(): string|null
    {
        return "1";
    }

    public function getScoutKey(): mixed
    {
        return $this->_id;
    }

    public function getScoutKeyName(): mixed
    {
        return '_id';
    }

    public function getKeyType(): string
    {
        return 'string';
    }

    public function typesenseQueryBy(): array
    {
        return ["search_term"];
    }

    public function queryScoutModelsByIds(Builder $builder, array $ids): \Laravel\Scout\Builder|\Illuminate\Database\Eloquent\Builder
    {
        $query = static::usesSoftDelete()
            ? $this->withTrashed() : $this->newQuery();

        if ($builder->queryCallback) {
            call_user_func($builder->queryCallback, $query);
        }

        $whereIn = in_array($this->getKeyType(), ['int', 'integer']) ?
            'whereIntegerInRaw' :
            'whereIn';

        return $query->{$whereIn}(
            $this->getScoutKeyName(), array_map(fn ($x) => new ObjectId($x), $ids)
        );
    }
}



================================================
FILE: app/User.php
================================================
<?php

namespace App;

use Illuminate\Auth\Authenticatable;
use Laravel\Lumen\Auth\Authorizable;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Contracts\Auth\Authenticatable as AuthenticatableContract;
use Illuminate\Contracts\Auth\Access\Authorizable as AuthorizableContract;

class User extends Model implements AuthenticatableContract, AuthorizableContract
{
    use Authenticatable, Authorizable;

    /**
     * The attributes that are mass assignable.
     *
     * @var array
     */
    protected $fillable = [
        'name', 'email',
    ];

    /**
     * The attributes excluded from the model's JSON form.
     *
     * @var array
     */
    protected $hidden = [
        'password',
    ];
}



================================================
FILE: app/Casts/ContextualBooleanCast.php
================================================
<?php

namespace App\Casts;

use Spatie\LaravelData\Casts\Cast;
use Spatie\LaravelData\Support\DataProperty;

/**
 * This class ensures that "?sfw" and "?kids" boolean type query string parameters in the url would be interpreted as "true"
 */
final class ContextualBooleanCast implements Cast
{

    public function cast(DataProperty $property, mixed $value, array $context): mixed
    {
        $propertyName = $property->name;

        if (array_key_exists($propertyName, $context) && $context[$propertyName] === "")
        {
            return true;
        }

        return $value;
    }
}



================================================
FILE: app/Casts/EnumCast.php
================================================
<?php

namespace App\Casts;

use BackedEnum;
use Spatie\LaravelData\Casts\Cast;
use Spatie\LaravelData\Casts\Uncastable;
use Spatie\LaravelData\Exceptions\CannotCastEnum;
use Spatie\LaravelData\Support\DataProperty;
use Throwable;

final class EnumCast implements Cast
{
    public function __construct(
        protected ?string $type = null
    ) {
    }

    /**
     * @throws CannotCastEnum
     */
    public function cast(DataProperty $property, mixed $value, array $context): mixed
    {
        $type = $this->type ?? $property->type->findAcceptedTypeForBaseType(BackedEnum::class);

        if ($type === null) {
            return Uncastable::create();
        }

        try {
            /** @noinspection PhpUndefinedMethodInspection */
            return $type::from($value);
        } catch (Throwable $e) {
            throw CannotCastEnum::create($type, $value);
        }
    }
}



================================================
FILE: app/Concerns/FilteredByLetter.php
================================================
<?php

namespace App\Concerns;

trait FilteredByLetter
{
    /**
     * The name of the field which contains the display name of the record.
     * @var ?string
     */
    protected ?string $displayNameFieldName;

    /** @noinspection PhpUnused */
    public function filterByLetter(\Laravel\Scout\Builder|\Illuminate\Database\Eloquent\Builder $query, string $value): \Laravel\Scout\Builder|\Illuminate\Database\Eloquent\Builder
    {
        if (empty($this->displayNameFieldName)) {
            return $query;
        }
        return $query->where($this->displayNameFieldName, "like", "{$value}%");
    }

    public function getDisplayNameFieldName(): string
    {
        return $this->displayNameFieldName;
    }

    public function displayNameFieldName(string $name): self
    {
        $this->displayNameFieldName = $name;

        return $this;
    }
}



================================================
FILE: app/Concerns/HasRequestFingerprint.php
================================================
<?php

namespace App\Concerns;

use App\Http\HttpHelper;
use Illuminate\Http\Request;
use Spatie\LaravelData\Resolvers\DataFromSomethingResolver;

/**
 * Helper trait for data transfer objects
 *
 * Ref: https://spatie.be/docs/laravel-data/v2/as-a-data-transfer-object/request-to-data-object#content-mapping-a-request-onto-a-data-object
 */
trait HasRequestFingerprint
{
    protected ?string $fingerprint = null;

    public static function fromRequest(Request $request): ?static
    {
        $result = app(DataFromSomethingResolver::class)
                    ->withoutMagicalCreation()->execute(static::class, $request);
        $result->fingerprint = HttpHelper::resolveRequestFingerprint($request);
        return $result;
    }

    public function getFingerPrint(): string
    {
        return $this->fingerprint;
    }
}



================================================
FILE: app/Concerns/MediaFilters.php
================================================
<?php

namespace App\Concerns;

use Spatie\Enum\Enum;

trait MediaFilters
{
    public function filterByMaxScore(\Laravel\Scout\Builder|\Illuminate\Database\Eloquent\Builder $query, mixed $value): \Laravel\Scout\Builder|\Illuminate\Database\Eloquent\Builder
    {
        // if the client specifies the "max" possible value, ignore it, in that case they want everything included
        // https://github.com/jikan-me/jikan-rest/issues/309
        if (floatval($value) == 10) {
            return $query;
        }
        return $query->where("score", "<=", floatval($value));
    }

    public function filterByMinScore(\Laravel\Scout\Builder|\Illuminate\Database\Eloquent\Builder $query, mixed $value): \Laravel\Scout\Builder|\Illuminate\Database\Eloquent\Builder
    {
        // if the client specifies the "max" possible value, ignore it, in that case they want everything included
        // https://github.com/jikan-me/jikan-rest/issues/309
        if (floatval($value) == 0) {
            return $query;
        }
        return $query->where("score", ">=", floatval($value));
    }

    public function filterByScore(\Laravel\Scout\Builder|\Illuminate\Database\Eloquent\Builder $query, mixed $value): \Laravel\Scout\Builder|\Illuminate\Database\Eloquent\Builder
    {
        return $query->where("score", floatval($value));
    }

    public function filterByStatus(\Laravel\Scout\Builder|\Illuminate\Database\Eloquent\Builder $query, Enum $value): \Laravel\Scout\Builder|\Illuminate\Database\Eloquent\Builder
    {
        return $query->where("status", $value->label);
    }

    public function filterByGenres(\Laravel\Scout\Builder|\Illuminate\Database\Eloquent\Builder $query, mixed $value): \Laravel\Scout\Builder|\Illuminate\Database\Eloquent\Builder
    {
        if (!is_string($value) || empty($value)) {
            return $query;
        }
        $genres = explode(',', $value);

        foreach ($genres as $genreItem) {
            $genre = (int) $genreItem;
            // here we need a nested where clause
            // this logically looks like: (genre = x OR demographic = x OR theme = x)
            // so: (any other where clauses from before) AND (genre = x OR demographic = x OR theme = x)
            $query = $query->where(function ($q) use ($genre) {
                return $q->where('genres.mal_id', $genre)
                    ->orWhere('demographics.mal_id', $genre)
                    ->orWhere('themes.mal_id', $genre)
                    ->orWhere('explicit_genres.mal_id', $genre);
            });
        }

        return $query;
    }

    public function filterByGenresExclude(\Laravel\Scout\Builder|\Illuminate\Database\Eloquent\Builder $query, mixed $value): \Laravel\Scout\Builder|\Illuminate\Database\Eloquent\Builder
    {
        if (!is_string($value) || empty($value)) {
            return $query;
        }
        $genres = explode(',', $value);

        foreach ($genres as $genreItem) {
            $genre = (int) $genreItem;
            $query = $query
                ->where('genres.mal_id', '!=', $genre)
                ->where('demographics.mal_id', '!=', $genre)
                ->where('themes.mal_id', '!=', $genre)
                ->where('explicit_genres.mal_id', '!=', $genre);
        }

        return $query;
    }

    public function filterBySfw(\Laravel\Scout\Builder|\Illuminate\Database\Eloquent\Builder $query, bool $value): \Laravel\Scout\Builder|\Illuminate\Database\Eloquent\Builder
    {
        // call scopeExceptItemsWithAdultRating method via $query->exceptItemsWithAdultRating()
        /** @noinspection PhpUndefinedMethodInspection */
        return $value ? $query->exceptItemsWithAdultRating() : $query;
    }

    public function filterByUnapproved(\Laravel\Scout\Builder|\Illuminate\Database\Eloquent\Builder $query, ?bool $value): \Laravel\Scout\Builder|\Illuminate\Database\Eloquent\Builder
    {
        return !$value ? $query->where("approved", true) : $query;
    }

    public function filterByKids(\Laravel\Scout\Builder|\Illuminate\Database\Eloquent\Builder $query, ?bool $value): \Laravel\Scout\Builder|\Illuminate\Database\Eloquent\Builder
    {
        if (is_null($value)) {
            return $query;
        }
        // call scopeOnlyKidsItems method via $query->onlyKidsItems()
        /** @noinspection PhpUndefinedMethodInspection */
        return $value ? $query->onlyKidsItems() : $query->exceptKidsItems();
    }
}



================================================
FILE: app/Concerns/ResolvesPaginatorParams.php
================================================
<?php

namespace App\Concerns;

use Illuminate\Support\Facades\App;

trait ResolvesPaginatorParams
{
    private function getPaginatorParams(?int $limit = null, ?int $page = null): array
    {
        $default_max_results_per_page = max_results_per_page();
        $limit = $limit ?? $default_max_results_per_page;
        $page = $page ?? 1;

        return compact("limit", "page");
    }
}



================================================
FILE: app/Concerns/ScraperCacheTtl.php
================================================
<?php

namespace App\Concerns;

use Illuminate\Support\Env;

trait ScraperCacheTtl
{
    public static function cacheTtl(): int
    {
        return (int) Env::get('CACHE_DEFAULT_EXPIRE');
    }
}



================================================
FILE: app/Console/Kernel.php
================================================
<?php

namespace App\Console;

use App\Console\Commands\CacheRemove;
use App\Console\Commands\Indexer;
use Illuminate\Console\Scheduling\Schedule;
use Laravel\Lumen\Console\Kernel as ConsoleKernel;

class Kernel extends ConsoleKernel
{
    /**
     * The Artisan commands provided by your application.
     *
     * @var array
     */
    protected $commands = [
        CacheRemove::class,
        Indexer\CommonIndexer::class,
        Indexer\AnimeScheduleIndexer::class,
        Indexer\CurrentSeasonIndexer::class,
        Indexer\AnimeIndexer::class,
        Indexer\MangaIndexer::class,
        Indexer\GenreIndexer::class,
        Indexer\ProducersIndexer::class,
        Indexer\AnimeSweepIndexer::class,
        Indexer\MangaSweepIndexer::class,
        Indexer\IncrementalIndexer::class
    ];

    /**
     * Define the application's command schedule.
     *
     * @param  \Illuminate\Console\Scheduling\Schedule  $schedule
     * @return void
     */
    protected function schedule(Schedule $schedule)
    {
        // Update Scheduled Anime and current season data daily
        // since they're airing, they're more prone to
        // have their information updated
        $schedule->command('indexer:anime-schedule')
            ->daily();

        $schedule->command('indexer:anime-current-season')
            ->daily();

        // Update common indexes daily
        $schedule->command('indexer:common')
            ->daily();

        $schedule->command('indexer:genres')
            ->daily();

        $schedule->command('indexer:producers')
            ->daily();

        $schedule->command('indexer:anime-sweep')
            ->daily();

        $schedule->command('indexer:manga-sweep')
            ->daily();

    }
}



================================================
FILE: app/Console/Commands/CacheRemove.php
================================================
<?php

namespace App\Console\Commands;

use Illuminate\Console\Command;
use Illuminate\Support\Facades\Cache;

class CacheRemove extends Command
{
    /**
     * The name and signature of the console command.
     *
     * @var string
     */
    protected $signature = 'cache:remove {key}';

    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = 'Remove cache by their hash key';

    /**
     * Create a new command instance.
     *
     * @return void
     */
    public function __construct()
    {
        parent::__construct();
    }

    /**
     * Execute the console command.
     *
     * @return mixed
     */
    public function handle()
    {
        $fingerprint = $this->argument('key');

        if (!Cache::has($fingerprint)) {
            $this->error("Cache does not exist");
        }

        if (Cache::forget($fingerprint)) {
            Cache::forget("ttl:".$fingerprint);
            $this->info('Cache removed');
        }
    }
}



================================================
FILE: app/Console/Commands/.gitkeep
================================================
[Empty file]


================================================
FILE: app/Console/Commands/Indexer/AnimeIndexer.php
================================================
<?php

namespace App\Console\Commands\Indexer;

use App\Exceptions\Console\FileNotFoundException;
use Illuminate\Console\Command;
use Illuminate\Support\Facades\Storage;


/**
 * Class AnimeIndexer
 * @package App\Console\Commands\Indexer
 */
class AnimeIndexer extends Command
{
    /**
     * The name and signature of the console command.
     *`
     * @var string
     */
    protected $signature = 'indexer:anime
                            {--failed : Run only entries that failed to index last time}
                            {--resume : Resume from the last position}
                            {--reverse : Start from the end of the array}
                            {--index=0 : Start from a specific index}
                            {--delay=3 : Set a delay between requests}';

    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = 'Index all anime';

    /**
     * @var array
     */
    private array $ids;

    /**
     * Create a new command instance.
     *
     * @return void
     */
    public function __construct()
    {
        parent::__construct();
        $this->ids = [];
    }

    /**
     * Execute the console command.
     *
     * @return void
     * @throws FileNotFoundException
     */
    public function handle()
    {

        $failed = $this->option('failed') ?? false;
        $resume = $this->option('resume') ?? false;
        $reverse = $this->option('reverse') ?? false;
        $delay = $this->option('delay') ?? 3;
        $index = $this->option('index') ?? 0;

        $index = (int)$index;
        $delay = (int)$delay;

        $this->info("Info: AnimeIndexer uses purarue/mal-id-cache fetch available MAL IDs and updates/indexes them\n\n");

        if ($failed && Storage::exists('indexer/indexer_anime.failed')) {
            $this->ids = $this->loadFailedMalIds();
        }

        if (!$failed) {
            $this->ids = $this->fetchMalIds();
        }

        // start from the end
        if ($reverse) {
            $this->ids = array_reverse($this->ids);
        }

        // Resume
        if ($resume && Storage::exists('indexer/indexer_anime.save')) {
            $index = (int)Storage::get('indexer/indexer_anime.save');

            $this->info("Resuming from index: {$index}");
        }

        // check if index even exists
        if ($index > 0 && !isset($this->ids[$index])) {
            $index = 0;
            $this->warn('Invalid index; set back to 0');
        }

        // initialize and index
        Storage::put('indexer/indexer_anime.save', 0);

        echo "Loading MAL IDs\n";
        $count = count($this->ids);
        $failedIds = [];
        $success = [];

        echo "{$count} entries available\n";
        for ($i = $index; $i <= ($count - 1); $i++) {
            $id = $this->ids[$i];

            $url = env('APP_URL') . "/v4/anime/{$id}";

            echo "Indexing/Updating " . ($i + 1) . "/{$count} {$url} [MAL ID: {$id}] \n";

            try {
                $response = json_decode(file_get_contents($url), true);

                if (isset($response['error']) && $response['status'] != 404) {
                    echo "[SKIPPED] Failed to fetch {$url} - {$response['error']}\n";
                    $failedIds[] = $id;
                    Storage::put('indexer/indexer_anime.failed', json_encode($failedIds));
                }

                sleep($delay);
            } catch (\Exception $e) {
                echo "[SKIPPED] Failed to fetch {$url}\n";
                $failedIds[] = $id;
                Storage::put('indexer/indexer_anime.failed', json_encode($failedIds));
            }

            $success[] = $id;
            Storage::put('indexer/indexer_anime.save', $i);
        }

        Storage::delete('indexer/indexer_anime.save');

        echo "---------\nIndexing complete\n";
        echo count($success) . " entries indexed or updated\n";
        echo count($failedIds) . " entries failed to index or update. Re-run with --failed to requeue failed entries only\n";
    }

    /**
     * @return array
     * @url https://github.com/purarue/mal-id-cache
     */
    private function fetchMalIds() : array
    {
        $this->info("Fetching MAL ID Cache https://raw.githubusercontent.com/purarue/mal-id-cache/master/cache/anime_cache.json...\n");

        $ids = json_decode(
            file_get_contents('https://raw.githubusercontent.com/purarue/mal-id-cache/master/cache/anime_cache.json'),
            true
        );

        $ids = array_merge($ids['sfw'], $ids['nsfw']);
        sort($ids, SORT_NUMERIC);
        Storage::put('indexer/anime_mal_id.json', json_encode($ids));

        return json_decode(Storage::get('indexer/anime_mal_id.json'));
    }

    /**
     * @return array
     * @throws FileNotFoundException
     */
    private function loadFailedMalIds() : array
    {
        if (!Storage::exists('indexer/indexer_anime.failed')) {
            throw new FileNotFoundException('"indexer/indexer_anime.failed" does not exist');
        }

        return json_decode(Storage::get('indexer/indexer_anime.failed'));
    }

}



================================================
FILE: app/Console/Commands/Indexer/AnimeScheduleIndexer.php
================================================
<?php

namespace App\Console\Commands\Indexer;

use App\Http\HttpHelper;
use Illuminate\Console\Command;
use Illuminate\Support\Facades\DB;
use Jikan\Request\Schedule\ScheduleRequest;


class AnimeScheduleIndexer extends Command
{
    /**
     * The name and signature of the console command.
     *`
     * @var string
     */
    protected $signature = 'indexer:anime-schedule';

    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = 'Index anime schedule';

    /**
     * Create a new command instance.
     *
     * @return void
     */
    public function __construct()
    {
        parent::__construct();
    }

    /**
     * Execute the console command.
     *
     */
    public function handle()
    {

        echo "Note: AnimeScheduleIndexer makes sure anime currently airing are up to date so the schedules endpoint returns fresh information\n\n";

        /**
         * Schedule
         */
        echo "Fetching Schedule...\n";
        $results = \json_decode(
            app('SerializerV4')->serialize(
                app('JikanParser')
                    ->getSchedule(new ScheduleRequest()),
                'json'
            ),
            true
        );

        if (HttpHelper::hasError($results)) {
            echo "FAILED: {$results->original['error']}\n";
            return;
        }

        $anime = [];

        foreach ($results as $day) {
            foreach ($day as $entry) {
                $anime[] = $entry;
            }
        }

        $i = 1;
        $itemCount = count($anime);
        echo "Anime currently airing: {$itemCount} entries\n";
        foreach ($anime as $entry) {
            $url = env('APP_URL') . "/v4/anime/{$entry['mal_id']}";

            file_get_contents($url);
            sleep(3); // prevent rate-limit

            echo "Updating {$i}/{$itemCount} \r";
            $i++;
        }

        echo str_pad("Indexing complete", 10).PHP_EOL;
    }
}



================================================
FILE: app/Console/Commands/Indexer/AnimeSweepIndexer.php
================================================
<?php

namespace App\Console\Commands\Indexer;

use App\Exceptions\Console\CommandAlreadyRunningException;
use App\Exceptions\Console\FileNotFoundException;
use Illuminate\Console\Command;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Storage;

/**
 * Class AnimeSweepIndexer
 *
 * @package App\Console\Commands\Indexer
 */
class AnimeSweepIndexer extends Command
{
    /**
     * The name and signature of the console command.
     *`
     *
     * @var string
     */
    protected $signature = 'indexer:anime-sweep';

    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = 'Delete all removed anime';

    /**
     * Create a new command instance.
     *
     * @return void
     */
    public function __construct()
    {
        parent::__construct();
    }

    /**
     * Execute the console command.
     *
     * @return void
     * @throws FileNotFoundException
     */
    public function handle()
    {
        $this->info("Info: Delete removed MAL IDs\n\n");

        echo "Loading MAL IDs\n";
        $malIds = array_fill_keys($this->fetchMalIds(), null);

        echo "Loading MAL IDs from local DB\n";
        $results = DB::table('anime')->select('mal_id', '_id')->get();

        echo "Compare MAL IDs\n";
        $remove = [];

        foreach ($results as $result) {
            if (!array_key_exists($result['mal_id'], $malIds)) {
                echo "Removing https://myanimelist.net/anime/".$result['mal_id']."\n";
                $remove[] = $result['_id'];
            }
        }

        echo "\n\n".count($remove);

        echo "Delete removed MAL IDs\n";
        DB::table('anime')->whereIn('_id', $remove)->delete();
    }

    /**
     * @return array
     * @url https://github.com/purarue/mal-id-cache
     */
    private function fetchMalIds(): array
    {
        $this->info("Fetching MAL ID Cache https://raw.githubusercontent.com/purarue/mal-id-cache/master/cache/anime_cache.json...\n");

        $ids = json_decode(
            file_get_contents('https://raw.githubusercontent.com/purarue/mal-id-cache/master/cache/anime_cache.json'),
            true
        );

        $ids = array_merge($ids['sfw'], $ids['nsfw']);
        Storage::put('indexer/anime_mal_id_sweep.json', json_encode($ids));

        return json_decode(Storage::get('indexer/anime_mal_id_sweep.json'));
    }
}



================================================
FILE: app/Console/Commands/Indexer/CommonIndexer.php
================================================
<?php

namespace App\Console\Commands\Indexer;

use App\Http\HttpHelper;
use App\Http\HttpResponse;
use Illuminate\Console\Command;
use Illuminate\Support\Facades\DB;
use Jikan\Request\Genre\AnimeGenresRequest;
use Jikan\Request\Genre\MangaGenresRequest;
use Jikan\Request\Magazine\MagazinesRequest;
use Jikan\Request\Producer\ProducersRequest;
use Jikan\Request\SeasonList\SeasonListRequest;

class CommonIndexer extends Command
{
    /**
     * The name and signature of the console command.
     *`
     * @var string
     */
    protected $signature = 'indexer:common';

    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = 'Index common endpoint metadata: Producers, Magazines';

    /**
     * Create a new command instance.
     *
     * @return void
     */
    public function __construct()
    {
        parent::__construct();
    }

    /**
     * Execute the console command.
     *
     * @return mixed
     */
    public function handle()
    {

        echo "Note: If an entry already exists, it will be updated instead.\n\n";

        /**
         * Magazines
         */
        echo "Indexing Magazines...\n";
        $results = \json_decode(
            app('SerializerV4')->serialize(
                app('JikanParser')
                    ->getMagazines(new MagazinesRequest()),
                'json'
            ),
            true
        )['magazines'];

        if (HttpHelper::hasError($results)) {
            echo "FAILED: {$results->original['error']}\n";
            return;
        }

        $itemCount = count($results);
        echo "Parsed {$itemCount} magazines\n";
        foreach ($results as $i => $item) {
            $result = DB::table('magazines')
                ->updateOrInsert(
                    [
                        'mal_id' => $item['mal_id']
                    ],
                    [
                        'mal_id' => $item['mal_id'],
                        'name' => $item['name'],
                        'url' => $item['url'],
                        'count' => $item['count']
                    ]
                );
            echo "Indexing {$i}/{$itemCount} \r";
        }

        echo str_pad("Indexing complete", 10).PHP_EOL;
    }
}



================================================
FILE: app/Console/Commands/Indexer/CurrentSeasonIndexer.php
================================================
<?php

namespace App\Console\Commands\Indexer;

use App\Http\HttpHelper;
use Illuminate\Console\Command;
use Illuminate\Support\Facades\DB;
use Jikan\Request\Schedule\ScheduleRequest;
use Jikan\Request\Seasonal\SeasonalRequest;


class CurrentSeasonIndexer extends Command
{
    /**
     * The name and signature of the console command.
     *`
     * @var string
     */
    protected $signature = 'indexer:anime-current-season';

    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = 'Index anime in current season';

    /**
     * Create a new command instance.
     *
     * @return void
     */
    public function __construct()
    {
        parent::__construct();
    }

    /**
     * Execute the console command.
     *
     * @return mixed
     */
    public function handle()
    {

        echo "Note: CurrentSeasonIndexer makes sure anime in current season are upto update so the /seasons/now endpoint returns fresh information\n\n";

        /**
         * Current Season
         */
        echo "Fetching Current Season...\n";
        $results = \json_decode(
            app('SerializerV4')->serialize(
                app('JikanParser')
                    ->getSeasonal(new SeasonalRequest()),
                'json'
            ),
            true
        );

        if (HttpHelper::hasError($results)) {
            echo "FAILED: {$results->original['error']}\n";
            return;
        }

        $anime = $results['anime'];
        $itemCount = count($anime);
        echo "Anime in current season: {$itemCount} entries\n";
        foreach ($anime as $i => $entry) {
            $url = env('APP_URL') . "/v4/anime/{$entry['mal_id']}";

            file_get_contents($url);
            sleep(3); // prevent rate-limit

            echo "Updating {$i}/{$itemCount} {$url} [{$entry['mal_id']} - {$entry['title']}] \n";
            try {
            } catch (\Exception $e) {
                echo "[SKIPPED] Failed to fetch {$url}\n";
            }
        }

        echo str_pad("Indexing complete", 100).PHP_EOL;
    }
}



================================================
FILE: app/Console/Commands/Indexer/GenreIndexer.php
================================================
<?php

namespace App\Console\Commands\Indexer;

use App\Http\HttpHelper;
use Illuminate\Console\Command;
use Illuminate\Support\Facades\DB;
use Jikan\Request\Genre\AnimeGenresRequest;
use Jikan\Request\Genre\MangaGenresRequest;

class GenreIndexer extends Command
{
    /**
     * The name and signature of the console command.
     *`
     * @var string
     */
    protected $signature = 'indexer:genres';

    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = 'Index Anime & Manga Genres';

    /**
     * Create a new command instance.
     *
     * @return void
     */
    public function __construct()
    {
        parent::__construct();
    }

    /**
     * Execute the console command.
     *
     * @return mixed
     */
    public function handle()
    {

        echo "Note: If an entry already exists, it will be updated instead.\n\n";

        /**
         * Anime Genres
         */
        echo "Indexing Anime Genres...\n";
        $results = \json_decode(
            app('SerializerV4')->serialize(
                app('JikanParser')
                    ->getAnimeGenres(new AnimeGenresRequest()),
                'json'
            ),
            true
        );

        if (HttpHelper::hasError($results)) {
            echo "FAILED: {$results->original['error']}\n";
            return;
        }

        $itemCount = count($results['genres']);
        echo "Parsed {$itemCount} anime genres\n";
        foreach ($results['genres'] as $i => $item) {
            $result = DB::table('genres_anime')
                ->updateOrInsert(
                    [
                        'mal_id' => $item['mal_id']
                    ],
                    [
                        'mal_id' => $item['mal_id'],
                        'name' => $item['name'],
                        'url' => $item['url'],
                        'count' => $item['count']
                    ]
                );
            echo "Indexing {$i}/{$itemCount} \r";
        }

        $itemCount = count($results['explicit_genres']);
        echo "Parsed {$itemCount} anime explicit_genres\n";
        foreach ($results['explicit_genres'] as $i => $item) {
            $result = DB::table('explicit_genres_anime')
                ->updateOrInsert(
                    [
                        'mal_id' => $item['mal_id']
                    ],
                    [
                        'mal_id' => $item['mal_id'],
                        'name' => $item['name'],
                        'url' => $item['url'],
                        'count' => $item['count']
                    ]
                );
            echo "Indexing {$i}/{$itemCount} \r";
        }

        $itemCount = count($results['themes']);
        echo "Parsed {$itemCount} anime themes\n";
        foreach ($results['themes'] as $i => $item) {
            $result = DB::table('themes_anime')
                ->updateOrInsert(
                    [
                        'mal_id' => $item['mal_id']
                    ],
                    [
                        'mal_id' => $item['mal_id'],
                        'name' => $item['name'],
                        'url' => $item['url'],
                        'count' => $item['count']
                    ]
                );
            echo "Indexing {$i}/{$itemCount} \r";
        }

        $itemCount = count($results['demographics']);
        echo "Parsed {$itemCount} anime demographics\n";
        foreach ($results['demographics'] as $i => $item) {
            $result = DB::table('demographics_anime')
                ->updateOrInsert(
                    [
                        'mal_id' => $item['mal_id']
                    ],
                    [
                        'mal_id' => $item['mal_id'],
                        'name' => $item['name'],
                        'url' => $item['url'],
                        'count' => $item['count']
                    ]
                );
            echo "Indexing {$i}/{$itemCount} \r";
        }

        /**
         * Manga Genres
         */
        echo "Indexing Manga Genres...\n";
        $results = \json_decode(
            app('SerializerV4')->serialize(
                app('JikanParser')
                    ->getMangaGenres(new MangaGenresRequest()),
                'json'
            ),
            true
        );

        if (HttpHelper::hasError($results)) {
            echo "FAILED: {$results->original['error']}\n";
            return;
        }

        $itemCount = count($results['genres']);
        echo "Parsed {$itemCount} manga genres\n";
        foreach ($results['genres'] as $i => $item) {
            $result = DB::table('genres_manga')
                ->updateOrInsert(
                    [
                        'mal_id' => $item['mal_id']
                    ],
                    [
                        'mal_id' => $item['mal_id'],
                        'name' => $item['name'],
                        'url' => $item['url'],
                        'count' => $item['count']
                    ]
                );
            echo "Indexing {$i}/{$itemCount} \r";
        }

        $itemCount = count($results['explicit_genres']);
        echo "Parsed {$itemCount} manga explicit_genres\n";
        foreach ($results['explicit_genres'] as $i => $item) {
            $result = DB::table('explicit_genres_manga')
                ->updateOrInsert(
                    [
                        'mal_id' => $item['mal_id']
                    ],
                    [
                        'mal_id' => $item['mal_id'],
                        'name' => $item['name'],
                        'url' => $item['url'],
                        'count' => $item['count']
                    ]
                );
            echo "Indexing {$i}/{$itemCount} \r";
        }

        $itemCount = count($results['themes']);
        echo "Parsed {$itemCount} manga themes\n";
        foreach ($results['themes'] as $i => $item) {
            $result = DB::table('themes_manga')
                ->updateOrInsert(
                    [
                        'mal_id' => $item['mal_id']
                    ],
                    [
                        'mal_id' => $item['mal_id'],
                        'name' => $item['name'],
                        'url' => $item['url'],
                        'count' => $item['count']
                    ]
                );
            echo "Indexing {$i}/{$itemCount} \r";
        }

        $itemCount = count($results['demographics']);
        echo "Parsed {$itemCount} manga demographics\n";
        foreach ($results['demographics'] as $i => $item) {
            $result = DB::table('demographics_manga')
                ->updateOrInsert(
                    [
                        'mal_id' => $item['mal_id']
                    ],
                    [
                        'mal_id' => $item['mal_id'],
                        'name' => $item['name'],
                        'url' => $item['url'],
                        'count' => $item['count']
                    ]
                );
            echo "Indexing {$i}/{$itemCount} \r";
        }


        echo str_pad("Indexing complete", 10).PHP_EOL;
    }
}



================================================
FILE: app/Console/Commands/Indexer/IncrementalIndexer.php
================================================
<?php

namespace App\Console\Commands\Indexer;

use Illuminate\Console\Command;
use Illuminate\Support\Facades\Storage;
use Illuminate\Support\Facades\Validator;

class IncrementalIndexer extends Command
{
    /**
     * @var bool
     */
    private bool $cancelled = false;

    /**
     * The name and signature of the console command.
     *
     * @var string
     */
    protected $signature = 'indexer:incremental {mediaType*}
    {--delay=3 : Set a delay between requests}
    {--resume : Resume from the last position}
    {--failed : Run only entries that failed to index last time}';

    protected function promptForMissingArgumentsUsing(): array
    {
        return [
            'mediaType' => ['The media type to index.', 'Valid values: anime, manga']
        ];
    }

    private function getExistingIds(string $mediaType): array
    {
        $existingIdsHash = "";
        $existingIdsRaw = "";

        if (Storage::exists("indexer/incremental/$mediaType.json"))
        {
            $existingIdsRaw = Storage::get("indexer/incremental/$mediaType.json");
            $existingIdsHash = sha1($existingIdsRaw);
        }

        return [$existingIdsHash, $existingIdsRaw];
    }

    private function getIdsToFetch(string $mediaType): array
    {
        $idsToFetch = [];
        [$existingIdsHash, $existingIdsRaw] = $this->getExistingIds($mediaType);

        if ($this->cancelled)
        {
            return [];
        }

        $newIdsRaw = file_get_contents("https://raw.githubusercontent.com/purarue/mal-id-cache/master/cache/${mediaType}_cache.json");
        $newIdsHash = sha1($newIdsRaw);

        /** @noinspection PhpConditionAlreadyCheckedInspection */
        if ($this->cancelled)
        {
            return [];
        }

        if ($newIdsHash !== $existingIdsHash)
        {
            $newIds = json_decode($newIdsRaw, true);
            $existingIds = json_decode($existingIdsRaw, true);

            if (is_null($existingIds) || count($existingIds) === 0)
            {
                $idsToFetch = $newIds;
            }
            else
            {
                foreach (["sfw", "nsfw"] as $t)
                {
                    $idsToFetch[$t] = array_diff($existingIds[$t], $newIds[$t]);
                }
            }

            Storage::put("indexer/incremental/$mediaType.json.tmp", $newIdsRaw);
        }

        return $idsToFetch;
    }

    private function getFailedIdsToFetch(string $mediaType): array
    {
        return json_decode(Storage::get("indexer/incremental/{$mediaType}_failed.json"));
    }

    private function fetchIds(string $mediaType, array $idsToFetch, bool $resume): void
    {
        $index = 0;
        $success = [];
        $failedIds = [];
        $idCount = count($idsToFetch);
        if ($resume && Storage::exists("indexer/incremental/{$mediaType}_resume.save"))
        {
            $index = (int)Storage::get("indexer/incremental/{$mediaType}_resume.save");
            $this->info("Resuming from index: $index");
        }

        $ids = array_merge($idsToFetch['sfw'], $idsToFetch['nsfw']);

        if ($index > 0 && !isset($ids[$index]))
        {
            $index = 0;
            $this->warn('Invalid index; set back to 0');
        }

        Storage::put("indexer/incremental/{$mediaType}_resume.save", 0);

        $this->info("$idCount $mediaType entries available");

        for ($i = $index; $i <= ($idCount - 1); $i++)
        {
            if ($this->cancelled)
            {
                return;
            }

            $id = $ids[$index];

            $url = env('APP_URL') . "/v4/$mediaType/$id";
            $this->info("Indexing/Updating " . ($i + 1) . "/$idCount $url [MAL ID: $id]");

            try
            {
                $response = json_decode(file_get_contents($url), true);
                if (!isset($response['error']) || $response['status'] == 404)
                {
                    continue;
                }

                $this->error("[SKIPPED] Failed to fetch $url - {$response['error']}");
            }
            catch (\Exception)
            {
                $this->warn("[SKIPPED] Failed to fetch $url");
                $failedIds[] = $id;
                Storage::put("indexer/incremental/$mediaType.failed", json_encode($failedIds));
            }

            $success[] = $id;
            Storage::put("indexer/incremental/{$mediaType}_resume.save", $index);
        }

        Storage::delete("indexer/incremental/{$mediaType}_resume.save");

        $this->info("--- Indexing of $mediaType is complete.");
        $this->info(count($success) . ' entries indexed or updated.');
        if (count($failedIds) > 0)
        {
            $this->info(count($failedIds) . ' entries failed to index or update. Re-run with --failed to requeue failed entries only.');
        }

        // finalize the latest state
        Storage::move("indexer/incremental/$mediaType.json.tmp", "indexer/incremental/$mediaType.json");
    }

    public function handle(): int
    {
        // validate inputs
        $validator = Validator::make(
            [
                'mediaType' => $this->argument('mediaType'),
                'delay' => $this->option('delay'),
                'resume' => $this->option('resume') ?? false,
                'failed' => $this->option('failed') ?? false
            ],
            [
                'mediaType' => 'required|in:anime,manga',
                'delay' => 'integer|min:1',
                'resume' => 'bool|prohibited_with:failed',
                'failed' => 'bool|prohibited_with:resume'
            ]
        );

        if ($validator->fails()) {
            $this->error($validator->errors()->toJson());
            return 1;
        }

        // we want to handle signals from the OS
        $this->trap([SIGTERM, SIGQUIT, SIGINT], fn () => $this->cancelled = true);

        $resume = $this->option('resume') ?? false;
        $onlyFailed = $this->option('failed') ?? false;

        /**
         * @var $mediaTypes array
         */
        $mediaTypes = $this->argument("mediaType");

        foreach ($mediaTypes as $mediaType)
        {
            $idsToFetch = [];

            // if "--failed" option is specified just run the failed ones
            if ($onlyFailed && Storage::exists("indexer/incremental/{$mediaType}_failed.json"))
            {
                $idsToFetch["sfw"] = $this->getFailedIdsToFetch($mediaType);
            }
            else
            {
                $idsToFetch = $this->getIdsToFetch($mediaType);
            }

            if ($this->cancelled)
            {
                return 127;
            }

            $idCount = count($idsToFetch);
            if ($idCount === 0)
            {
                continue;
            }

            $this->fetchIds($mediaType, $idsToFetch, $resume);
        }

        return 0;
    }
}



================================================
FILE: app/Console/Commands/Indexer/MangaIndexer.php
================================================
<?php

namespace App\Console\Commands\Indexer;

use App\Exceptions\Console\CommandAlreadyRunningException;
use App\Exceptions\Console\FileNotFoundException;
use Illuminate\Console\Command;
use Illuminate\Support\Facades\Storage;


/**
 * Class MangaIndexer
 * @package App\Console\Commands\Indexer
 */
class MangaIndexer extends Command
{
    /**
     * The name and signature of the console command.
     *`
     * @var string
     */
    protected $signature = 'indexer:manga
                            {--failed : Run only entries that failed to index last time}
                            {--resume : Resume from the last position}
                            {--reverse : Start from the end of the array}
                            {--index=0 : Start from a specific index}
                            {--delay=3 : Set a delay between requests}';

    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = 'Index all manga';

    /**
     * @var array
     */
    private array $ids;

    /**
     * Create a new command instance.
     *
     * @return void
     */
    public function __construct()
    {
        parent::__construct();
        $this->ids = [];
    }

    /**
     * Execute the console command.
     *
     * @return void
     * @throws FileNotFoundException
     */
    public function handle()
    {

        $failed = $this->option('failed') ?? false;
        $resume = $this->option('resume') ?? false;
        $reverse = $this->option('reverse') ?? false;
        $delay = $this->option('delay') ?? 3;
        $index = $this->option('index') ?? 0;

        $index = (int)$index;
        $delay = (int)$delay;

        $this->info("Info: MangaIndexer uses purarue/mal-id-cache fetch available MAL IDs and updates/indexes them\n\n");

        if ($failed && Storage::exists('indexer/indexer_manga.failed')) {
            $this->ids = $this->loadFailedMalIds();
        }

        if (!$failed) {
            $this->ids = $this->fetchMalIds();
        }

        // start from the end
        if ($reverse) {
            $this->ids = array_reverse($this->ids);
        }

        // Resume
        if ($resume && Storage::exists('indexer/indexer_manga.save')) {
            $index = (int)Storage::get('indexer/indexer_manga.save');

            $this->info("Resuming from index: {$index}");
        }

        // check if index even exists
        if ($index > 0 && !isset($this->ids[$index])) {
            $index = 0;
            $this->warn('Invalid index; set back to 0');
        }

        // initialize and index
        Storage::put('indexer/indexer_manga.save', 0);

        echo "Loading MAL IDs\n";
        $count = count($this->ids);
        $failedIds = [];
        $success = [];

        echo "{$count} entries available\n";
        for ($i = $index; $i <= ($count - 1); $i++) {
            $id = $this->ids[$i];

            $url = env('APP_URL') . "/v4/manga/{$id}";

            echo "Indexing/Updating " . ($i + 1) . "/{$count} {$url} [MAL ID: {$id}] \n";

            try {
                $response = json_decode(file_get_contents($url), true);

                if (isset($response['error']) && $response['status'] != 404) {
                    echo "[SKIPPED] Failed to fetch {$url} - {$response['error']}\n";
                    $failedIds[] = $id;
                    Storage::put('indexer/indexer_manga.failed', json_encode($failedIds));
                }

                sleep($delay);
            } catch (\Exception $e) {
                echo "[SKIPPED] Failed to fetch {$url}\n";
                $failedIds[] = $id;
                Storage::put('indexer/indexer_manga.failed', json_encode($failedIds));
            }

            $success[] = $id;
            Storage::put('indexer/indexer_manga.save', $i);
        }

        Storage::delete('indexer/indexer_manga.save');

        echo "---------\nIndexing complete\n";
        echo count($success) . " entries indexed or updated\n";
        echo count($failedIds) . " entries failed to index or update. Re-run with --failed to requeue failed entries only\n";
    }

    /**
     * @return array
     * @url https://github.com/purarue/mal-id-cache
     */
    private function fetchMalIds() : array
    {
        $this->info("Fetching MAL ID Cache https://raw.githubusercontent.com/purarue/mal-id-cache/master/cache/manga_cache.json...\n");

        $ids = json_decode(
            file_get_contents('https://raw.githubusercontent.com/purarue/mal-id-cache/master/cache/manga_cache.json'),
            true
        );

        $ids = array_merge($ids['sfw'], $ids['nsfw']);
        sort($ids, SORT_NUMERIC);
        Storage::put('indexer/manga_mal_id.json', json_encode($ids));

        return json_decode(Storage::get('indexer/manga_mal_id.json'));
    }

    /**
     * @return array
     * @throws FileNotFoundException
     */
    private function loadFailedMalIds() : array
    {
        if (!Storage::exists('indexer/indexer_manga.failed')) {
            throw new FileNotFoundException('"indexer/indexer_manga.failed" does not exist');
        }

        return json_decode(Storage::get('indexer/indexer_manga.failed'));
    }

}



================================================
FILE: app/Console/Commands/Indexer/MangaSweepIndexer.php
================================================
<?php

namespace App\Console\Commands\Indexer;

use App\Exceptions\Console\CommandAlreadyRunningException;
use App\Exceptions\Console\FileNotFoundException;
use Illuminate\Console\Command;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Storage;

/**
 * Class MangaSweepIndexer
 *
 * @package App\Console\Commands\Indexer
 */
class MangaSweepIndexer extends Command
{
    /**
     * The name and signature of the console command.
     *`
     *
     * @var string
     */
    protected $signature = 'indexer:manga-sweep';

    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = 'Delete all removed manga';

    /**
     * Create a new command instance.
     *
     * @return void
     */
    public function __construct()
    {
        parent::__construct();
    }

    /**
     * Execute the console command.
     *
     * @return void
     * @throws FileNotFoundException
     */
    public function handle()
    {
        $this->info("Info: Delete removed MAL IDs\n\n");

        echo "Loading MAL IDs\n";
        $malIds = array_fill_keys($this->fetchMalIds(), null);

        echo "Loading MAL IDs from local DB\n";
        $results = DB::table('manga')->select('mal_id', '_id')->get();

        echo "Compare MAL IDs\n";
        $remove = [];

        foreach ($results as $result) {
            if (!array_key_exists($result['mal_id'], $malIds)) {
                $remove[] = $result['_id'];
            }
        }

        echo "Delete removed MAL IDs\n";
        DB::table('manga')->whereIn('_id', $remove)->delete();
    }

    /**
     * @return array
     * @url https://github.com/purarue/mal-id-cache
     */
    private function fetchMalIds(): array
    {
        $this->info("Fetching MAL ID Cache https://raw.githubusercontent.com/purarue/mal-id-cache/master/cache/manga_cache.json...\n");

        $ids = json_decode(
            file_get_contents('https://raw.githubusercontent.com/purarue/mal-id-cache/master/cache/manga_cache.json'),
            true
        );

        $ids = array_merge($ids['sfw'], $ids['nsfw']);
        Storage::put('indexer/manga_mal_id_sweep.json', json_encode($ids));

        return json_decode(Storage::get('indexer/manga_mal_id_sweep.json'));
    }
}



================================================
FILE: app/Console/Commands/Indexer/ProducersIndexer.php
================================================
<?php

namespace App\Console\Commands\Indexer;

use App\Exceptions\Console\FileNotFoundException;
use Illuminate\Console\Command;
use Illuminate\Support\Facades\Storage;
use Jikan\Request\Producer\ProducersRequest;


/**
 * Class ProducersIndexer
 * @package App\Console\Commands\Indexer
 */
class ProducersIndexer extends Command
{
    /**
     * The name and signature of the console command.
     *`
     * @var string
     */
    protected $signature = 'indexer:producers
                            {--failed : Run only entries that failed to index last time}
                            {--resume : Resume from the last position}
                            {--reverse : Start from the end of the array}
                            {--index=0 : Start from a specific index}
                            {--delay=3 : Set a delay between requests}';

    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = 'Index all producers';

    /**
     * @var array
     */
    private array $ids;

    /**
     * Create a new command instance.
     *
     * @return void
     */
    public function __construct()
    {
        parent::__construct();
    }

    /**
     * Execute the console command.
     *
     * @return void
     * @throws FileNotFoundException
     */
    public function handle()
    {

        $failed = $this->option('failed') ?? false;
        $resume = $this->option('resume') ?? false;
        $reverse = $this->option('reverse') ?? false;
        $delay = $this->option('delay') ?? 3;
        $index = $this->option('index') ?? 0;

        $index = (int)$index;
        $delay = (int)$delay;

        $this->info("Info: ProducersIndexer scrapes available MAL IDs and updates/indexes them\n\n");

        if ($failed && Storage::exists('indexer/indexer_producers.save')) {
            $this->ids = $this->loadFailedMalIds();
        }

        if (!$failed) {
            $this->ids = $this->fetchMalIds();
        }

        // start from the end
        if ($reverse) {
            $this->ids = array_reverse($this->ids);
        }

        // Resume
        if ($resume && Storage::exists('indexer/indexer_producers.save')) {
            $index = (int)Storage::get('indexer/indexer_producers.save');

            $this->info("Resuming from index: {$index}");
        }

        // check if index even exists
        if ($index > 0 && !isset($this->ids[$index])) {
            $index = 0;
            $this->warn('Invalid index; set back to 0');
        }

        // initialize and index
        Storage::put('indexer/indexer_producers.save', 0);

        echo "Loading MAL IDs\n";
        $count = count($this->ids);
        $failedIds = [];
        $success = [];

        echo "{$count} entries available\n";
        for ($i = $index; $i <= ($count - 1); $i++) {
            $id = $this->ids[$i];

            $url = env('APP_URL') . "/v4/producers/{$id}";

            echo "Indexing/Updating " . ($i + 1) . "/{$count} {$url} [MAL ID: {$id}] \n";

            try {
                $response = json_decode(file_get_contents($url), true);

                if (isset($response['error']) && $response['status'] != 404) {
                    echo "[SKIPPED] Failed to fetch {$url} - {$response['error']}\n";
                    $failedIds[] = $id;
                    Storage::put('indexer/indexer_producers.failed', json_encode($failedIds));
                }

                sleep($delay);
            } catch (\Exception $e) {
                echo "[SKIPPED] Failed to fetch {$url}\n";
                $failedIds[] = $id;
                Storage::put('indexer/indexer_producers.failed', json_encode($failedIds));
            }

            $success[] = $id;
            Storage::put('indexer/indexer_producers.save', $i);
        }

        Storage::delete('indexer/indexer_producers.save');

        echo "---------\nIndexing complete\n";
        echo count($success) . " entries indexed or updated\n";
        echo count($failedIds) . " entries failed to index or update. Re-run with --failed to requeue failed entries only\n";
    }

    /**
     * @return array
     */
    private function fetchMalIds() : array
    {
        $this->info("Scraping Producer MAL IDs from https://myanimelist.net/anime/producer...\n");

        $producers = \json_decode(
            app('SerializerV4')->serialize(
                app('JikanParser')
                    ->getProducers(new ProducersRequest()),
                'json'
            ),
            true
        )['producers'];

        foreach ($producers as $producer) {
            $this->ids[] = $producer['mal_id'];
        }

        Storage::put('indexer/producers_mal_id.json', json_encode($this->ids));

        return json_decode(Storage::get('indexer/producers_mal_id.json'));
    }

    /**
     * @return array
     * @throws FileNotFoundException
     */
    private function loadFailedMalIds() : array
    {
        if (!Storage::exists('indexer/indexer_producers.failed')) {
            throw new FileNotFoundException('"indexer/indexer_producers.failed" does not exist');
        }

        return json_decode(Storage::get('indexer/indexer_producers.failed'));
    }

}



================================================
FILE: app/Contracts/AnimeRepository.php
================================================
<?php

namespace App\Contracts;

use App\Anime;
use App\Enums\AnimeScheduleFilterEnum;
use App\Enums\AnimeSeasonEnum;
use App\Enums\AnimeTypeEnum;
use Illuminate\Contracts\Database\Query\Builder as EloquentBuilder;
use Illuminate\Support\Carbon;
use Illuminate\Support\Collection;
use Laravel\Scout\Builder as ScoutBuilder;
use Laravel\Scout\Scout;

/**
 * @implements Repository<Anime>
 */
interface AnimeRepository extends Repository
{
    public function getTopAiringItems(): EloquentBuilder|ScoutBuilder;

    public function getTopUpcomingItems(): EloquentBuilder|ScoutBuilder;

    public function exceptItemsWithAdultRating(): EloquentBuilder|ScoutBuilder;

    public function excludeKidsItems($builder): Collection|EloquentBuilder|ScoutBuilder;

    public function excludeNsfwItems($builder): Collection|EloquentBuilder|ScoutBuilder;

    public function excludeUnapprovedItems($builder): Collection|EloquentBuilder|ScoutBuilder;

    public function orderByPopularity(): EloquentBuilder|ScoutBuilder;

    public function orderByFavoriteCount(): EloquentBuilder|ScoutBuilder;

    public function orderByRank(): EloquentBuilder|ScoutBuilder;

    public function getCurrentlyAiring(
        ?AnimeScheduleFilterEnum $filter = null
    ): EloquentBuilder;

    public function getItemsBySeason(
        Carbon $from,
        Carbon $to,
        ?AnimeTypeEnum $type = null,
        ?string $premiered = null,
        bool $includeContinuingItems = false
    ): EloquentBuilder;

    public function getUpcomingSeasonItems(?AnimeTypeEnum $type = null): EloquentBuilder;

    public function orderByScore(): EloquentBuilder|ScoutBuilder;
}



================================================
FILE: app/Contracts/CachedScraperService.php
================================================
<?php

namespace App\Contracts;

use App\Support\CachedData;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\Response;
use Symfony\Component\HttpKernel\Exception\NotFoundHttpException;

/**
 * Representation of a service which knows about cached MAL scraper results.
 */
interface CachedScraperService
{
    /**
     * Finds cached scraper results by cacheKey, if not found scrapes them from MAL via the provided callback.
     * @param string $cacheKey
     * @param \Closure $getMalDataCallback
     * @param int|null $page
     * @return CachedData
     */
    public function findList(string $cacheKey, \Closure $getMalDataCallback, ?int $page = null): CachedData;

    /**
     * Finds cached scraper results by id in the database, if not found scrapes them from MAL.
     * @param int $id
     * @param string $cacheKey
     * @return CachedData
     * @throws NotFoundHttpException
     */
    public function find(int $id, string $cacheKey): CachedData;

    public function findByKey(string $key, mixed $val, string $cacheKey): CachedData;

    public function get(string $cacheKey): CachedData;
}



================================================
FILE: app/Contracts/CharacterRepository.php
================================================
<?php

namespace App\Contracts;

use App\Character;
use Illuminate\Contracts\Database\Query\Builder as EloquentBuilder;
use Laravel\Scout\Builder as ScoutBuilder;

/**
 * @implements Repository<Character>
 */
interface CharacterRepository extends Repository
{
    public function topCharacters(): EloquentBuilder|ScoutBuilder;
}



================================================
FILE: app/Contracts/ClubRepository.php
================================================
<?php

namespace App\Contracts;

use App\Club;

/**
 * @implements Repository<Club>
 */
interface ClubRepository extends Repository
{
}



================================================
FILE: app/Contracts/DataRequest.php
================================================
<?php

namespace App\Contracts;

use Illuminate\Http\Resources\Json\JsonResource;
use Illuminate\Http\Resources\Json\ResourceCollection;
use Illuminate\Http\Response;

/**
 * Marker interface to represent a request with a response
 * @template T of ResourceCollection|JsonResource|Response
 */
interface DataRequest
{
}



================================================
FILE: app/Contracts/GenreRepository.php
================================================
<?php

namespace App\Contracts;

use Illuminate\Support\Collection;

interface GenreRepository extends Repository
{
    public function genres(): Collection;

    public function getExplicitItems(): Collection;

    public function getThemes(): Collection;

    public function getDemographics(): Collection;

    public function all(): Collection;
}



================================================
FILE: app/Contracts/MagazineRepository.php
================================================
<?php

namespace App\Contracts;

use App\Magazine;

/**
 * @implements Repository<Magazine>
 */
interface MagazineRepository extends Repository
{
}



================================================
FILE: app/Contracts/MangaRepository.php
================================================
<?php

namespace App\Contracts;

use App\Manga;
use Illuminate\Contracts\Database\Query\Builder as EloquentBuilder;
use Laravel\Scout\Builder as ScoutBuilder;

/**
 * @implements Repository<Manga>
 */
interface MangaRepository extends Repository
{
    public function getTopPublishingItems(): EloquentBuilder|ScoutBuilder;

    public function getTopUpcomingItems(): EloquentBuilder|ScoutBuilder;

    public function orderByPopularity(): EloquentBuilder|ScoutBuilder;

    public function orderByFavoriteCount(): EloquentBuilder|ScoutBuilder;

    public function orderByRank(): EloquentBuilder|ScoutBuilder;

    public function exceptItemsWithAdultRating(): EloquentBuilder|ScoutBuilder;

    public function orderByScore(): EloquentBuilder|ScoutBuilder;

}



================================================
FILE: app/Contracts/Mediator.php
================================================
<?php

namespace App\Contracts;

interface Mediator
{
    /**
     * Send a request to a single handler
     * @template T
     * @param DataRequest<T> $requestData
     * @return T
     */
    public function send(DataRequest $requestData);
}



================================================
FILE: app/Contracts/PeopleRepository.php
================================================
<?php

namespace App\Contracts;

use App\Person;
use Illuminate\Contracts\Database\Query\Builder as EloquentBuilder;
use Laravel\Scout\Builder as ScoutBuilder;

/**
 * @implements Repository<Person>
 */
interface PeopleRepository extends Repository
{
    public function topPeople(): EloquentBuilder|ScoutBuilder;
}



================================================
FILE: app/Contracts/ProducerRepository.php
================================================
<?php

namespace App\Contracts;

use App\Producers;

/**
 * @implements Repository<Producers>
 */
interface ProducerRepository extends Repository
{

}



================================================
FILE: app/Contracts/Repository.php
================================================
<?php

namespace App\Contracts;

use App\JikanApiModel;
use Illuminate\Contracts\Database\Query\Builder;
use Illuminate\Support\Collection;

/**
 * @template T of JikanApiModel
 * @implements RepositoryQuery<T>
 */
interface Repository extends RepositoryQuery
{
    /**
     * @return T
     */
    public function createEntity();

    /**
     * @return ?T
     */
    public function getByMalId(int $id): JikanApiModel|array|null;

    public function getAllByMalId(int $id): Collection;

    public function queryByMalId(int $id): Builder;

    public function tableName(): string;

    // fixme: this should not be here.
    //        this is here because we have the "scrape" static method on models
    public function scrape(int|string $id): array;

    public function insert(array $attributes): bool;

    public function random(int $numberOfRandomItems = 1): Collection;
}



================================================
FILE: app/Contracts/RepositoryQuery.php
================================================
<?php

namespace App\Contracts;

use App\JikanApiModel;
use Illuminate\Contracts\Database\Query\Builder;
use Illuminate\Support\Collection;
use Laravel\Scout\Builder as ScoutBuilder;

/**
 * @template T of JikanApiModel
 */
interface RepositoryQuery
{
    /**
     * @param Collection $params
     * @return Builder<T>|ScoutBuilder<T>
     */
    public function filter(Collection $params): Builder|ScoutBuilder;

    /**
     * @param string $keywords
     * @param \Closure|null $callback
     * @return ScoutBuilder<T>
     */
    public function search(string $keywords, ?\Closure $callback = null): ScoutBuilder;

    /**
     * Get a where filter query
     * @param string $key
     * @param mixed $value
     * @return Builder
     */
    public function where(string $key, mixed $value): Builder;
}



================================================
FILE: app/Contracts/RequestHandler.php
================================================
<?php

namespace App\Contracts;

use Illuminate\Http\Resources\Json\JsonResource;
use Illuminate\Http\Resources\Json\ResourceCollection;
use Illuminate\Http\Response;

/**
 * @template TRequest of DataRequest<TResponse>
 * @template TResponse of ResourceCollection|JsonResource|Response
 */
interface RequestHandler
{
    /**
     * @param TRequest $request
     * @return TResponse
     */
    public function handle($request);

    /**
     * @return class-string<TRequest>
     */
    public function requestClass(): string;
}



================================================
FILE: app/Contracts/SearchAnalyticsService.php
================================================
<?php

namespace App\Contracts;

use Illuminate\Support\Collection;

interface SearchAnalyticsService
{
    public function logSearch(string $searchTerm, int $hitsCount, Collection $hits, string $indexName): void;
}



================================================
FILE: app/Contracts/UnitOfWork.php
================================================
<?php

namespace App\Contracts;

use App\Repositories\DocumentRepository;

interface UnitOfWork
{
    public function anime(): AnimeRepository;

    public function manga(): MangaRepository;

    public function characters(): CharacterRepository;

    public function people(): PeopleRepository;

    public function clubs(): ClubRepository;

    public function producers(): ProducerRepository;

    public function magazines(): MagazineRepository;

    public function users(): UserRepository;

    public function animeGenres(): GenreRepository;

    public function mangaGenres(): GenreRepository;

    /**
     * Returns the repository instance for a document collection which doesn't have a model representation.
     * @param string $tableName
     * @return DocumentRepository
     */
    public function documents(string $tableName): DocumentRepository;
}



================================================
FILE: app/Contracts/UserRepository.php
================================================
<?php

namespace App\Contracts;

use App\Profile;

/**
 * @implements Repository<Profile>
 */
interface UserRepository extends Repository
{
}



================================================
FILE: app/DataPipes/MapRouteParametersDataPipe.php
================================================
<?php

namespace App\DataPipes;

use Illuminate\Http\Request;
use Illuminate\Support\Collection;
use Spatie\LaravelData\DataPipes\DataPipe;
use Spatie\LaravelData\Support\DataClass;

/**
 * Maps route parameters to the data class properties if a request object payload is present.
 *
 * This makes the mapping of requests to dtos easier: The controller action only has to have the dto as argument.
 */
final class MapRouteParametersDataPipe implements DataPipe
{
    public function handle(mixed $payload, DataClass $class, Collection $properties): Collection
    {
        if ($payload instanceof Request) {
            foreach ($class->properties as $dataProperty) {
                $routeParamVal = $payload->route($dataProperty->inputMappedName ?? $dataProperty->name);

                if (!is_null($routeParamVal)) {
                    $properties->put($dataProperty->name, $routeParamVal);
                }
            }
        }

        return $properties;
    }
}



================================================
FILE: app/Dto/AnimeCharactersLookupCommand.php
================================================
<?php

namespace App\Dto;

use Illuminate\Http\JsonResponse;

/**
 * @extends LookupDataCommand<JsonResponse>
 */
final class AnimeCharactersLookupCommand extends LookupDataCommand
{
}



================================================
FILE: app/Dto/AnimeEpisodeLookupCommand.php
================================================
<?php

namespace App\Dto;

use Illuminate\Http\JsonResponse;
use Spatie\LaravelData\Attributes\Validation\Min;
use Spatie\LaravelData\Attributes\Validation\Numeric;
use Spatie\LaravelData\Attributes\Validation\Required;

/**
 * @extends LookupDataCommand<JsonResponse>
 */
final class AnimeEpisodeLookupCommand extends LookupDataCommand
{
    #[Numeric, Required, Min(1)]
    public int $episodeId;
}



================================================
FILE: app/Dto/AnimeEpisodesLookupCommand.php
================================================
<?php

namespace App\Dto;

use Illuminate\Http\JsonResponse;
use Spatie\LaravelData\Attributes\Validation\Min;
use Spatie\LaravelData\Attributes\Validation\Numeric;
use Spatie\LaravelData\Optional;

/**
 * @extends LookupDataCommand<JsonResponse>
 */
final class AnimeEpisodesLookupCommand extends LookupDataCommand
{
    #[Numeric, Min(1)]
    public int|Optional $page = 1;
}



================================================
FILE: app/Dto/AnimeExternalLookupCommand.php
================================================
<?php

namespace App\Dto;

use Illuminate\Http\JsonResponse;

/**
 * @extends LookupDataCommand<JsonResponse>
 */
final class AnimeExternalLookupCommand extends LookupDataCommand
{
}



================================================
FILE: app/Dto/AnimeForumLookupCommand.php
================================================
<?php

namespace App\Dto;

use App\Casts\EnumCast;
use App\Enums\AnimeForumFilterEnum;
use App\Rules\Attributes\EnumValidation;
use Illuminate\Http\JsonResponse;
use Spatie\LaravelData\Attributes\WithCast;
use Spatie\LaravelData\Optional;

/**
 * @extends LookupDataCommand<JsonResponse>
 */
final class AnimeForumLookupCommand extends LookupDataCommand
{
    #[WithCast(EnumCast::class, AnimeForumFilterEnum::class), EnumValidation(AnimeForumFilterEnum::class)]
    public AnimeForumFilterEnum|Optional $filter;
}



================================================
FILE: app/Dto/AnimeFullLookupCommand.php
================================================
<?php

namespace App\Dto;

use Illuminate\Http\JsonResponse;

/**
 * @extends LookupDataCommand<JsonResponse>
 */
final class AnimeFullLookupCommand extends LookupDataCommand
{
}



================================================
FILE: app/Dto/AnimeGenreListCommand.php
================================================
<?php

namespace App\Dto;

use App\Contracts\DataRequest;
use App\Http\Resources\V4\GenreCollection;

/**
 * @implements DataRequest<GenreCollection>
 */
final class AnimeGenreListCommand extends GenreListCommand implements DataRequest
{
}



================================================
FILE: app/Dto/AnimeLookupCommand.php
================================================
<?php

namespace App\Dto;

use Illuminate\Http\JsonResponse;
use Illuminate\Http\Request;

/**
 * @extends LookupDataCommand<JsonResponse>
 */
final class AnimeLookupCommand extends LookupDataCommand
{
}



================================================
FILE: app/Dto/AnimeMoreInfoLookupCommand.php
================================================
<?php

namespace App\Dto;

use Illuminate\Http\JsonResponse;

/**
 * @extends LookupDataCommand<JsonResponse>
 */
final class AnimeMoreInfoLookupCommand extends LookupDataCommand
{
}



================================================
FILE: app/Dto/AnimeNewsLookupCommand.php
================================================
<?php

namespace App\Dto;

use Illuminate\Http\JsonResponse;
use Spatie\LaravelData\Attributes\Validation\Min;
use Spatie\LaravelData\Attributes\Validation\Numeric;
use Spatie\LaravelData\Optional;

/**
 * @extends LookupDataCommand<JsonResponse>
 */
final class AnimeNewsLookupCommand extends LookupDataCommand
{
    #[Numeric, Min(1)]
    public int|Optional $page = 1;
}



================================================
FILE: app/Dto/AnimePicturesLookupCommand.php
================================================
<?php

namespace App\Dto;

use Illuminate\Http\JsonResponse;

/**
 * @extends LookupDataCommand<JsonResponse>
 */
final class AnimePicturesLookupCommand extends LookupDataCommand
{
}



================================================
FILE: app/Dto/AnimeRecommendationsLookupCommand.php
================================================
<?php

namespace App\Dto;

use Illuminate\Http\JsonResponse;

/**
 * @extends LookupDataCommand<JsonResponse>
 */
final class AnimeRecommendationsLookupCommand extends LookupDataCommand
{
}



================================================
FILE: app/Dto/AnimeRelationsLookupCommand.php
================================================
<?php

namespace App\Dto;

use Illuminate\Http\JsonResponse;

/**
 * @extends LookupDataCommand<JsonResponse>
 */
final class AnimeRelationsLookupCommand extends LookupDataCommand
{
}



================================================
FILE: app/Dto/AnimeReviewsLookupCommand.php
================================================
<?php

namespace App\Dto;

use App\Casts\ContextualBooleanCast;
use App\Casts\EnumCast;
use App\Dto\Concerns\HasPreliminaryParameter;
use App\Dto\Concerns\HasSpoilersParameter;
use App\Dto\Concerns\PreparesData;
use App\Enums\MediaReviewsSortEnum;
use App\Rules\Attributes\EnumValidation;
use Illuminate\Http\JsonResponse;
use Spatie\LaravelData\Attributes\Validation\BooleanType;
use Spatie\LaravelData\Attributes\Validation\Min;
use Spatie\LaravelData\Attributes\Validation\Numeric;
use Spatie\LaravelData\Attributes\WithCast;
use Spatie\LaravelData\Optional;


/**
 * @extends LookupDataCommand<JsonResponse>
 */
final class AnimeReviewsLookupCommand extends LookupDataCommand
{
    use PreparesData, HasPreliminaryParameter, HasSpoilersParameter;

    #[Numeric, Min(1)]
    public int|Optional $page = 1;

    #[WithCast(EnumCast::class, MediaReviewsSortEnum::class), EnumValidation(MediaReviewsSortEnum::class)]
    public MediaReviewsSortEnum|Optional $sort;
}



================================================
FILE: app/Dto/AnimeSearchCommand.php
================================================
<?php

namespace App\Dto;

use App\Contracts\DataRequest;
use App\Dto\Concerns\HasSfwParameter;
use App\Enums\AnimeOrderByEnum;
use App\Enums\AnimeRatingEnum;
use App\Enums\AnimeStatusEnum;
use App\Enums\AnimeTypeEnum;
use App\Http\Resources\V4\AnimeCollection;
use App\Rules\Attributes\EnumValidation;
use Spatie\LaravelData\Attributes\MapInputName;
use Spatie\LaravelData\Attributes\MapOutputName;
use Spatie\LaravelData\Attributes\Validation\IntegerType;
use Spatie\LaravelData\Attributes\Validation\Min;
use Spatie\LaravelData\Attributes\Validation\Prohibits;
use Spatie\LaravelData\Attributes\Validation\StringType;
use Spatie\LaravelData\Attributes\WithCast;
use App\Casts\EnumCast;
use Spatie\LaravelData\Optional;

/**
 * @implements DataRequest<AnimeCollection>
 */
final class AnimeSearchCommand extends MediaSearchCommand implements DataRequest
{
    #[WithCast(EnumCast::class, AnimeStatusEnum::class), EnumValidation(AnimeStatusEnum::class)]
    public AnimeStatusEnum|Optional $status;

    #[WithCast(EnumCast::class, AnimeTypeEnum::class), EnumValidation(AnimeTypeEnum::class)]
    public AnimeTypeEnum|Optional $type;

    #[WithCast(EnumCast::class, AnimeRatingEnum::class), EnumValidation(AnimeRatingEnum::class)]
    public AnimeRatingEnum|Optional $rating;

    #[IntegerType, Min(1)]
    public int|Optional $producer;

    #[Prohibits("producer"), StringType]
    public string|Optional $producers;

    #[
        MapInputName("order_by"),
        MapOutputName("order_by"),
        WithCast(EnumCast::class, AnimeOrderByEnum::class),
        EnumValidation(AnimeOrderByEnum::class)
    ]
    public AnimeOrderByEnum|Optional $orderBy;
}



================================================
FILE: app/Dto/AnimeStaffLookupCommand.php
================================================
<?php

namespace App\Dto;

use Illuminate\Http\JsonResponse;

/**
 * @extends LookupDataCommand<JsonResponse>
 */
final class AnimeStaffLookupCommand extends LookupDataCommand
{
}



================================================
FILE: app/Dto/AnimeStatsLookupCommand.php
================================================
<?php

namespace App\Dto;

use Illuminate\Http\JsonResponse;

/**
 * @extends LookupDataCommand<JsonResponse>
 */
final class AnimeStatsLookupCommand extends LookupDataCommand
{
}



================================================
FILE: app/Dto/AnimeStreamingLookupCommand.php
================================================
<?php

namespace App\Dto;

use Illuminate\Http\JsonResponse;

/**
 * @extends LookupDataCommand<JsonResponse>
 */
final class AnimeStreamingLookupCommand extends LookupDataCommand
{
}



================================================
FILE: app/Dto/AnimeThemesLookupCommand.php
================================================
<?php

namespace App\Dto;

use Illuminate\Http\JsonResponse;

/**
 * @extends LookupDataCommand<JsonResponse>
 */
final class AnimeThemesLookupCommand extends LookupDataCommand
{
}



================================================
FILE: app/Dto/AnimeUserUpdatesLookupCommand.php
================================================
<?php

namespace App\Dto;

use Illuminate\Http\JsonResponse;
use Spatie\LaravelData\Attributes\Validation\Min;
use Spatie\LaravelData\Attributes\Validation\Numeric;
use Spatie\LaravelData\Optional;

/**
 * @extends LookupDataCommand<JsonResponse>
 */
final class AnimeUserUpdatesLookupCommand extends LookupDataCommand
{
    #[Numeric, Min(1)]
    public int|Optional $page = 1;
}



================================================
FILE: app/Dto/AnimeVideosEpisodesLookupCommand.php
================================================
<?php

namespace App\Dto;

use Illuminate\Http\JsonResponse;
use Spatie\LaravelData\Attributes\Validation\Min;
use Spatie\LaravelData\Attributes\Validation\Numeric;
use Spatie\LaravelData\Optional;

/**
 * @extends LookupDataCommand<JsonResponse>
 */
final class AnimeVideosEpisodesLookupCommand extends LookupDataCommand
{
    #[Numeric, Min(1)]
    public int|Optional $page = 1;
}



================================================
FILE: app/Dto/AnimeVideosLookupCommand.php
================================================
<?php

namespace App\Dto;

use Illuminate\Http\JsonResponse;

/**
 * @extends LookupDataCommand<JsonResponse>
 */
final class AnimeVideosLookupCommand extends LookupDataCommand
{
}



================================================
FILE: app/Dto/CharacterAnimeLookupCommand.php
================================================
<?php

namespace App\Dto;

use Illuminate\Http\JsonResponse;

/**
 * @extends LookupDataCommand<JsonResponse>
 */
final class CharacterAnimeLookupCommand extends LookupDataCommand
{
}



================================================
FILE: app/Dto/CharacterFullLookupCommand.php
================================================
<?php

namespace App\Dto;

use Illuminate\Http\JsonResponse;

/**
 * @extends LookupDataCommand<JsonResponse>
 */
final class CharacterFullLookupCommand extends LookupDataCommand
{
}



================================================
FILE: app/Dto/CharacterLookupCommand.php
================================================
<?php

namespace App\Dto;

use Illuminate\Http\JsonResponse;

/**
 * @extends LookupDataCommand<JsonResponse>
 */
final class CharacterLookupCommand extends LookupDataCommand
{
}



================================================
FILE: app/Dto/CharacterMangaLookupCommand.php
================================================
<?php

namespace App\Dto;

use Illuminate\Http\JsonResponse;

/**
 * @extends LookupDataCommand<JsonResponse>
 */
final class CharacterMangaLookupCommand extends LookupDataCommand
{
}



================================================
FILE: app/Dto/CharacterPicturesLookupCommand.php
================================================
<?php

namespace App\Dto;

use Illuminate\Http\JsonResponse;

/**
 * @extends LookupDataCommand<JsonResponse>
 */
final class CharacterPicturesLookupCommand extends LookupDataCommand
{
}



================================================
FILE: app/Dto/CharactersSearchCommand.php
================================================
<?php

namespace App\Dto;

use App\Casts\EnumCast;
use App\Contracts\DataRequest;
use App\Enums\CharacterOrderByEnum;
use App\Http\Resources\V4\CharacterCollection;
use App\Rules\Attributes\EnumValidation;
use Spatie\LaravelData\Attributes\MapInputName;
use Spatie\LaravelData\Attributes\MapOutputName;
use Spatie\LaravelData\Attributes\WithCast;
use Spatie\LaravelData\Optional;

/**
 * @implements DataRequest<CharacterCollection>
 */
final class CharactersSearchCommand extends SearchCommand implements DataRequest
{
    #[MapInputName("order_by"), MapOutputName("order_by"),
        WithCast(EnumCast::class, CharacterOrderByEnum::class), EnumValidation(CharacterOrderByEnum::class)]
    public CharacterOrderByEnum|Optional $orderBy;
}



================================================
FILE: app/Dto/CharacterVoicesLookupCommand.php
================================================
<?php

namespace App\Dto;

use Illuminate\Http\JsonResponse;

/**
 * @extends LookupDataCommand<JsonResponse>
 */
final class CharacterVoicesLookupCommand extends LookupDataCommand
{
}



================================================
FILE: app/Dto/ClubLookupCommand.php
================================================
<?php

namespace App\Dto;

use Illuminate\Http\JsonResponse;

/**
 * @extends LookupDataCommand<JsonResponse>
 */
final class ClubLookupCommand extends LookupDataCommand
{
}



================================================
FILE: app/Dto/ClubMembersLookupCommand.php
================================================
<?php

namespace App\Dto;

use App\Dto\Concerns\HasPageParameter;
use Illuminate\Http\JsonResponse;
use Spatie\LaravelData\Attributes\Validation\Min;
use Spatie\LaravelData\Attributes\Validation\Numeric;
use Spatie\LaravelData\Optional;

/**
 * @extends LookupDataCommand<JsonResponse>
 */
final class ClubMembersLookupCommand extends LookupDataCommand
{
    // use HasPageParameter;
    #[Numeric, Min(1)]
    public int|Optional $page = 1;
}



================================================
FILE: app/Dto/ClubRelationLookupCommand.php
================================================
<?php

namespace App\Dto;

use Illuminate\Http\JsonResponse;

/**
 * @extends LookupDataCommand<JsonResponse>
 */
final class ClubRelationLookupCommand extends LookupDataCommand
{
}



================================================
FILE: app/Dto/ClubSearchCommand.php
================================================
<?php

namespace App\Dto;

use App\Casts\EnumCast;
use App\Contracts\DataRequest;
use App\Enums\ClubCategoryEnum;
use App\Enums\ClubOrderByEnum;
use App\Enums\ClubTypeEnum;
use App\Http\Resources\V4\ClubCollection;
use App\Rules\Attributes\EnumValidation;
use Spatie\LaravelData\Attributes\MapInputName;
use Spatie\LaravelData\Attributes\MapOutputName;
use Spatie\LaravelData\Attributes\WithCast;
use Spatie\LaravelData\Optional;

/**
 * @implements DataRequest<ClubCollection>
 */
final class ClubSearchCommand extends SearchCommand implements DataRequest
{
    #[WithCast(EnumCast::class, ClubCategoryEnum::class), EnumValidation(ClubCategoryEnum::class)]
    public ClubCategoryEnum|Optional $category;

    #[WithCast(EnumCast::class, ClubTypeEnum::class), EnumValidation(ClubTypeEnum::class)]
    public ClubTypeEnum|Optional $type;

    #[MapInputName("order_by"), MapOutputName("order_by"),
        WithCast(EnumCast::class, ClubOrderByEnum::class), EnumValidation(ClubOrderByEnum::class)]
    public ClubOrderByEnum|Optional $orderBy;
}



================================================
FILE: app/Dto/ClubStaffLookupCommand.php
================================================
<?php

namespace App\Dto;

use Illuminate\Http\JsonResponse;

/**
 * @extends LookupDataCommand<JsonResponse>
 */
final class ClubStaffLookupCommand extends LookupDataCommand
{
}



================================================
FILE: app/Dto/GenreListCommand.php
================================================
<?php

namespace App\Dto;

use App\Enums\GenreFilterEnum;
use App\Rules\Attributes\EnumValidation;
use Spatie\LaravelData\Attributes\WithCast;
use App\Casts\EnumCast;
use Spatie\LaravelData\Data;
use Spatie\LaravelData\Optional;

abstract class GenreListCommand extends Data
{
    #[WithCast(EnumCast::class, GenreFilterEnum::class), EnumValidation(GenreFilterEnum::class)]
    public GenreFilterEnum|Optional $filter;
}



================================================
FILE: app/Dto/LookupByUsernameCommand.php
================================================
<?php

namespace App\Dto;

use App\Concerns\HasRequestFingerprint;
use App\Contracts\DataRequest;
use App\Dto\Concerns\MapsRouteParameters;
use Illuminate\Http\Resources\Json\JsonResource;
use Illuminate\Http\Resources\Json\ResourceCollection;
use Illuminate\Http\Response;
use Spatie\LaravelData\Attributes\Validation\Max;
use Spatie\LaravelData\Attributes\Validation\Min;
use Spatie\LaravelData\Attributes\Validation\StringType;
use Spatie\LaravelData\Data;

/**
 * Base class for all requests/commands which are for looking up things by username.
 * @template T of ResourceCollection|JsonResource|Response
 * @implements DataRequest<T>
 */
abstract class LookupByUsernameCommand extends Data implements DataRequest
{
    use MapsRouteParameters, HasRequestFingerprint;

    #[StringType, Max(255), Min(3)]
    public string $username;
}



================================================
FILE: app/Dto/LookupDataCommand.php
================================================
<?php

namespace App\Dto;

use App\Concerns\HasRequestFingerprint;
use App\Contracts\DataRequest;
use App\Dto\Concerns\MapsRouteParameters;
use Illuminate\Http\Resources\Json\JsonResource;
use Illuminate\Http\Resources\Json\ResourceCollection;
use Illuminate\Http\Response;
use Spatie\LaravelData\Attributes\Validation\Min;
use Spatie\LaravelData\Attributes\Validation\Numeric;
use Spatie\LaravelData\Attributes\Validation\Required;
use Spatie\LaravelData\Data;

/**
 * Base class for all requests/commands which are for looking up things by id.
 * @template T of ResourceCollection|JsonResource|Response
 * @implements DataRequest<T>
 */
abstract class LookupDataCommand extends Data implements DataRequest
{
    use MapsRouteParameters, HasRequestFingerprint;

    #[Numeric, Required, Min(1)]
    public int $id;
}



================================================
FILE: app/Dto/MagazineSearchCommand.php
================================================
<?php

namespace App\Dto;

use App\Casts\EnumCast;
use App\Contracts\DataRequest;
use App\Enums\MagazineOrderByEnum;
use App\Http\Resources\V4\MagazineCollection;
use App\Rules\Attributes\EnumValidation;
use Spatie\LaravelData\Attributes\MapInputName;
use Spatie\LaravelData\Attributes\MapOutputName;
use Spatie\LaravelData\Attributes\WithCast;
use Spatie\LaravelData\Optional;

/**
 * @implements DataRequest<MagazineCollection>
 */
final class MagazineSearchCommand extends SearchCommand implements DataRequest
{
    #[MapInputName("order_by"), MapOutputName("order_by"),
        WithCast(EnumCast::class, MagazineOrderByEnum::class), EnumValidation(MagazineOrderByEnum::class)]
    public MagazineOrderByEnum|Optional $orderBy;
}



================================================
FILE: app/Dto/MangaCharactersLookupCommand.php
================================================
<?php

namespace App\Dto;


use Illuminate\Http\JsonResponse;

/**
 * @extends LookupDataCommand<JsonResponse>
 */
final class MangaCharactersLookupCommand extends LookupDataCommand
{
}



================================================
FILE: app/Dto/MangaExternalLookupCommand.php
================================================
<?php

namespace App\Dto;


use Illuminate\Http\JsonResponse;

/**
 * @extends LookupDataCommand<JsonResponse>
 */
final class MangaExternalLookupCommand extends LookupDataCommand
{
}



================================================
FILE: app/Dto/MangaForumLookupCommand.php
================================================
<?php

namespace App\Dto;


use App\Casts\EnumCast;
use App\Enums\MangaForumFilterEnum;
use App\Rules\Attributes\EnumValidation;
use Illuminate\Http\JsonResponse;
use Spatie\LaravelData\Attributes\WithCast;
use Spatie\LaravelData\Optional;

/**
 * @extends LookupDataCommand<JsonResponse>
 */
final class MangaForumLookupCommand extends LookupDataCommand
{
    #[WithCast(EnumCast::class, MangaForumFilterEnum::class), EnumValidation(MangaForumFilterEnum::class)]
    public MangaForumFilterEnum|Optional $filter;
}



================================================
FILE: app/Dto/MangaFullLookupCommand.php
================================================
<?php

namespace App\Dto;

use Illuminate\Http\JsonResponse;

/**
 * @extends LookupDataCommand<JsonResponse>
 */
final class MangaFullLookupCommand extends LookupDataCommand
{
}



================================================
FILE: app/Dto/MangaGenreListCommand.php
================================================
<?php

namespace App\Dto;

use App\Contracts\DataRequest;
use App\Http\Resources\V4\GenreCollection;

/**
 * @implements DataRequest<GenreCollection>
 */
final class MangaGenreListCommand extends GenreListCommand implements DataRequest
{
}



================================================
FILE: app/Dto/MangaLookupCommand.php
================================================
<?php

namespace App\Dto;


use Illuminate\Http\JsonResponse;

/**
 * @extends LookupDataCommand<JsonResponse>
 */
final class MangaLookupCommand extends LookupDataCommand
{
}



================================================
FILE: app/Dto/MangaMoreInfoLookupCommand.php
================================================
<?php

namespace App\Dto;


use Illuminate\Http\JsonResponse;

/**
 * @extends LookupDataCommand<JsonResponse>
 */
final class MangaMoreInfoLookupCommand extends LookupDataCommand
{
}



================================================
FILE: app/Dto/MangaNewsLookupCommand.php
================================================
<?php

namespace App\Dto;


use Illuminate\Http\JsonResponse;
use Spatie\LaravelData\Attributes\Validation\Min;
use Spatie\LaravelData\Attributes\Validation\Numeric;
use Spatie\LaravelData\Optional;

/**
 * @extends LookupDataCommand<JsonResponse>
 */
final class MangaNewsLookupCommand extends LookupDataCommand
{
    #[Numeric, Min(1)]
    public int|Optional $page = 1;
}



================================================
FILE: app/Dto/MangaPicturesLookupCommand.php
================================================
<?php

namespace App\Dto;


use Illuminate\Http\JsonResponse;

/**
 * @extends LookupDataCommand<JsonResponse>
 */
final class MangaPicturesLookupCommand extends LookupDataCommand
{
}



================================================
FILE: app/Dto/MangaRecommendationsLookupCommand.php
================================================
<?php

namespace App\Dto;


use Illuminate\Http\JsonResponse;

/**
 * @extends LookupDataCommand<JsonResponse>
 */
final class MangaRecommendationsLookupCommand extends LookupDataCommand
{
}



================================================
FILE: app/Dto/MangaRelationsLookupCommand.php
================================================
<?php

namespace App\Dto;


use Illuminate\Http\JsonResponse;

/**
 * @extends LookupDataCommand<JsonResponse>
 */
final class MangaRelationsLookupCommand extends LookupDataCommand
{
}



================================================
FILE: app/Dto/MangaReviewsLookupCommand.php
================================================
<?php

namespace App\Dto;


use App\Casts\ContextualBooleanCast;
use App\Casts\EnumCast;
use App\Dto\Concerns\HasPreliminaryParameter;
use App\Dto\Concerns\HasSpoilersParameter;
use App\Dto\Concerns\PreparesData;
use App\Enums\MediaReviewsSortEnum;
use App\Rules\Attributes\EnumValidation;
use Illuminate\Http\JsonResponse;
use Spatie\LaravelData\Attributes\Validation\BooleanType;
use Spatie\LaravelData\Attributes\Validation\Min;
use Spatie\LaravelData\Attributes\Validation\Numeric;
use Spatie\LaravelData\Attributes\WithCast;
use Spatie\LaravelData\Optional;

/**
 * @extends LookupDataCommand<JsonResponse>
 */
final class MangaReviewsLookupCommand extends LookupDataCommand
{
    use PreparesData, HasPreliminaryParameter, HasSpoilersParameter;

    #[Numeric, Min(1)]
    public int|Optional $page = 1;

    #[WithCast(EnumCast::class, MediaReviewsSortEnum::class), EnumValidation(MediaReviewsSortEnum::class)]
    public MediaReviewsSortEnum|Optional $sort;
}



================================================
FILE: app/Dto/MangaSearchCommand.php
================================================
<?php

namespace App\Dto;

use App\Casts\EnumCast;
use App\Contracts\DataRequest;
use App\Enums\MangaOrderByEnum;
use App\Enums\MangaStatusEnum;
use App\Enums\MangaTypeEnum;
use App\Http\Resources\V4\MangaCollection;
use App\Rules\Attributes\EnumValidation;
use Spatie\Enum\Laravel\Rules\EnumRule;
use Spatie\LaravelData\Attributes\MapInputName;
use Spatie\LaravelData\Attributes\MapOutputName;
use Spatie\LaravelData\Attributes\Validation\StringType;
use Spatie\LaravelData\Attributes\WithCast;
use Spatie\LaravelData\Optional;

/**
 * @implements DataRequest<MangaCollection>
 */
final class MangaSearchCommand extends MediaSearchCommand implements DataRequest
{
    #[WithCast(EnumCast::class, MangaStatusEnum::class), EnumValidation(MangaStatusEnum::class)]
    public MangaStatusEnum|Optional $status;

    #[WithCast(EnumCast::class, MangaTypeEnum::class), EnumValidation(MangaTypeEnum::class)]
    public MangaTypeEnum|Optional $type;

    #[StringType]
    public string|Optional $magazines;

    #[
        MapInputName("order_by"),
        MapOutputName("order_by"),
        EnumValidation(MangaOrderByEnum::class),
        WithCast(EnumCast::class, MangaOrderByEnum::class)
    ]
    public MangaOrderByEnum|Optional $orderBy;
}



================================================
FILE: app/Dto/MangaStatsLookupCommand.php
================================================
<?php

namespace App\Dto;


use Illuminate\Http\JsonResponse;

/**
 * @extends LookupDataCommand<JsonResponse>
 */
final class MangaStatsLookupCommand extends LookupDataCommand
{
}



================================================
FILE: app/Dto/MangaUserUpdatesLookupCommand.php
================================================
<?php

namespace App\Dto;


use Illuminate\Http\JsonResponse;
use Spatie\LaravelData\Attributes\Validation\Min;
use Spatie\LaravelData\Attributes\Validation\Numeric;
use Spatie\LaravelData\Optional;

/**
 * @extends LookupDataCommand<JsonResponse>
 */
final class MangaUserUpdatesLookupCommand extends LookupDataCommand
{
    #[Numeric, Min(1)]
    public int|Optional $page = 1;
}



================================================
FILE: app/Dto/MediaSearchCommand.php
================================================
<?php

namespace App\Dto;

use App\Dto\Concerns\HasSfwParameter;
use App\Dto\Concerns\HasUnapprovedParameter;
use Carbon\CarbonImmutable;
use Illuminate\Validation\Validator;
use Spatie\LaravelData\Attributes\MapInputName;
use Spatie\LaravelData\Attributes\MapOutputName;
use Spatie\LaravelData\Attributes\Validation\AfterOrEqual;
use Spatie\LaravelData\Attributes\Validation\BeforeOrEqual;
use Spatie\LaravelData\Attributes\Validation\Between;
use Spatie\LaravelData\Attributes\Validation\DateFormat;
use Spatie\LaravelData\Attributes\Validation\Numeric;
use Spatie\LaravelData\Attributes\Validation\Prohibits;
use Spatie\LaravelData\Attributes\Validation\Required;
use Spatie\LaravelData\Attributes\Validation\Sometimes;
use Spatie\LaravelData\Attributes\WithCast;
use Spatie\LaravelData\Attributes\WithTransformer;
use Spatie\LaravelData\Casts\DateTimeInterfaceCast;
use Spatie\LaravelData\Optional;
use Spatie\LaravelData\Transformers\DateTimeInterfaceTransformer;

class MediaSearchCommand extends SearchCommand
{
    use HasSfwParameter, HasUnapprovedParameter;

    #[MapInputName("min_score"), MapOutputName("min_score"), Between(0.00, 10.00), Numeric]
    public float|Optional $minScore;

    #[MapInputName("max_score"), MapOutputName("max_score"), Between(1.00, 10.00), Numeric]
    public float|Optional $maxScore;

    #[Between(1.00, 9.99), Numeric, Prohibits(["min_score", "max_score"])]
    public float|Optional $score;

    public string|Optional $genres;

    #[MapInputName("genres_exclude"), MapOutputName("genres_exclude")]
    public string|Optional $genresExclude;

    #[
        BeforeOrEqual("end_date"),
        DateFormat("Y-m-d"),
        Sometimes,
        Required,
        WithCast(DateTimeInterfaceCast::class),
        WithTransformer(DateTimeInterfaceTransformer::class)
    ]
    public CarbonImmutable|Optional $start_date;

    #[
        AfterOrEqual("start_date"),
        DateFormat("Y-m-d"),
        Sometimes,
        Required,
        WithCast(DateTimeInterfaceCast::class),
        WithTransformer(DateTimeInterfaceTransformer::class)
    ]
    public CarbonImmutable|Optional $end_date;

    public static function withValidator(Validator $validator): void
    {
        $validator->sometimes("min_score", "lte:max_score", fn ($input) => !empty($input->max_score));
        $validator->sometimes("max_score", "gte:min_score", fn ($input) => !empty($input->min_score));
    }
}



================================================
FILE: app/Dto/PeopleSearchCommand.php
================================================
<?php

namespace App\Dto;

use App\Casts\EnumCast;
use App\Contracts\DataRequest;
use App\Enums\PeopleOrderByEnum;
use App\Http\Resources\V4\PersonCollection;
use App\Rules\Attributes\EnumValidation;
use Spatie\LaravelData\Attributes\MapInputName;
use Spatie\LaravelData\Attributes\MapOutputName;
use Spatie\LaravelData\Attributes\WithCast;
use Spatie\LaravelData\Optional;

/**
 * @implements DataRequest<PersonCollection>
 */
final class PeopleSearchCommand extends SearchCommand implements DataRequest
{
    #[MapInputName("order_by"), MapOutputName("order_by"),
        WithCast(EnumCast::class, PeopleOrderByEnum::class), EnumValidation(PeopleOrderByEnum::class)]
    public PeopleOrderByEnum|Optional $orderBy;
}



================================================
FILE: app/Dto/PersonAnimeLookupCommand.php
================================================
<?php

namespace App\Dto;


use Illuminate\Http\JsonResponse;

/**
 * @extends LookupDataCommand<JsonResponse>
 */
final class PersonAnimeLookupCommand extends LookupDataCommand
{
}



================================================
FILE: app/Dto/PersonFullLookupCommand.php
================================================
<?php

namespace App\Dto;


use Illuminate\Http\JsonResponse;

/**
 * @extends LookupDataCommand<JsonResponse>
 */
final class PersonFullLookupCommand extends LookupDataCommand
{
}



================================================
FILE: app/Dto/PersonLookupCommand.php
================================================
<?php

namespace App\Dto;


use Illuminate\Http\JsonResponse;

/**
 * @extends LookupDataCommand<JsonResponse>
 */
final class PersonLookupCommand extends LookupDataCommand
{
}



================================================
FILE: app/Dto/PersonMangaLookupCommand.php
================================================
<?php

namespace App\Dto;


use Illuminate\Http\JsonResponse;

/**
 * @extends LookupDataCommand<JsonResponse>
 */
final class PersonMangaLookupCommand extends LookupDataCommand
{
}



================================================
FILE: app/Dto/PersonPicturesLookupCommand.php
================================================
<?php

namespace App\Dto;


use Illuminate\Http\JsonResponse;

/**
 * @extends LookupDataCommand<JsonResponse>
 */
final class PersonPicturesLookupCommand extends LookupDataCommand
{
}



================================================
FILE: app/Dto/PersonVoicesLookupCommand.php
================================================
<?php

namespace App\Dto;


use Illuminate\Http\JsonResponse;

/**
 * @extends LookupDataCommand<JsonResponse>
 */
final class PersonVoicesLookupCommand extends LookupDataCommand
{
}



================================================
FILE: app/Dto/ProducerExternalLookupCommand.php
================================================
<?php

namespace App\Dto;


use Illuminate\Http\JsonResponse;

/**
 * @extends LookupDataCommand<JsonResponse>
 */
final class ProducerExternalLookupCommand extends LookupDataCommand
{
}



================================================
FILE: app/Dto/ProducerFullLookupCommand.php
================================================
<?php

namespace App\Dto;


use Illuminate\Http\JsonResponse;

/**
 * @extends LookupDataCommand<JsonResponse>
 */
final class ProducerFullLookupCommand extends LookupDataCommand
{
}



================================================
FILE: app/Dto/ProducerLookupCommand.php
================================================
<?php

namespace App\Dto;


use Illuminate\Http\JsonResponse;

/**
 * @extends LookupDataCommand<JsonResponse>
 */
final class ProducerLookupCommand extends LookupDataCommand
{
}



================================================
FILE: app/Dto/ProducersSearchCommand.php
================================================
<?php

namespace App\Dto;

use App\Casts\EnumCast;
use App\Contracts\DataRequest;
use App\Enums\ProducerOrderByEnum;
use App\Http\Resources\V4\ProducerCollection;
use App\Rules\Attributes\EnumValidation;
use Spatie\LaravelData\Attributes\MapInputName;
use Spatie\LaravelData\Attributes\MapOutputName;
use Spatie\LaravelData\Attributes\WithCast;
use Spatie\LaravelData\Optional;

/**
 * @implements DataRequest<ProducerCollection>
 */
final class ProducersSearchCommand extends SearchCommand implements DataRequest
{
    #[MapInputName("order_by"), MapOutputName("order_by"),
        WithCast(EnumCast::class, ProducerOrderByEnum::class), EnumValidation(ProducerOrderByEnum::class)]
    public ProducerOrderByEnum|Optional $orderBy;
}



================================================
FILE: app/Dto/QueryAnimeListOfUserCommand.php
================================================
<?php

namespace App\Dto;

use App\Casts\EnumCast;
use App\Enums\AnimeListAiringStatusFilterEnum;
use App\Enums\AnimeListStatusEnum;
use App\Enums\UserAnimeListOrderByEnum;
use App\Enums\UserListTypeEnum;
use App\Rules\Attributes\EnumValidation;
use App\Services\JikanUserListRequestMapperService;
use Carbon\CarbonImmutable;
use Jikan\Request\User\UserAnimeListRequest;
use Spatie\LaravelData\Attributes\MapInputName;
use Spatie\LaravelData\Attributes\Validation\AfterOrEqual;
use Spatie\LaravelData\Attributes\Validation\BeforeOrEqual;
use Spatie\LaravelData\Attributes\Validation\DateFormat;
use Spatie\LaravelData\Attributes\Validation\Max;
use Spatie\LaravelData\Attributes\Validation\Min;
use Spatie\LaravelData\Attributes\Validation\Required;
use Spatie\LaravelData\Attributes\Validation\Sometimes;
use Spatie\LaravelData\Attributes\WithCast;
use Spatie\LaravelData\Attributes\WithTransformer;
use Spatie\LaravelData\Casts\DateTimeInterfaceCast;
use Spatie\LaravelData\Optional;
use Spatie\LaravelData\Transformers\DateTimeInterfaceTransformer;

final class QueryAnimeListOfUserCommand extends QueryListOfUserCommand
{
    #[WithCast(EnumCast::class, AnimeListStatusEnum::class), EnumValidation(AnimeListStatusEnum::class)]
    public AnimeListStatusEnum|Optional $status;

    #[
        WithCast(EnumCast::class, UserAnimeListOrderByEnum::class),
        EnumValidation(UserAnimeListOrderByEnum::class),
        MapInputName("order_by")
    ]
    public UserAnimeListOrderByEnum|Optional $orderBy;

    #[
        WithCast(EnumCast::class, UserAnimeListOrderByEnum::class),
        EnumValidation(UserAnimeListOrderByEnum::class),
        MapInputName("order_by2")
    ]
    public UserAnimeListOrderByEnum|Optional $orderBy2;

    #[
        WithCast(EnumCast::class, AnimeListAiringStatusFilterEnum::class),
        EnumValidation(AnimeListAiringStatusFilterEnum::class),
        MapInputName("airing_status")
    ]
    public AnimeListAiringStatusFilterEnum|Optional $airingStatus;

    #[Min(1500), Max(2999)]
    public int|Optional $year;

    #[Min(1)]
    public int|Optional $producer;

    #[
        BeforeOrEqual("aired_to"),
        DateFormat("Y-m-d"),
        Sometimes,
        Required,
        WithCast(DateTimeInterfaceCast::class),
        WithTransformer(DateTimeInterfaceTransformer::class),
        MapInputName("aired_from")
    ]
    public CarbonImmutable|Optional $airedFrom;

    #[
        AfterOrEqual("aired_from"),
        DateFormat("Y-m-d"),
        Sometimes,
        Required,
        WithCast(DateTimeInterfaceCast::class),
        WithTransformer(DateTimeInterfaceTransformer::class),
        MapInputName("aired_to")
    ]
    public CarbonImmutable|Optional $airedTo;

    public function toJikanParserRequest(): UserAnimeListRequest
    {
        $mapper = app(JikanUserListRequestMapperService::class);
        return $mapper->map($this, UserListTypeEnum::anime());
    }
}



================================================
FILE: app/Dto/QueryAnimeRecommendationsCommand.php
================================================
<?php

namespace App\Dto;


use App\Concerns\HasRequestFingerprint;
use App\Contracts\DataRequest;
use App\Http\Resources\V4\ResultsResource;
use Spatie\LaravelData\Data;

/**
 * @implements DataRequest<ResultsResource>
 */
final class QueryAnimeRecommendationsCommand extends Data implements DataRequest
{
    use HasRequestFingerprint;
}



================================================
FILE: app/Dto/QueryAnimeReviewsCommand.php
================================================
<?php

namespace App\Dto;

use App\Dto\Concerns\HasPreliminaryParameter;
use App\Dto\Concerns\HasSpoilersParameter;

final class QueryAnimeReviewsCommand extends QueryReviewsCommand
{
    use HasPreliminaryParameter, HasSpoilersParameter;
}



================================================
FILE: app/Dto/QueryAnimeSchedulesCommand.php
================================================
<?php

namespace App\Dto;

use App\Casts\EnumCast;
use App\Concerns\HasRequestFingerprint;
use App\Contracts\DataRequest;
use App\Dto\Concerns\HasKidsParameter;
use App\Dto\Concerns\HasLimitParameter;
use App\Dto\Concerns\HasPageParameter;
use App\Dto\Concerns\HasSfwParameter;
use App\Dto\Concerns\HasUnapprovedParameter;
use App\Dto\Concerns\MapsRouteParameters;
use App\Dto\Concerns\PreparesData;
use App\Enums\AnimeScheduleFilterEnum;
use App\Rules\Attributes\EnumValidation;
use Illuminate\Http\JsonResponse;
use Spatie\LaravelData\Attributes\WithCast;
use Spatie\LaravelData\Data;
use Spatie\LaravelData\Attributes\MapOutputName;

/**
 * @implements DataRequest<JsonResponse>
 */
final class QueryAnimeSchedulesCommand extends Data implements DataRequest
{
    use HasLimitParameter, HasRequestFingerprint, HasPageParameter, PreparesData, HasSfwParameter, HasKidsParameter, HasUnapprovedParameter, MapsRouteParameters;

    #[
        WithCast(EnumCast::class, AnimeScheduleFilterEnum::class),
        EnumValidation(AnimeScheduleFilterEnum::class)
    ]
    public ?AnimeScheduleFilterEnum $filter;
}



================================================
FILE: app/Dto/QueryAnimeSeasonCommand.php
================================================
<?php

namespace App\Dto;


use App\Casts\EnumCast;
use App\Concerns\HasRequestFingerprint;
use App\Contracts\DataRequest;
use App\Dto\Concerns\HasKidsParameter;
use App\Dto\Concerns\HasLimitParameter;
use App\Dto\Concerns\HasPageParameter;
use App\Dto\Concerns\HasSfwParameter;
use App\Dto\Concerns\HasUnapprovedParameter;
use App\Dto\Concerns\HasContinuingParameter;
use App\Enums\AnimeTypeEnum;
use App\Rules\Attributes\EnumValidation;
use Spatie\LaravelData\Attributes\WithCast;
use Spatie\LaravelData\Data;
use Spatie\LaravelData\Optional;


abstract class QueryAnimeSeasonCommand extends Data implements DataRequest
{
    use HasSfwParameter,
        HasKidsParameter,
        HasUnapprovedParameter,
        HasLimitParameter,
        HasRequestFingerprint,
        HasPageParameter,
        HasContinuingParameter;

    #[WithCast(EnumCast::class, AnimeTypeEnum::class), EnumValidation(AnimeTypeEnum::class)]
    public AnimeTypeEnum|Optional $filter;
}



================================================
FILE: app/Dto/QueryAnimeSeasonListCommand.php
================================================
<?php

namespace App\Dto;


use App\Concerns\HasRequestFingerprint;
use App\Contracts\DataRequest;
use Illuminate\Http\JsonResponse;
use Spatie\LaravelData\Data;

/**
 * @implements DataRequest<JsonResponse>
 */
final class QueryAnimeSeasonListCommand extends Data implements DataRequest
{
    use HasRequestFingerprint;
}



================================================
FILE: app/Dto/QueryCurrentAnimeSeasonCommand.php
================================================
<?php

namespace App\Dto;


final class QueryCurrentAnimeSeasonCommand extends QueryAnimeSeasonCommand
{
}



================================================
FILE: app/Dto/QueryListOfUserCommand.php
================================================
<?php

namespace App\Dto;


use App\Casts\EnumCast;
use App\Concerns\HasRequestFingerprint;
use App\Contracts\DataRequest;
use App\Dto\Concerns\HasPageParameter;
use App\Dto\Concerns\MapsRouteParameters;
use App\Enums\SortDirection;
use App\Rules\Attributes\EnumValidation;
use Illuminate\Http\JsonResponse;
use Spatie\LaravelData\Attributes\MapOutputName;
use Spatie\LaravelData\Attributes\Validation\Max;
use Spatie\LaravelData\Attributes\Validation\Min;
use Spatie\LaravelData\Attributes\WithCast;
use Spatie\LaravelData\Data;
use Spatie\LaravelData\Optional;

/**
 * @implements DataRequest<JsonResponse>
 */
abstract class QueryListOfUserCommand extends Data implements DataRequest
{
    use HasRequestFingerprint, HasPageParameter, MapsRouteParameters;

    #[Min(3)]
    public string $username;

    #[Max(255), MapOutputName("title")]
    public string|Optional $q;

    #[WithCast(EnumCast::class, SortDirection::class), EnumValidation(SortDirection::class)]
    public SortDirection|Optional $sort;
}



================================================
FILE: app/Dto/QueryMangaListOfUserCommand.php
================================================
<?php

namespace App\Dto;

use App\Casts\EnumCast;
use App\Enums\MangaListStatusEnum;
use App\Enums\UserListTypeEnum;
use App\Enums\UserMangaListOrderByEnum;
use App\Enums\UserMangaListStatusFilterEnum;
use App\Rules\Attributes\EnumValidation;
use App\Services\JikanUserListRequestMapperService;
use Carbon\CarbonImmutable;
use Jikan\Request\User\UserMangaListRequest;
use Spatie\LaravelData\Attributes\MapInputName;
use Spatie\LaravelData\Attributes\Validation\AfterOrEqual;
use Spatie\LaravelData\Attributes\Validation\BeforeOrEqual;
use Spatie\LaravelData\Attributes\Validation\DateFormat;
use Spatie\LaravelData\Attributes\Validation\Min;
use Spatie\LaravelData\Attributes\Validation\Required;
use Spatie\LaravelData\Attributes\Validation\Sometimes;
use Spatie\LaravelData\Attributes\WithCast;
use Spatie\LaravelData\Attributes\WithTransformer;
use Spatie\LaravelData\Casts\DateTimeInterfaceCast;
use Spatie\LaravelData\Optional;
use Spatie\LaravelData\Transformers\DateTimeInterfaceTransformer;

final class QueryMangaListOfUserCommand extends QueryListOfUserCommand
{
    #[WithCast(EnumCast::class, MangaListStatusEnum::class), EnumValidation(MangaListStatusEnum::class)]
    public MangaListStatusEnum|Optional $status;

    #[
        WithCast(EnumCast::class, UserMangaListOrderByEnum::class),
        MapInputName("order_by"),
        EnumValidation(UserMangaListOrderByEnum::class)
    ]
    public UserMangaListOrderByEnum|Optional $orderBy;

    #[
        WithCast(EnumCast::class, UserMangaListOrderByEnum::class),
        MapInputName("order_by2"),
        EnumValidation(UserMangaListOrderByEnum::class)
    ]
    public UserMangaListOrderByEnum|Optional $orderBy2;

    #[Min(1)]
    public int|Optional $magazine;

    #[
        BeforeOrEqual("published_to"),
        DateFormat("Y-m-d"),
        Sometimes,
        Required,
        WithCast(DateTimeInterfaceCast::class),
        WithTransformer(DateTimeInterfaceTransformer::class),
        MapInputName("published_from")
    ]
    public CarbonImmutable|Optional $publishedFrom;

    #[
        AfterOrEqual("published_from"),
        DateFormat("Y-m-d"),
        Sometimes,
        Required,
        WithCast(DateTimeInterfaceCast::class),
        WithTransformer(DateTimeInterfaceTransformer::class),
        MapInputName("published_to")
    ]
    public CarbonImmutable|Optional $publishedTo;

    #[
        WithCast(EnumCast::class, UserMangaListStatusFilterEnum::class),
        EnumValidation(UserMangaListStatusFilterEnum::class),
        MapInputName("publishing_status")
    ]
    public UserMangaListStatusFilterEnum|Optional $publishingStatus;


    public function toJikanParserRequest(): UserMangaListRequest
    {
        $mapper = app(JikanUserListRequestMapperService::class);
        return $mapper->map($this, UserListTypeEnum::manga());
    }
}



================================================
FILE: app/Dto/QueryMangaRecommendationsCommand.php
================================================
<?php

namespace App\Dto;


use App\Concerns\HasRequestFingerprint;
use App\Contracts\DataRequest;
use App\Http\Resources\V4\ResultsResource;
use Spatie\LaravelData\Data;

/**
 * @implements DataRequest<ResultsResource>
 */
final class QueryMangaRecommendationsCommand extends Data implements DataRequest
{
    use HasRequestFingerprint;
}



================================================
FILE: app/Dto/QueryMangaReviewsCommand.php
================================================
<?php

namespace App\Dto;

use App\Dto\Concerns\HasPreliminaryParameter;
use App\Dto\Concerns\HasSpoilersParameter;

final class QueryMangaReviewsCommand extends QueryReviewsCommand
{
    use HasPreliminaryParameter, HasSpoilersParameter;
}



================================================
FILE: app/Dto/QueryPopularEpisodesCommand.php
================================================
<?php

namespace App\Dto;


use App\Concerns\HasRequestFingerprint;
use App\Contracts\DataRequest;
use Illuminate\Http\JsonResponse;
use Spatie\LaravelData\Data;

/**
 * @implements DataRequest<JsonResponse>
 */
final class QueryPopularEpisodesCommand extends Data implements DataRequest
{
    use HasRequestFingerprint;
}



================================================
FILE: app/Dto/QueryPopularPromoVideosCommand.php
================================================
<?php

namespace App\Dto;


use App\Concerns\HasRequestFingerprint;
use App\Contracts\DataRequest;
use Illuminate\Http\JsonResponse;
use Spatie\LaravelData\Data;

/**
 * @implements DataRequest<JsonResponse>
 */
final class QueryPopularPromoVideosCommand extends Data implements DataRequest
{
    use HasRequestFingerprint;
}



================================================
FILE: app/Dto/QueryRandomAnimeCommand.php
================================================
<?php

namespace App\Dto;

use App\Contracts\DataRequest;
use App\Dto\Concerns\HasSfwParameter;
use App\Dto\Concerns\HasUnapprovedParameter;
use App\Http\Resources\V4\AnimeResource;
use Spatie\LaravelData\Data;

/**
 * @implements DataRequest<AnimeResource>
 */
final class QueryRandomAnimeCommand extends Data implements DataRequest
{
    use HasSfwParameter, HasUnapprovedParameter;
}



================================================
FILE: app/Dto/QueryRandomCharacterCommand.php
================================================
<?php

namespace App\Dto;

use App\Contracts\DataRequest;
use App\Http\Resources\V4\CharacterResource;
use Spatie\LaravelData\Data;

/**
 * @implements DataRequest<CharacterResource>
 */
final class QueryRandomCharacterCommand extends Data implements DataRequest
{
}



================================================
FILE: app/Dto/QueryRandomMangaCommand.php
================================================
<?php

namespace App\Dto;

use App\Contracts\DataRequest;
use App\Dto\Concerns\HasSfwParameter;
use App\Dto\Concerns\HasUnapprovedParameter;
use App\Http\Resources\V4\MangaResource;
use Spatie\LaravelData\Data;

/**
 * @implements DataRequest<MangaResource>
 */
final class QueryRandomMangaCommand extends Data implements DataRequest
{
    use HasSfwParameter, HasUnapprovedParameter;
}



================================================
FILE: app/Dto/QueryRandomPersonCommand.php
================================================
<?php

namespace App\Dto;

use App\Contracts\DataRequest;
use App\Http\Resources\V4\PersonResource;
use Spatie\LaravelData\Data;

/**
 * @implements DataRequest<PersonResource>
 */
final class QueryRandomPersonCommand extends Data implements DataRequest
{
}



================================================
FILE: app/Dto/QueryRandomUserCommand.php
================================================
<?php

namespace App\Dto;

use App\Contracts\DataRequest;
use App\Http\Resources\V4\ProfileResource;
use Spatie\LaravelData\Data;

/**
 * @implements DataRequest<ProfileResource>
 */
final class QueryRandomUserCommand extends Data implements DataRequest
{
}



================================================
FILE: app/Dto/QueryRecentlyAddedEpisodesCommand.php
================================================
<?php

namespace App\Dto;


use App\Concerns\HasRequestFingerprint;
use App\Contracts\DataRequest;
use Illuminate\Http\JsonResponse;
use Spatie\LaravelData\Data;

/**
 * @implements DataRequest<JsonResponse>
 */
final class QueryRecentlyAddedEpisodesCommand extends Data implements DataRequest
{
    use HasRequestFingerprint;
}



================================================
FILE: app/Dto/QueryRecentlyAddedPromoVideosCommand.php
================================================
<?php

namespace App\Dto;


use App\Concerns\HasRequestFingerprint;
use App\Contracts\DataRequest;
use App\Dto\Concerns\HasPageParameter;
use Illuminate\Http\JsonResponse;
use Spatie\LaravelData\Data;

/**
 * @implements DataRequest<JsonResponse>
 */
final class QueryRecentlyAddedPromoVideosCommand extends Data implements DataRequest
{
    use HasRequestFingerprint, HasPageParameter;
}



================================================
FILE: app/Dto/QueryRecentlyOnlineUsersCommand.php
================================================
<?php

namespace App\Dto;


use App\Contracts\DataRequest;
use Illuminate\Http\JsonResponse;
use Spatie\LaravelData\Data;

/**
 * @extends DataRequest<JsonResponse>
 */
final class QueryRecentlyOnlineUsersCommand extends Data implements DataRequest
{
}



================================================
FILE: app/Dto/QueryReviewsCommand.php
================================================
<?php

namespace App\Dto;


use App\Casts\ContextualBooleanCast;
use App\Casts\EnumCast;
use App\Concerns\HasRequestFingerprint;
use App\Contracts\DataRequest;
use App\Dto\Concerns\HasPageParameter;
use App\Dto\Concerns\HasPreliminaryParameter;
use App\Dto\Concerns\HasSpoilersParameter;
use App\Dto\Concerns\PreparesData;
use App\Enums\MediaReviewsSortEnum;
use App\Http\Resources\V4\ResultsResource;
use App\Rules\Attributes\EnumValidation;
use Spatie\LaravelData\Attributes\Validation\BooleanType;
use Spatie\LaravelData\Attributes\WithCast;
use Spatie\LaravelData\Data;
use Spatie\LaravelData\Optional;

/**
 * @implements DataRequest<ResultsResource>
 */
abstract class QueryReviewsCommand extends Data implements DataRequest
{
    use HasRequestFingerprint, HasPageParameter, HasPreliminaryParameter, HasSpoilersParameter, PreparesData;

    #[WithCast(EnumCast::class, MediaReviewsSortEnum::class), EnumValidation(MediaReviewsSortEnum::class)]
    public MediaReviewsSortEnum|Optional $sort;
}



================================================
FILE: app/Dto/QuerySpecificAnimeSeasonCommand.php
================================================
<?php

namespace App\Dto;

use App\Casts\EnumCast;
use App\Dto\Concerns\HasKidsParameter;
use App\Dto\Concerns\HasSfwParameter;
use App\Dto\Concerns\HasUnapprovedParameter;
use App\Dto\Concerns\MapsRouteParameters;
use App\Enums\AnimeSeasonEnum;
use App\Rules\Attributes\EnumValidation;
use Spatie\LaravelData\Attributes\Validation\Between;
use Spatie\LaravelData\Attributes\Validation\Required;
use Spatie\LaravelData\Attributes\WithCast;


final class QuerySpecificAnimeSeasonCommand extends QueryAnimeSeasonCommand
{
    use MapsRouteParameters, HasSfwParameter, HasKidsParameter, HasUnapprovedParameter;

    #[Required, Between(1000, 2999)]
    public int $year;

    #[WithCast(EnumCast::class, AnimeSeasonEnum::class), EnumValidation(AnimeSeasonEnum::class)]
    public AnimeSeasonEnum $season;

    protected static int $defaultLimit = 30;

    public static function messages(...$args): array
    {
        return [
            "season.enum" => "Invalid season supplied."
        ];
    }
}



================================================
FILE: app/Dto/QueryTopAnimeItemsCommand.php
================================================
<?php

namespace App\Dto;

use App\Casts\EnumCast;
use App\Contracts\DataRequest;
use App\Dto\Concerns\HasSfwParameter;
use App\Dto\Concerns\PreparesData;
use App\Enums\AnimeRatingEnum;
use App\Enums\AnimeTypeEnum;
use App\Enums\TopAnimeFilterEnum;
use App\Http\Resources\V4\AnimeCollection;
use App\Rules\Attributes\EnumValidation;
use Spatie\Enum\Laravel\Rules\EnumRule;
use Spatie\LaravelData\Attributes\WithCast;
use Spatie\LaravelData\Optional;

/**
 * @implements DataRequest<AnimeCollection>
 */
final class QueryTopAnimeItemsCommand extends QueryTopItemsCommand implements DataRequest
{
    use PreparesData, HasSfwParameter;

    #[WithCast(EnumCast::class, AnimeTypeEnum::class), EnumValidation(AnimeTypeEnum::class)]
    public AnimeTypeEnum|Optional $type;

    #[WithCast(EnumCast::class, AnimeRatingEnum::class), EnumValidation(AnimeRatingEnum::class)]
    public AnimeRatingEnum|Optional $rating;

    #[WithCast(EnumCast::class, TopAnimeFilterEnum::class), EnumValidation(TopAnimeFilterEnum::class)]
    public TopAnimeFilterEnum|Optional $filter;
}



================================================
FILE: app/Dto/QueryTopCharactersCommand.php
================================================
<?php

namespace App\Dto;

use App\Contracts\DataRequest;
use App\Http\Resources\V4\CharacterCollection;

/**
 * @implements DataRequest<CharacterCollection>
 */
final class QueryTopCharactersCommand extends QueryTopItemsCommand implements DataRequest
{
}



================================================
FILE: app/Dto/QueryTopItemsCommand.php
================================================
<?php

namespace App\Dto;

use App\Dto\Concerns\HasLimitParameter;
use App\Dto\Concerns\HasPageParameter;
use Spatie\LaravelData\Data;

abstract class QueryTopItemsCommand extends Data
{
    use HasLimitParameter, HasPageParameter;
}



================================================
FILE: app/Dto/QueryTopMangaItemsCommand.php
================================================
<?php

namespace App\Dto;

use App\Casts\EnumCast;
use App\Contracts\DataRequest;
use App\Dto\Concerns\HasSfwParameter;
use App\Dto\Concerns\PreparesData;
use App\Enums\MangaTypeEnum;
use App\Enums\TopMangaFilterEnum;
use App\Http\Resources\V4\MangaCollection;
use App\Rules\Attributes\EnumValidation;
use Spatie\Enum\Laravel\Rules\EnumRule;
use Spatie\LaravelData\Attributes\WithCast;
use Spatie\LaravelData\Optional;

/**
 * @implements DataRequest<MangaCollection>
 */
final class QueryTopMangaItemsCommand extends QueryTopItemsCommand implements DataRequest
{
    use PreparesData, HasSfwParameter;

    #[WithCast(EnumCast::class, MangaTypeEnum::class), EnumValidation(MangaTypeEnum::class)]
    public MangaTypeEnum|Optional $type;

    #[WithCast(EnumCast::class, TopMangaFilterEnum::class), EnumValidation(TopMangaFilterEnum::class)]
    public TopMangaFilterEnum|Optional $filter;
}



================================================
FILE: app/Dto/QueryTopPeopleCommand.php
================================================
<?php

namespace App\Dto;

use App\Contracts\DataRequest;
use App\Http\Resources\V4\PersonCollection;

/**
 * @implements DataRequest<PersonCollection>
 */
final class QueryTopPeopleCommand extends QueryTopItemsCommand implements DataRequest
{
}



================================================
FILE: app/Dto/QueryTopReviewsCommand.php
================================================
<?php

namespace App\Dto;

use App\Casts\EnumCast;
use App\Concerns\HasRequestFingerprint;
use App\Contracts\DataRequest;
use App\Dto\Concerns\HasPreliminaryParameter;
use App\Dto\Concerns\HasSpoilersParameter;
use App\Dto\Concerns\PreparesData;
use App\Enums\TopReviewsTypeEnum;
use App\Rules\Attributes\EnumValidation;
use Illuminate\Http\JsonResponse;
use Spatie\LaravelData\Attributes\WithCast;
use Spatie\LaravelData\Optional;

/**
 * @implements DataRequest<JsonResponse>
 */
final class QueryTopReviewsCommand extends QueryTopItemsCommand implements DataRequest
{
    use HasRequestFingerprint, HasPreliminaryParameter, HasSpoilersParameter, PreparesData;

    #[WithCast(EnumCast::class, TopReviewsTypeEnum::class), EnumValidation(TopReviewsTypeEnum::class)]
    public TopReviewsTypeEnum|Optional $type;
}



================================================
FILE: app/Dto/QueryUpcomingAnimeSeasonCommand.php
================================================
<?php

namespace App\Dto;

final class QueryUpcomingAnimeSeasonCommand extends QueryAnimeSeasonCommand
{
}



================================================
FILE: app/Dto/SearchCommand.php
================================================
<?php

namespace App\Dto;

use App\Casts\EnumCast;
use App\Dto\Concerns\HasLimitParameter;
use App\Dto\Concerns\HasPageParameter;
use App\Enums\SortDirection;
use App\Rules\Attributes\EnumValidation;
use Spatie\LaravelData\Attributes\Validation\Alpha;
use Spatie\LaravelData\Attributes\Validation\Max;
use Spatie\LaravelData\Attributes\Validation\Prohibits;
use Spatie\LaravelData\Attributes\Validation\Size;
use Spatie\LaravelData\Attributes\Validation\StringType;
use Spatie\LaravelData\Attributes\WithCast;
use Spatie\LaravelData\Data;
use Spatie\LaravelData\Optional;

class SearchCommand extends Data
{
    use HasLimitParameter, HasPageParameter;

    /**
     * The search keywords
     * @var string|Optional
     */
    #[Max(255), StringType]
    public string|Optional $q;

    #[WithCast(EnumCast::class, SortDirection::class), EnumValidation(SortDirection::class)]
    public SortDirection|Optional $sort;

    #[Size(1), StringType, Alpha, Prohibits("q")]
    public string|Optional $letter;
}



================================================
FILE: app/Dto/UserAboutLookupCommand.php
================================================
<?php

namespace App\Dto;


use Illuminate\Http\JsonResponse;

/**
 * @extends LookupDataCommand<JsonResponse>
 */
final class UserAboutLookupCommand extends LookupByUsernameCommand
{
}



================================================
FILE: app/Dto/UserByIdLookupCommand.php
================================================
<?php

namespace App\Dto;

use Illuminate\Http\JsonResponse;

/**
 * @extends LookupDataCommand<JsonResponse>
 */
final class UserByIdLookupCommand extends LookupDataCommand
{
}



================================================
FILE: app/Dto/UserClubsLookupCommand.php
================================================
<?php

namespace App\Dto;


use Illuminate\Http\JsonResponse;

/**
 * @extends LookupDataCommand<JsonResponse>
 */
final class UserClubsLookupCommand extends LookupByUsernameCommand
{
}



================================================
FILE: app/Dto/UserExternalLookupCommand.php
================================================
<?php

namespace App\Dto;


use Illuminate\Http\JsonResponse;

/**
 * @extends LookupDataCommand<JsonResponse>
 */
final class UserExternalLookupCommand extends LookupByUsernameCommand
{
}



================================================
FILE: app/Dto/UserFavoritesLookupCommand.php
================================================
<?php

namespace App\Dto;


use Illuminate\Http\JsonResponse;

/**
 * @extends LookupDataCommand<JsonResponse>
 */
final class UserFavoritesLookupCommand extends LookupByUsernameCommand
{
}



================================================
FILE: app/Dto/UserFriendsLookupCommand.php
================================================
<?php

namespace App\Dto;


use App\Dto\Concerns\HasPageParameter;
use Illuminate\Http\JsonResponse;

/**
 * @extends LookupDataCommand<JsonResponse>
 */
final class UserFriendsLookupCommand extends LookupByUsernameCommand
{
    use HasPageParameter;
}



================================================
FILE: app/Dto/UserFullLookupCommand.php
================================================
<?php

namespace App\Dto;


use Illuminate\Http\JsonResponse;

/**
 * @extends LookupDataCommand<JsonResponse>
 */
final class UserFullLookupCommand extends LookupByUsernameCommand
{
}



================================================
FILE: app/Dto/UserHistoryLookupCommand.php
================================================
<?php

namespace App\Dto;


use App\Casts\EnumCast;
use App\Enums\UserHistoryTypeEnum;
use App\Rules\Attributes\EnumValidation;
use Illuminate\Http\JsonResponse;
use Spatie\Enum\Laravel\Rules\EnumRule;
use Spatie\LaravelData\Attributes\Validation\Nullable;
use Spatie\LaravelData\Attributes\WithCast;

/**
 * @extends LookupDataCommand<JsonResponse>
 */
final class UserHistoryLookupCommand extends LookupByUsernameCommand
{
    #[WithCast(EnumCast::class, UserHistoryTypeEnum::class), EnumValidation(UserHistoryTypeEnum::class)]
    public ?UserHistoryTypeEnum $type;
}



================================================
FILE: app/Dto/UserProfileLookupCommand.php
================================================
<?php

namespace App\Dto;


use Illuminate\Http\JsonResponse;

/**
 * @extends LookupDataCommand<JsonResponse>
 */
final class UserProfileLookupCommand extends LookupByUsernameCommand
{
}



================================================
FILE: app/Dto/UserRecommendationsLookupCommand.php
================================================
<?php

namespace App\Dto;


use App\Dto\Concerns\HasPageParameter;
use Illuminate\Http\JsonResponse;

/**
 * @extends LookupDataCommand<JsonResponse>
 */
final class UserRecommendationsLookupCommand extends LookupByUsernameCommand
{
    use HasPageParameter;
}



================================================
FILE: app/Dto/UserReviewsLookupCommand.php
================================================
<?php

namespace App\Dto;


use App\Dto\Concerns\HasPageParameter;
use Illuminate\Http\JsonResponse;

/**
 * @extends LookupDataCommand<JsonResponse>
 */
final class UserReviewsLookupCommand extends LookupByUsernameCommand
{
    use HasPageParameter;
}



================================================
FILE: app/Dto/UsersSearchCommand.php
================================================
<?php

namespace App\Dto;

use App\Casts\EnumCast;
use App\Concerns\HasRequestFingerprint;
use App\Contracts\DataRequest;
use App\Enums\GenderEnum;
use App\Http\Resources\V4\UserCollection;
use App\Rules\Attributes\EnumValidation;
use Spatie\Enum\Laravel\Rules\EnumRule;
use Spatie\LaravelData\Attributes\Validation\StringType;
use Spatie\LaravelData\Attributes\WithCast;
use Spatie\LaravelData\Optional;

/**
 * @implements DataRequest<UserCollection>
 */
final class UsersSearchCommand extends SearchCommand implements DataRequest
{
    use HasRequestFingerprint;

    public int|Optional $minAge;

    public int|Optional $maxAge;

    #[WithCast(EnumCast::class, GenderEnum::class), EnumValidation(GenderEnum::class)]
    public GenderEnum|Optional $gender;

    #[StringType]
    public string|Optional $location;
}



================================================
FILE: app/Dto/UserStatisticsLookupCommand.php
================================================
<?php

namespace App\Dto;


use Illuminate\Http\JsonResponse;

/**
 * @extends LookupDataCommand<JsonResponse>
 */
final class UserStatisticsLookupCommand extends LookupByUsernameCommand
{
}



================================================
FILE: app/Dto/UserUpdatesLookupCommand.php
================================================
<?php

namespace App\Dto;


use Illuminate\Http\JsonResponse;

/**
 * @extends LookupDataCommand<JsonResponse>
 */
final class UserUpdatesLookupCommand extends LookupByUsernameCommand
{
}



================================================
FILE: app/Dto/Concerns/HasContinuingParameter.php
================================================
<?php

namespace App\Dto\Concerns;

use App\Casts\ContextualBooleanCast;
use OpenApi\Annotations as OA;
use Spatie\LaravelData\Attributes\Validation\BooleanType;
use Spatie\LaravelData\Attributes\WithCast;
use Spatie\LaravelData\Optional;

/**
 *  @OA\Parameter(
 *      name="continuing",
 *      in="query",
 *      required=false,
 *      description="This is a flag. When supplied it will include entries which are continuing from previous seasons. MAL includes these items on the seasons view in the &#8243;TV (continuing)&#8243; section. (Example: https://myanimelist.net/anime/season/2024/winter) <br />Example usage: `?continuing`",
 *      @OA\Schema(type="boolean")
 * ),
 */
trait HasContinuingParameter
{
    use PreparesData;

    #[BooleanType, WithCast(ContextualBooleanCast::class)]
    public bool|Optional $continuing = false;
}



================================================
FILE: app/Dto/Concerns/HasKidsParameter.php
================================================
<?php

namespace App\Dto\Concerns;

use App\Casts\ContextualBooleanCast;
use OpenApi\Annotations as OA;
use Spatie\LaravelData\Attributes\Validation\BooleanType;
use Spatie\LaravelData\Attributes\WithCast;
use Spatie\LaravelData\Optional;

/**
 *  @OA\Parameter(
 *      name="kids",
 *      in="query",
 *      required=false,
 *      description="This is a flag. When supplied it will include entries with the Kids genres in specific endpoints that filter them out by default. You do not need to pass a value to it. e.g usage: `?kids`",
 *      @OA\Schema(type="boolean")
 * ),
 */
trait HasKidsParameter
{
    use PreparesData;

    #[BooleanType, WithCast(ContextualBooleanCast::class)]
    public bool|Optional $kids;
}



================================================
FILE: app/Dto/Concerns/HasLimitParameter.php
================================================
<?php

namespace App\Dto\Concerns;

use App\Rules\Attributes\MaxLimitWithFallback;
use OpenApi\Annotations as OA;
use Spatie\LaravelData\Attributes\Validation\IntegerType;
use Spatie\LaravelData\Attributes\Validation\Min;
use Spatie\LaravelData\Optional;


/**
 *  @OA\Parameter(
 *    name="limit",
 *    in="query",
 *    @OA\Schema(type="integer")
 *  ),
 */
trait HasLimitParameter
{
    use PreparesData;

    #[IntegerType, Min(1), MaxLimitWithFallback]
    public int|Optional $limit;
}



================================================
FILE: app/Dto/Concerns/HasPageParameter.php
================================================
<?php

namespace App\Dto\Concerns;

use OpenApi\Annotations as OA;
use Spatie\LaravelData\Attributes\Validation\Min;
use Spatie\LaravelData\Attributes\Validation\Numeric;
use Spatie\LaravelData\Optional;

/**
 *  @OA\Parameter(
 *    name="page",
 *    in="query",
 *    @OA\Schema(type="integer")
 *  ),
 */
trait HasPageParameter
{
    #[Numeric, Min(1)]
    public int|Optional $page = 1;
}



================================================
FILE: app/Dto/Concerns/HasPreliminaryParameter.php
================================================
<?php

namespace App\Dto\Concerns;

use App\Casts\ContextualBooleanCast;
use OpenApi\Annotations as OA;
use Spatie\LaravelData\Attributes\Validation\BooleanType;
use Spatie\LaravelData\Attributes\WithCast;
use Spatie\LaravelData\Optional;

/**
 *  @OA\Parameter(
 *      name="preliminary",
 *      in="query",
 *      required=false,
 *      description="Any reviews left during an ongoing anime/manga, those reviews are tagged as preliminary. NOTE: Preliminary reviews are not returned by default so if the entry is airing/publishing you need to add this otherwise you will get an empty list. e.g usage: `?preliminary=true`",
 *      @OA\Schema(type="boolean")
 * ),
 */
trait HasPreliminaryParameter
{
    use PreparesData;

    #[BooleanType, WithCast(ContextualBooleanCast::class)]
    public bool|Optional $preliminary;
}



================================================
FILE: app/Dto/Concerns/HasSfwParameter.php
================================================
<?php

namespace App\Dto\Concerns;

use App\Casts\ContextualBooleanCast;
use OpenApi\Annotations as OA;
use Spatie\LaravelData\Attributes\Validation\BooleanType;
use Spatie\LaravelData\Attributes\WithCast;
use Spatie\LaravelData\Optional;

/**
 *  @OA\Parameter(
 *      name="sfw",
 *      in="query",
 *      required=false,
 *      description="'Safe For Work'. This is a flag. When supplied it will filter out entries according to the SFW Policy. You do not need to pass a value to it. e.g usage: `?sfw`",
 *      @OA\Schema(type="boolean")
 * ),
 */
trait HasSfwParameter
{
    use PreparesData;

    #[BooleanType, WithCast(ContextualBooleanCast::class)]
    public bool|Optional $sfw = false;
}



================================================
FILE: app/Dto/Concerns/HasSpoilersParameter.php
================================================
<?php

namespace App\Dto\Concerns;

use App\Casts\ContextualBooleanCast;
use OpenApi\Annotations as OA;
use Spatie\LaravelData\Attributes\Validation\BooleanType;
use Spatie\LaravelData\Attributes\WithCast;
use Spatie\LaravelData\Optional;

/**
 *  @OA\Parameter(
 *      name="spoilers",
 *      in="query",
 *      required=false,
 *      description="Any reviews that are tagged as a spoiler. Spoiler reviews are not returned by default. e.g usage: `?spoiler=true`",
 *      @OA\Schema(type="boolean")
 * ),
 */
trait HasSpoilersParameter
{
    use PreparesData;

    #[BooleanType, WithCast(ContextualBooleanCast::class)]
    public bool|Optional $spoilers;
}



================================================
FILE: app/Dto/Concerns/HasUnapprovedParameter.php
================================================
<?php

namespace App\Dto\Concerns;

use App\Casts\ContextualBooleanCast;
use OpenApi\Annotations as OA;
use Spatie\LaravelData\Attributes\Validation\BooleanType;
use Spatie\LaravelData\Attributes\WithCast;
use Spatie\LaravelData\Optional;

/**
 *  @OA\Parameter(
 *      name="unapproved",
 *      in="query",
 *      required=false,
 *      description="This is a flag. When supplied it will include entries which are unapproved. Unapproved entries on MyAnimeList are those that are user submitted and have not yet been approved by MAL to show up on other pages. They will have their own specifc pages and are often removed resulting in a 404 error. You do not need to pass a value to it. e.g usage: `?unapproved`",
 *      @OA\Schema(type="boolean")
 * ),
 */
trait HasUnapprovedParameter
{
    use PreparesData;

    #[BooleanType, WithCast(ContextualBooleanCast::class)]
    public bool|Optional $unapproved = false;
}



================================================
FILE: app/Dto/Concerns/MapsRouteParameters.php
================================================
<?php

namespace App\Dto\Concerns;

use App\DataPipes\MapRouteParametersDataPipe;
use Spatie\LaravelData\DataPipeline;
use Spatie\LaravelData\DataPipes\AuthorizedDataPipe;
use Spatie\LaravelData\DataPipes\CastPropertiesDataPipe;
use Spatie\LaravelData\DataPipes\DefaultValuesDataPipe;
use Spatie\LaravelData\DataPipes\MapPropertiesDataPipe;
use Spatie\LaravelData\DataPipes\ValidatePropertiesDataPipe;

trait MapsRouteParameters
{
    public static function pipeline(): DataPipeline
    {
        return DataPipeline::create()
            ->into(static::class)
            ->through(AuthorizedDataPipe::class)
            ->through(MapPropertiesDataPipe::class)
            ->through(MapRouteParametersDataPipe::class) // if a payload is a request object, we map route params
            ->through(ValidatePropertiesDataPipe::class)
            ->through(DefaultValuesDataPipe::class)
            ->through(CastPropertiesDataPipe::class);
    }
}



================================================
FILE: app/Dto/Concerns/PreparesData.php
================================================
<?php

namespace App\Dto\Concerns;

use Illuminate\Support\Collection;
use Spatie\LaravelData\Support\DataConfig;
use Spatie\LaravelData\Support\DataProperty;

/**
 * A trait for preparing the incoming data before passing it through the data pipeline.
 * All preparation logic lives here.
 * https://spatie.be/docs/laravel-data/v3/advanced-usage/pipeline
 */
trait PreparesData
{
    public static function prepareForPipeline(Collection $properties): Collection
    {
        // let's always set the limit parameter to the globally configured default value
        if (property_exists(static::class, "limit") && !$properties->has("limit")) {
            $properties->put("limit", max_results_per_page(
                property_exists(static::class, "defaultLimit") ? static::$defaultLimit : null));
        }

        // we want to cast "true" and "false" string values to boolean before validation, so let's take all properties
        // of the class which are bool or bool|Optional type, and using their name read the values from the incoming
        // collection, and if they are present have such a value, convert them.
        $dataClass = app(DataConfig::class)->getDataClass(static::class);
        foreach ($dataClass->properties as $property) {
            /**
             * @var DataProperty $property
             */
            // the name can be different in the $properties variable, so let's check if there is an input name mapping
            // for the property and use that instead if present.
            $propertyRawName = $property->inputMappedName ?? $property->name;
            if ($properties->has($propertyRawName)) {
                $propertyVal = $properties->get($propertyRawName);
                if ($property->type->acceptsType("bool")) {
                    if ($propertyVal === "true") {
                        $propertyVal = true;
                    }
                    if ($propertyVal === "false") {
                        $propertyVal = false;
                    }
                }
                // if the property is optional and the value is an empty string, we want to ignore it.
                if ($property->type->isOptional && $propertyVal === "" && !$property->type->acceptsType("bool")) {
                    $propertyVal = null;
                }

                if (!is_null($propertyVal)) {
                    $properties->put($propertyRawName, $propertyVal);
                } else {
                    $properties->forget($propertyRawName);
                }
            }
        }

        return $properties;
    }
}



================================================
FILE: app/Enums/AnimeForumFilterEnum.php
================================================
<?php

namespace App\Enums;

use Spatie\Enum\Laravel\Enum;

/**
 * @method static self all()
 * @method static self episode()
 * @method static self other()
 */
final class AnimeForumFilterEnum extends Enum
{
}



================================================
FILE: app/Enums/AnimeListAiringStatusFilterEnum.php
================================================
<?php

namespace App\Enums;


use Spatie\Enum\Laravel\Enum;
use Jikan\Helper\Constants as JikanConstants;

/**
 * @method static self airing()
 * @method static self finished()
 * @method static self complete()
 * @method static self to_be_aired()
 * @method static self not_yet_aired()
 * @method static self tba()
 * @method static self nya()
 */
final class AnimeListAiringStatusFilterEnum extends Enum
{
    protected static function labels()
    {
        return [
            'airing' => JikanConstants::USER_ANIME_LIST_CURRENTLY_AIRING,
            'finished' => JikanConstants::USER_ANIME_LIST_FINISHED_AIRING,
            'complete' => JikanConstants::USER_ANIME_LIST_FINISHED_AIRING,
            'to_be_aired' => JikanConstants::USER_ANIME_LIST_NOT_YET_AIRED,
            'not_yet_aired' => JikanConstants::USER_ANIME_LIST_NOT_YET_AIRED,
            'tba' => JikanConstants::USER_ANIME_LIST_NOT_YET_AIRED,
            'nya' => JikanConstants::USER_ANIME_LIST_NOT_YET_AIRED,
        ];
    }
}



================================================
FILE: app/Enums/AnimeListStatusEnum.php
================================================
<?php

namespace App\Enums;


use Spatie\Enum\Laravel\Enum;

/**
 * @method static self all()
 * @method static self watching()
 * @method static self completed()
 * @method static self onhold()
 * @method static self dropped()
 * @method static self plantowatch()
 *
 * @OA\Schema(
 *   schema="user_anime_list_status_filter",
 *   description="User's anime list status filter options",
 *   type="string",
 *   enum={"all", "watching", "completed", "onhold", "dropped", "plantowatch"}
 * )
 */
final class AnimeListStatusEnum extends Enum
{
    // labels will be the values used for mapping, meanwhile the values are the names of the enum elements,
    // because these are getting passed in through the query string in requests, and we validate against them
    protected static function labels(): array
    {
        return [
            "all" => "7",
            "watching" => "1",
            "completed" => "2",
            "onhold" => "3",
            "dropped" => "4",
            "plantowatch" => "6"
        ];
    }
}



================================================
FILE: app/Enums/AnimeOrderByEnum.php
================================================
<?php

namespace App\Enums;

use Spatie\Enum\Laravel\Enum;

/**
 * @method static self mal_id()
 * @method static self title()
 * @method static self start_date()
 * @method static self end_date()
 * @method static self episodes()
 * @method static self score()
 * @method static self scored_by()
 * @method static self rank()
 * @method static self popularity()
 * @method static self members()
 * @method static self favorites()
 *
 * @OA\Schema(
 *   schema="anime_search_query_orderby",
 *   description="Available Anime order_by properties",
 *   type="string",
 *   enum={"mal_id", "title", "start_date", "end_date", "episodes", "score", "scored_by", "rank", "popularity", "members", "favorites" }
 * )
 */
final class AnimeOrderByEnum extends Enum
{
    protected static function labels(): array
    {
        return [
            'start_date' => 'aired.from',
            'end_date' => 'aired.to',
        ];
    }
}



================================================
FILE: app/Enums/AnimeRatingEnum.php
================================================
<?php

namespace App\Enums;

use Spatie\Enum\Laravel\Enum;

/**
 * @method static self g()
 * @method static self pg()
 * @method static self pg13()
 * @method static self r17()
 * @method static self r()
 * @method static self rx()
 *
 * @OA\Schema(
 *   schema="anime_search_query_rating",
 *   description="Available Anime audience ratings<br><br><b>Ratings</b><br><ul><li>G - All Ages</li><li>PG - Children</li><li>PG-13 - Teens 13 or older</li><li>R - 17+ (violence & profanity)</li><li>R+ - Mild Nudity</li><li>Rx - Hentai</li></ul>",
 *   type="string",
 *   enum={"g","pg","pg13","r17","r","rx"}
 * )
 */
final class AnimeRatingEnum extends Enum
{
    protected static function labels(): array
    {
        return [
            "g" => "G - All Ages",
            "pg" => "PG - Children",
            "pg13" => "PG-13 - Teens 13 or older",
            "r17" => "R - 17+ (violence & profanity)",
            "r" => "R+ - Mild Nudity",
            "rx" => "Rx - Hentai"
        ];
    }
}



================================================
FILE: app/Enums/AnimeScheduleFilterEnum.php
================================================
<?php

namespace App\Enums;


use Spatie\Enum\Laravel\Enum;

/**
 * @method static self monday()
 * @method static self tuesday()
 * @method static self wednesday()
 * @method static self thursday()
 * @method static self friday()
 * @method static self saturday()
 * @method static self sunday()
 * @method static self other()
 * @method static self unknown()
 */
final class AnimeScheduleFilterEnum extends Enum
{
    public function isWeekDay(): bool
    {
        return $this->value !== self::other()->value && $this->value !== self::unknown()->value;
    }

    protected static function labels(): array
    {
        return [
            ...collect(self::values())->map(fn ($x) => ucfirst($x))->toArray(),
            "other" => "Not scheduled once per week",
            "unknown" => "Unknown"
        ];
    }
}



================================================
FILE: app/Enums/AnimeSeasonEnum.php
================================================
<?php

namespace App\Enums;


use Spatie\Enum\Laravel\Enum;

/**
 * @method static self summer()
 * @method static self spring()
 * @method static self winter()
 * @method static self fall()
 */
final class AnimeSeasonEnum extends Enum
{
    protected static function labels(): array
    {
        $labels = [];
        foreach (self::values() as $value) {
            $labels[$value] = ucfirst($value);
        }

        return $labels;
    }
}



================================================
FILE: app/Enums/AnimeStatusEnum.php
================================================
<?php

namespace App\Enums;
use Spatie\Enum\Laravel\Enum;

/**
 * @method static self airing()
 * @method static self complete()
 * @method static self upcoming()
 *
 * @OA\Schema(
 *   schema="anime_search_query_status",
 *   description="Available Anime statuses",
 *   type="string",
 *   enum={"airing","complete","upcoming"}
 * )
 */
final class AnimeStatusEnum extends Enum
{
    protected static function labels(): array
    {
        return [
            "airing" => "Currently Airing",
            "complete" => "Finished Airing",
            "upcoming" => "Not yet aired",
        ];
    }
}



================================================
FILE: app/Enums/AnimeTypeEnum.php
================================================
<?php

namespace App\Enums;

use Spatie\Enum\Laravel\Enum;

/**
 * @method static self tv()
 * @method static self movie()
 * @method static self ova()
 * @method static self special()
 * @method static self ona()
 * @method static self music()
 * @method static self cm()
 * @method static self pv()
 * @method static self tv_special()
 *
 * @OA\Schema(
 *   schema="anime_search_query_type",
 *   description="Available Anime types",
 *   type="string",
 *   enum={"tv","movie","ova","special","ona","music","cm","pv","tv_special"}
 * )
 */
final class AnimeTypeEnum extends Enum
{
    protected static function labels(): array
    {
        return [
            'tv' => 'TV',
            'movie' => 'Movie',
            'ova' => 'OVA',
            'special' => 'Special',
            'ona' => 'ONA',
            'music' => 'Music',
            'cm' => 'CM',
            'pv' => 'PV',
            'tv_special' => 'TV Special'
        ];
    }
}



================================================
FILE: app/Enums/CharacterOrderByEnum.php
================================================
<?php

namespace App\Enums;

use Spatie\Enum\Laravel\Enum;

/**
 * @method static self mal_id()
 * @method static self name()
 * @method static self favorites()
 *
 * @OA\Schema(
 *   schema="characters_search_query_orderby",
 *   description="Available Character order_by properties",
 *   type="string",
 *   enum={"mal_id", "name", "favorites"}
 * )
 */
final class CharacterOrderByEnum extends Enum
{
    protected static function labels(): array
    {
        return [
            "favorites" => "member_favorites"
        ];
    }
}



================================================
FILE: app/Enums/ClubCategoryEnum.php
================================================
<?php

namespace App\Enums;

use Spatie\Enum\Laravel\Enum;

/**
 * @method static self anime()
 * @method static self manga()
 * @method static self actors_and_artists()
 * @method static self characters()
 * @method static self cities_and_neighborhoods()
 * @method static self companies()
 * @method static self conventions()
 * @method static self games()
 * @method static self japan()
 * @method static self music()
 * @method static self other()
 * @method static self schools()
 *
 * @OA\Schema(
 *   schema="club_search_query_category",
 *   description="Club Search Query Category",
 *   type="string",
 *   enum={
 *      "anime","manga","actors_and_artists","characters",
 *      "cities_and_neighborhoods","companies","conventions","games",
 *      "japan","music","other","schools"
 *   }
 * )
 */
final class ClubCategoryEnum extends Enum
{
    protected static function labels(): array
    {
        return [
            'anime' => 'Anime',
            'manga' => 'Manga',
            'actors_and_artists' => 'Actors & Artists',
            'characters' => 'Characters',
            'cities_and_neighborhoods' => 'Cities & Neighborhoods',
            'companies' => 'Companies',
            'conventions' => 'Conventions',
            'games' => 'Games',
            'japan' => 'Japan',
            'music' => 'Music',
            'other' => 'Other',
            'schools' => 'Schools'
        ];
    }
}



================================================
FILE: app/Enums/ClubOrderByEnum.php
================================================
<?php

namespace App\Enums;

use Spatie\Enum\Laravel\Enum;

/**
 * @method static self mal_id()
 * @method static self name()
 * @method static self members_count()
 * @method static self created()
 *
 * @OA\Schema(
 *   schema="club_search_query_orderby",
 *   description="Club Search Query OrderBy",
 *   type="string",
 *   enum={"mal_id","name","members_count","created"}
 * )
 */
final class ClubOrderByEnum extends Enum
{
    protected static function labels(): array
    {
        return [
            "members_count" => "members"
        ];
    }
}



================================================
FILE: app/Enums/ClubTypeEnum.php
================================================
<?php

namespace App\Enums;

use Spatie\Enum\Laravel\Enum;

/**
 * @method static self public()
 * @method static self private()
 * @method static self secret()
 *
 * @OA\Schema(
 *   schema="club_search_query_type",
 *   description="Club Search Query Type",
 *   type="string",
 *   enum={"public","private","secret"}
 * )
 */
final class ClubTypeEnum extends Enum
{
}



================================================
FILE: app/Enums/GenderEnum.php
================================================
<?php

namespace App\Enums;

use Jikan\Helper\Constants as JikanConstants;
use Spatie\Enum\Laravel\Enum;

/**
 * @method static self any()
 * @method static self male()
 * @method static self female()
 * @method static self nonbinary()
 * @OA\Schema(
 *   schema="users_search_query_gender",
 *   description="Users Search Query Gender.",
 *   type="string",
 *   enum={"any","male","female","nonbinary"}
 * )
 */
final class GenderEnum extends Enum
{
    protected static function labels(): array
    {
        return [
            'any' => JikanConstants::SEARCH_USER_GENDER_ANY,
            'male' => JikanConstants::SEARCH_USER_GENDER_MALE,
            'female' => JikanConstants::SEARCH_USER_GENDER_FEMALE,
            'nonbinary' => JikanConstants::SEARCH_USER_GENDER_NONBINARY
        ];
    }
}



================================================
FILE: app/Enums/GenreFilterEnum.php
================================================
<?php

namespace App\Enums;

use Spatie\Enum\Laravel\Enum;

/**
 * @method static self genres()
 * @method static self explicit_genres()
 * @method static self themes()
 * @method static self demographics()
 *
 * @OA\Schema(
 *    schema="genre_query_filter",
 *    description="Filter genres by type",
 *    type="string",
 *    enum={"genres","explicit_genres", "themes", "demographics"}
 *  )
 */
final class GenreFilterEnum extends Enum
{
}



================================================
FILE: app/Enums/MagazineOrderByEnum.php
================================================
<?php

namespace App\Enums;

use Spatie\Enum\Laravel\Enum;

/**
 * @method static self mal_id()
 * @method static self name()
 * @method static self count()
 *
 * @OA\Schema(
 *    schema="magazines_query_orderby",
 *    description="Order by magazine data",
 *    type="string",
 *    enum={"mal_id", "name", "count"}
 *  )
 */
final class MagazineOrderByEnum extends Enum
{
}



================================================
FILE: app/Enums/MangaForumFilterEnum.php
================================================
<?php

namespace App\Enums;


use Spatie\Enum\Laravel\Enum;

/**
 * @method static self all()
 * @method static self chapters()
 * @method static self other()
 */
final class MangaForumFilterEnum extends Enum
{
}



================================================
FILE: app/Enums/MangaListStatusEnum.php
================================================
<?php

namespace App\Enums;


use Spatie\Enum\Laravel\Enum;

/**
 * @method static self all()
 * @method static self reading()
 * @method static self completed()
 * @method static self onhold()
 * @method static self dropped()
 * @method static self plantoread()
 *
 * @OA\Schema(
 *   schema="user_manga_list_status_filter",
 *   description="User's anime list status filter options",
 *   type="string",
 *   enum={"all", "reading", "completed", "onhold", "dropped", "plantoread"}
 * )
 */
final class MangaListStatusEnum extends Enum
{
    // labels will be the values used for mapping, meanwhile the values are the names of the enum elements,
    // because these are getting passed in through the query string in requests, and we validate against them
    protected static function labels(): array
    {
        return [
            "all" => "7",
            "reading" => "1",
            "completed" => "2",
            "onhold" => "3",
            "dropped" => "4",
            "plantoread" => "6"
        ];
    }
}



================================================
FILE: app/Enums/MangaOrderByEnum.php
================================================
<?php

namespace App\Enums;

use Spatie\Enum\Laravel\Enum;

/**
 * @method static self mal_id()
 * @method static self title()
 * @method static self start_date()
 * @method static self end_date()
 * @method static self chapters()
 * @method static self volumes()
 * @method static self score()
 * @method static self scored_by()
 * @method static self rank()
 * @method static self popularity()
 * @method static self members()
 * @method static self favorites()
 *
 * @OA\Schema(
 *   schema="manga_search_query_orderby",
 *   description="Available Manga order_by properties",
 *   type="string",
 *   enum={"mal_id", "title", "start_date", "end_date", "chapters", "volumes", "score", "scored_by", "rank", "popularity", "members", "favorites"}
 * )
 */
final class MangaOrderByEnum extends Enum
{
    protected static function labels(): array
    {
        return [
            'start_date' => 'published.from',
            'end_date' => 'published.to'
        ];
    }
}



================================================
FILE: app/Enums/MangaStatusEnum.php
================================================
<?php

namespace App\Enums;

use Spatie\Enum\Laravel\Enum;

/**
 * @method static self publishing()
 * @method static self complete()
 * @method static self hiatus()
 * @method static self discontinued()
 * @method static self upcoming()
 *
 * @OA\Schema(
 *   schema="manga_search_query_status",
 *   description="Available Manga statuses",
 *   type="string",
 *   enum={"publishing","complete","hiatus","discontinued","upcoming"}
 * )
 */
final class MangaStatusEnum extends Enum
{
    protected static function labels(): array
    {
        return [
            "publishing" => "Publishing",
            "complete" => "Finished",
            "hiatus" => "On Hiatus",
            "discontinued" => "Discontinued",
            "upcoming" => "Not yet published"
        ];
    }
}



================================================
FILE: app/Enums/MangaTypeEnum.php
================================================
<?php

namespace App\Enums;

use Spatie\Enum\Laravel\Enum;

/**
 * @method static self manga()
 * @method static self novel()
 * @method static self lightnovel()
 * @method static self oneshot()
 * @method static self doujin()
 * @method static self manhwa()
 * @method static self manhua()
 *
 * @OA\Schema(
 *   schema="manga_search_query_type",
 *   description="Available Manga types",
 *   type="string",
 *   enum={"manga","novel", "lightnovel", "oneshot","doujin","manhwa","manhua"}
 * )
 */
final class MangaTypeEnum extends Enum
{
    protected static function labels(): array
    {
        return [
            'manga' => 'Manga',
            'novel' => 'Novel',
            'lightnovel' => 'Light Novel',
            'oneshot' => 'One-shot',
            'doujin' => 'Doujinshi',
            'manhwa' => 'Manhwa',
            'manhua' => 'Manhua'
        ];
    }
}



================================================
FILE: app/Enums/MediaReviewsSortEnum.php
================================================
<?php

namespace App\Enums;

use Jikan\Helper\Constants;
use Spatie\Enum\Laravel\Enum;

/**
 * @method static self mostVoted()
 * @method static self newest()
 * @method static self oldest()
 */
final class MediaReviewsSortEnum extends Enum
{
    protected static function labels(): array
    {
        return [
            "mostVoted" => Constants::REVIEWS_SORT_MOST_VOTED,
            "newest" => Constants::REVIEWS_SORT_NEWEST,
            "oldest" => Constants::REVIEWS_SORT_OLDEST,
            "suggested" => "suggested",
        ];
    }
}



================================================
FILE: app/Enums/PeopleOrderByEnum.php
================================================
<?php

namespace App\Enums;

use Spatie\Enum\Laravel\Enum;

/**
 * @method static self mal_id()
 * @method static self name()
 * @method static self birthday()
 * @method static self favorites()
 *
 * @OA\Schema(
 *   schema="people_search_query_orderby",
 *   description="Available People order_by properties",
 *   type="string",
 *   enum={"mal_id", "name", "birthday", "favorites"}
 * )
 */
final class PeopleOrderByEnum extends Enum
{
    protected static function labels()
    {
        return [
            "favorites" => "member_favorites"
        ];
    }
}



================================================
FILE: app/Enums/ProducerOrderByEnum.php
================================================
<?php

namespace App\Enums;

use Spatie\Enum\Laravel\Enum;

/**
 * @method static self mal_id()
 * @method static self count()
 * @method static self favorites()
 * @method static self established()
 *
 * @OA\Schema(
 *   schema="producers_query_orderby",
 *   description="Producers Search Query Order By",
 *   type="string",
 *   enum={"mal_id", "count", "favorites", "established"}
 * )
 */
final class ProducerOrderByEnum extends Enum
{
}



================================================
FILE: app/Enums/ReviewTypeEnum.php
================================================
<?php

namespace App\Enums;


use Spatie\Enum\Laravel\Enum;

/**
 * @method static self anime()
 * @method static self manga()
 */
final class ReviewTypeEnum extends Enum
{
}



================================================
FILE: app/Enums/SortDirection.php
================================================
<?php

namespace App\Enums;
use Spatie\Enum\Laravel\Enum;

/**
 * @method static self asc()
 * @method static self desc()
 *
 * @OA\Schema(
 *   schema="search_query_sort",
 *   description="Search query sort direction",
 *   type="string",
 *   enum={"desc","asc"}
 * )
 */
final class SortDirection extends Enum
{
}



================================================
FILE: app/Enums/TopAnimeFilterEnum.php
================================================
<?php

namespace App\Enums;

use Spatie\Enum\Laravel\Enum;

/**
 * @method static self airing()
 * @method static self upcoming()
 * @method static self bypopularity()
 * @method static self favorite()
 *
 * @OA\Schema(
 *   schema="top_anime_filter",
 *   description="Top items filter types",
 *   type="string",
 *   enum={"airing","upcoming","bypopularity","favorite"}
 * )
 */
final class TopAnimeFilterEnum extends Enum
{
}



================================================
FILE: app/Enums/TopMangaFilterEnum.php
================================================
<?php

namespace App\Enums;

use Spatie\Enum\Laravel\Enum;

/**
 * @method static self publishing()
 * @method static self upcoming()
 * @method static self bypopularity()
 * @method static self favorite()
 *
 * @OA\Schema(
 *   schema="top_manga_filter",
 *   description="Top items filter types",
 *   type="string",
 *   enum={"publishing","upcoming","bypopularity","favorite"}
 * )
 */
final class TopMangaFilterEnum extends Enum
{
}



================================================
FILE: app/Enums/TopReviewsTypeEnum.php
================================================
<?php

namespace App\Enums;


use Spatie\Enum\Laravel\Enum;

/**
 * @method static self anime()
 * @method static self manga()
 * @OA\Schema(
 *   schema="top_reviews_type_enum",
 *   description="The type of reviews to filter by. Defaults to anime.",
 *   type="string",
 *   enum={"anime","manga"}
 * )
 */
final class TopReviewsTypeEnum extends Enum
{
}



================================================
FILE: app/Enums/UserAnimeListOrderByEnum.php
================================================
<?php

namespace App\Enums;


use Spatie\Enum\Laravel\Enum;
use Jikan\Helper\Constants as JikanConstants;

/**
 * @method static self title()
 * @method static self started_date()
 * @method static self score()
 * @method static self last_updated()
 * @method static self type()
 * @method static self rated()
 * @method static self rewatch_value()
 * @method static self priority()
 * @method static self episodes_watched()
 * @method static self storage()
 * @method static self air_start()
 * @method static self air_end()
 * @method static self status()
 */
final class UserAnimeListOrderByEnum extends Enum
{
    // labels will be the values used for mapping, meanwhile the values are the names of the enum elements,
    // because these are getting passed in through the query string in requests, and we validate against them
    protected static function labels(): array
    {
        return [
            'title' => JikanConstants::USER_ANIME_LIST_ORDER_BY_TITLE,
            'finished_date' => JikanConstants::USER_ANIME_LIST_ORDER_BY_FINISHED_DATE,
            'started_date' => JikanConstants::USER_ANIME_LIST_ORDER_BY_STARTED_DATE,
            'score' => JikanConstants::USER_ANIME_LIST_ORDER_BY_SCORE,
            'last_updated' => JikanConstants::USER_ANIME_LIST_ORDER_BY_LAST_UPDATED,
            'type' => JikanConstants::USER_ANIME_LIST_ORDER_BY_TYPE,
            'rated' => JikanConstants::USER_ANIME_LIST_ORDER_BY_RATED,
            'rewatch_value' => JikanConstants::USER_ANIME_LIST_ORDER_BY_REWATCH_VALUE,
            'priority' => JikanConstants::USER_ANIME_LIST_ORDER_BY_PRIORITY,
            'episodes_watched' => JikanConstants::USER_ANIME_LIST_ORDER_BY_PROGRESS,
            'storage' => JikanConstants::USER_ANIME_LIST_ORDER_BY_STORAGE,
            'air_start' => JikanConstants::USER_ANIME_LIST_ORDER_BY_AIR_START,
            'air_end' => JikanConstants::USER_ANIME_LIST_ORDER_BY_AIR_END,
            'status' => JikanConstants::USER_ANIME_LIST_ORDER_BY_STATUS,
        ];
    }
}



================================================
FILE: app/Enums/UserHistoryTypeEnum.php
================================================
<?php

namespace App\Enums;


use Spatie\Enum\Laravel\Enum;

/**
 * @method static self anime()
 * @method static self manga()
 */
final class UserHistoryTypeEnum extends Enum
{
}



================================================
FILE: app/Enums/UserListTypeEnum.php
================================================
<?php

namespace App\Enums;


use Spatie\Enum\Laravel\Enum;

/**
 * @method static self anime()
 * @method static self manga()
 */
final class UserListTypeEnum extends Enum
{
}



================================================
FILE: app/Enums/UserMangaListOrderByEnum.php
================================================
<?php

namespace App\Enums;


use Spatie\Enum\Laravel\Enum;
use Jikan\Helper\Constants as JikanConstants;

/**
 * @method static self title()
 * @method static self started_date()
 * @method static self score()
 * @method static self last_updated()
 * @method static self priority()
 * @method static self progress()
 * @method static self chapters_read()
 * @method static self volumes_read()
 * @method static self type()
 * @method static self publish_start(